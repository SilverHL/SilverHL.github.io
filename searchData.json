[{"title":"Nginx处理一次HTTP请求","url":"/2020/08/27/Nginx处理一次HTTP请求/","content":"\n\n完成的一次调用链 (开新坑，后面补上)\nngx_process_events_and_timers               -- worker/simple 进程循环\n|\n|-->ngx_epoll_process_events                -- 多路复用处理事件的入口 \n    |\n    |->ngx_event_accept                     -- 准备accept新的连接  connection对应的回调\n       |\n       |->ngx_http_init_connection          -- 初始化新的连接\n          |\n          |->ngx_handle_read_event          -- 将新连接的事件加入到多路复用\n             |\n             |->ngx_event_actions.add\n\n\n\nngx_process_events_and_timers \n \n  ngx_epoll_process_events\n    \n    ngx_http_init_request\n      \n      ngx_http_process_requeset_line","tags":["Nginx"]},{"title":"Nginx父子进程通信","url":"/2020/08/24/Nginx父子进程通信/","content":"\n"},{"title":"Nginx进程","url":"/2020/08/19/Nginx进程/","content":"\nnginx中一般的架构是由一个master进程管理N(一般与CPU核心数相同)个worker子进程，而当子进程挂掉，或者配置变更，需要重新读取配置，又或者更新了二进制文件，需要更新master进程，都需要有master进程来通过一个统一的ngx_process_spawn方法来启动子进程。\n\n## 进程类型\n\n我们先来看一下有几种进程以及对应的使用场景。\n\n> \\#define NGX_PROCESS_NORESPAWN     -1\n> \\#define NGX_PROCESS_JUST_SPAWN    -2\n> \\#define NGX_PROCESS_RESPAWN       -3\n> \\#define NGX_PROCESS_JUST_RESPAWN  -4\n> \\#define NGX_PROCESS_DETACHED      -5\n\n首先， NGX_PROCESS_NORESPAWS 以及 NGX_PROCESS_JUST_SPAWN都是用于cache_manager子进程的，暂且不提。\n\nNGX_PROCESS_RESPAWN是用于正常流程下，master进程拉起worker子进程的时候，比如刚启动的时候，就会使用这个标志拉起子进程。\n\nNGX_PROCESS_DETACHED是当二进制文件有更新的时候，master会传入这个标志重新拉起一个进程，pid记录在ngx_new_binary中，然后进行分离，逐渐由新进程来接管master的工作。\n\nNGX_JUST_RESPAWN是当配置有更新的时候，比如调用nginx -s reload, nginx会有以下的行为:\n- 二进制文件如果有更新的话(此时已经通过ngx_change_binary标志分离了一个新的master进程)，会用新的master进程通过NGX_PROCESS_RESPAWN拉起一批普通子进程。\n- 重新加载整个cycle, 拉取到最新的配置后，拉起一批NGX_PROCESS_JUST_RESPAWN标志的子进程，用以区分新旧进程。\n- 向旧的进程(即NGX_PROCESS_RESPAWN的子进程)发送SIGQUIT信号，进程关闭进程间通信的channel，然后优雅退出。\n\n那么nginx是如何区分进程的不同类型呢？其实是通过每个进程的标志位来区分的，先来看下nginx中单个进程的struct。\n\n```C\ntypedef struct {\n    // 进程的pid\n    ngx_pid_t           pid;\n    // waitpid 系统调用返回的进程状态\n    int                 status;\n    // 与父进程通信的channel\n    ngx_socket_t        channel[2];\n\n    // 子进程循环执行的方法\n    ngx_spawn_proc_pt   proc;\n    // proc的参数\n    void               *data;\n    char               *name;\n\n    unsigned            respawn:1;\n    unsigned            just_spawn:1;\n    unsigned            detached:1;\n    unsigned            exiting:1;\n    unsigned            exited:1;\n} ngx_process_t;\n```\n每种不同类型的进程会通过设置这些标志位来区分这些进程。\n\n```C\n    switch (respawn) {\n\n    case NGX_PROCESS_NORESPAWN:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_JUST_SPAWN:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 1;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_RESPAWN:\n        ngx_processes[s].respawn = 1;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_JUST_RESPAWN:\n        ngx_processes[s].respawn = 1;\n        ngx_processes[s].just_spawn = 1;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_DETACHED:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 1;\n        break;\n    }\n```\n\n## ngx_process_spawn方法\n然后来看下今天的主角， ngx_process_spawn方法。\n\n> ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data, char *name, ngx_int_t respawn)\n\n第一个参数是nginx的循环，然后是子进程一直会循环的方法，第三个是需要传给proc的数组，name是进程的名字，respawn就是拉起进程的时候传入的类型。\n\n我们现在来具体分析一下这个方法的流程。\n\n```C\nngx_pid_t\nngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,\n    char *name, ngx_int_t respawn)\n{\n    u_long     on;\n    ngx_pid_t  pid;\n    ngx_int_t  s;\n\n    // 如果respawn >= 0 实际是为了填充ngx_processes数组，此时的respawn是数组的index\n\n    /**\n    * 可以看到，进程的类型(上面的几种#define)实际上都是小于0的，那么什么时候会走到这个循环里呢？\n    * 实际是当子进程意外退出，父进程会对这个特定的子进程重新调用ngx_spawn_process方法，此时传入的respawn实际是挂掉的子进程在ngx_processes全局进程数组中的index，\n    * 并且这里的s也会被赋值为respawn，也就是说:\n    * 在这种情况下调用的ngx_spawn_process实际是将新生成的进程填入了原进程在数组中的位置。\n    * **/ \n    if (respawn >= 0) {\n        s = respawn;\n\n    } else {\n        // 从0开始，取到第一个可用的slot\n        for (s = 0; s < ngx_last_process; s++) {\n            if (ngx_processes[s].pid == -1) {\n                break;\n            }\n        }\n\n        // 没有的话说明进程数组为空了，返回 INVALID_PID\n        if (s == NGX_MAX_PROCESSES) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n                          \"no more than %d processes can be spawned\",\n                          NGX_MAX_PROCESSES);\n            return NGX_INVALID_PID;\n        }\n    }\n\n\n    // 如果此次调用不是为了拉起分离进程\n    if (respawn != NGX_PROCESS_DETACHED) {\n\n        /* Solaris 9 still has no AF_LOCAL */\n\n        // 通过socketpair系统调用进行父子进程通信\n        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)\n        {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"socketpair() failed while spawning \\\"%s\\\"\", name);\n            return NGX_INVALID_PID;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n                       \"channel %d:%d\",\n                       ngx_processes[s].channel[0],\n                       ngx_processes[s].channel[1]);\n\n        // 设置通信的fd nonblocking\n        if (ngx_nonblocking(ngx_processes[s].channel[0]) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_nonblocking_n \" failed while spawning \\\"%s\\\"\",\n                          name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        if (ngx_nonblocking(ngx_processes[s].channel[1]) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_nonblocking_n \" failed while spawning \\\"%s\\\"\",\n                          name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        on = 1;\n        if (ioctl(ngx_processes[s].channel[0], FIOASYNC, &on) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"ioctl(FIOASYNC) failed while spawning \\\"%s\\\"\", name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        if (fcntl(ngx_processes[s].channel[0], F_SETOWN, ngx_pid) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"fcntl(F_SETOWN) failed while spawning \\\"%s\\\"\", name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        if (fcntl(ngx_processes[s].channel[0], F_SETFD, FD_CLOEXEC) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"fcntl(FD_CLOEXEC) failed while spawning \\\"%s\\\"\",\n                           name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        if (fcntl(ngx_processes[s].channel[1], F_SETFD, FD_CLOEXEC) == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"fcntl(FD_CLOEXEC) failed while spawning \\\"%s\\\"\",\n                           name);\n            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n            return NGX_INVALID_PID;\n        }\n\n        ngx_channel = ngx_processes[s].channel[1];\n\n    } else {\n        // 否则关闭父子进程的通信channel\n        ngx_processes[s].channel[0] = -1;\n        ngx_processes[s].channel[1] = -1;\n    }\n\n    ngx_process_slot = s;\n\n    // fork子进程出来\n    pid = fork();\n\n    switch (pid) {\n\n    case -1:\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      \"fork() failed while spawning \\\"%s\\\"\", name);\n        ngx_close_channel(ngx_processes[s].channel, cycle->log);\n        return NGX_INVALID_PID;\n\n    case 0:\n        // 子进程继续proc方法\n        ngx_pid = ngx_getpid();\n        proc(cycle, data);\n        break;\n\n    default:\n        break;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"start %s %P\", name, pid);\n\n    ngx_processes[s].pid = pid;\n    ngx_processes[s].exited = 0;\n\n    if (respawn >= 0) {\n        return pid;\n    }\n\n    ngx_processes[s].proc = proc;\n    ngx_processes[s].data = data;\n    ngx_processes[s].name = name;\n    ngx_processes[s].exiting = 0;\n\n    switch (respawn) {\n\n    case NGX_PROCESS_NORESPAWN:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_JUST_SPAWN:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 1;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_RESPAWN:\n        ngx_processes[s].respawn = 1;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_JUST_RESPAWN:\n        ngx_processes[s].respawn = 1;\n        ngx_processes[s].just_spawn = 1;\n        ngx_processes[s].detached = 0;\n        break;\n\n    case NGX_PROCESS_DETACHED:\n        ngx_processes[s].respawn = 0;\n        ngx_processes[s].just_spawn = 0;\n        ngx_processes[s].detached = 1;\n        break;\n    }\n\n    if (s == ngx_last_process) {\n        ngx_last_process++;\n    }\n\n    return pid;\n}\n```\n\n这就是nginx重新生成子进程的流程。","tags":["Nginx"]},{"url":"/2020/08/19/Untitled/"},{"title":"Linux进程API","url":"/2020/08/19/Linux进程API/","content":"\n来看下Linux下的进程相关的API。\n\n\n\n## 父子进程\n\n\n\n## waitpid \n\n>SYNOPSIS\n>\n>\\#include <sys/types.h>\n>\n>\\#include <sys/wait.h>\n\n>       pid_t wait(int *status);\n>    \n>       pid_t waitpid(pid_t pid, int *status, int options);\n>    \n\n 这一系列的函数都是为了等待调用进程的子进程的状态改变而存在的，我们来看下waitpid(),第一个参数是一个pid_t类型，取值范围有:\n\n- < -1，代表等待进程组id为|pid|的子进程状态改变。\n- == -1，代表等待pid为任意的子进程状态改变。\n- == 0，代表等待进程组id为调用进程的子进程状态改变。\n- \\> 0，代表等待pid为pid的子进程状态改变。\n\n返回值的话，如果没有子进程状态改变返回0，-1的话说明被打断或者pid不存在，正常返回的就是状态改变的子进程。","tags":["Linux"]},{"title":"Linux下信号API","url":"/2020/08/16/Linux下信号API/","content":"\n# Linux 下的信号API\n\n之前在看Nginx源码，因为Nginx的许多行为都是通过信号来进行改变的， 比如nginx -s reload或者 改变二进制文件等，今天特意来整理下信号相关的API。\n\n## Linux下的信号处理阶段\n\n先放一张图：\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/test/signal_process.png)\n\n信号从发出到实际调用handler去处理，可能会经历以下几个阶段，有Blocking(阻塞)，Pending(未决)， Delivery(递达) (但是实际上Blocking与Pending应该是同一个阶段，接下来会说明)。\n\n一个信号，被系统调用实际的handler处理的时候，被称为Delivery(递达)状态，在递达状态之前，该信号<strong>一直都是未决(Pending)状态</strong>的，当然被目标进程block的信号会持续保持未决状态，直到该信号被unblock。而SIGIGNORE只是一个递达态的信号的handler，代表我对这个信号不做任何处理，<strong>此处应当与信号被阻塞区分开来。</strong>\n\n\n## Linux下的信号API\n\n### 基础数据结构及操作函数\n\n先来看下基础的数据结构sigset_t\n\n```C\ntypedef struct {\n\tunsigned long sig[_NSIG_WORDS];\n} sigset_t;\n```\n\nsigset_t表示的是一组信号，即一个信号集，然后来看下对信号集的操作。\n\n\n```C\n#include <signal.h>\n\nint sigemptyset(sigset_t *set)；\n\nint sigfillset(sigset_t *set)；\n\nint sigaddset(sigset_t *set, int signum)\n\nint sigdelset(sigset_t *set, int signum)；\n\nint sigismember(const sigset_t *set, int signum)；\n```\n\n写个代码试下：\n\n```C\n#include <stdio.h>\n#include <signal.h>\n\nvoid test_signal_number();\nvoid travse_set(sigset_t *);\nint main()\n{\n    test_signal_number();\n}\n\n\nvoid test_signal_number()\n{\n    sigset_t set;\n    sigempty(&set);\n    sigaddset(&set, SIGUSR1);\n    sigaddset(&set, SIGHUP);\n    sigaddset(&set, SIGTERM);\n\n    travse_set(&set);\n}\n\nvoid travse_set(sigset_t *set) \n{\n    for (int i = 0; i < NSIG; i++) {\n        if (sigismember(set, i)) {\n            printf(\"1\");\n        } else {\n            printf(\"0\");\n        }\n    }\n}\n```\n\n编译下，输出结果如下：\n> 11000000001000010000000000000000000000000000000000000000000000000\n\n可以看到，在信号集里的信号都输出了1，再来看下别的信号操作函数.\n\n### 信号阻塞及未决操作相关函数\n\n```C\n#include <signal.h>\n\nint  sigprocmask(int  how,  const  sigset_t *set, sigset_t *oldset))；\n\nint sigpending(sigset_t *set));\n\nint sigsuspend(const sigset_t *mask))；\n```\n\nsigprocmask看下man手册的定义及使用方法:\n\n>NAME\n>       sigprocmask - examine and change blocked signals\n>\n>SYNOPSIS\n>       #include <signal.h>\n>\n>       int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n>\n>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):\n>\n>       sigprocmask(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE\n>\n>DESCRIPTION\n>       sigprocmask() is used to fetch and/or change the signal mask of the calling thread.  The signal mask is the set of signals whose delivery is currently blocked for the caller\n>       (see also signal(7) for more details).\n>\n>       The behavior of the call is dependent on the value of how, as follows.\n>\n>       SIG_BLOCK\n>              The set of blocked signals is the union of the current set and the set argument.\n>\n>       SIG_UNBLOCK\n>              The signals in set are removed from the current set of blocked signals.  It is permissible to attempt to unblock a signal which is not blocked.\n>\n>       SIG_SETMASK\n>              The set of blocked signals is set to the argument set.\n>\n>       If oldset is non-NULL, the previous value of the signal mask is stored in oldset.\n>\n>       If set is NULL, then the signal mask is unchanged (i.e., how is ignored), but the current value of the signal mask is nevertheless returned in oldset (if it is not NULL).\n>\n>       The use of sigprocmask() is unspecified in a multithreaded process; see pthread_sigmask(3).\n\n可以看到，sigprocmask实际是用于改变调用线程的信号掩码，所有在该信号掩码中的信号，在被线程收到时都将会陷入到block状态中，how参数有如下三个值：\n\nSIG_BLOCK: block set中所有的信号, 即调用后，当前线程中的屏蔽集应该是set参数与原屏蔽集的交集。\nSIG_UNBLIOCK: unblock set中的所有信号，如果当前被传入的set中存在当前线程未block的信号也是被允许的, 即调用后，当前线程中的屏蔽即应该是去掉原线程与set参数的交集。\nSIG_SETMASK: 直接将当前线程的屏蔽集设置为set参数，即调用后，当前线程的屏蔽集为set。\n\n同时也特别说明了, 如果oldset参数是NON-NULL的, 旧的参数会被传入到oldset中。\n\n下面来看下sigpending方法的用法。\n\n>SYNOPSIS\n>       #include <signal.h>\n>\n>       int sigpending(sigset_t *set);\n>\n>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):\n>\n>       sigpending(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE\n>\n>DESCRIPTION\n>       sigpending()  returns  the  set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked).  The mask of pending\n>       signals is returned in set.\n\n可以看到，sigpending是获取所有当前线程收到的未决状态的信号并存到set参数中。\n\n然后是sigsuspend方法。\n\n>SYNOPSIS\n>       #include <signal.h>\n>\n>       int sigsuspend(const sigset_t *mask);\n>\n>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):\n>\n>       sigsuspend(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE\n>\n>DESCRIPTION\n>       sigsuspend() temporarily replaces the signal mask of the calling process with the mask given by mask and then suspends the process until delivery of a signal whose action is\n>       to invoke a signal handler or to terminate a process.\n>\n>       If the signal terminates the process, then sigsuspend() does not return.  If the signal is caught, then sigsuspend() returns after the signal handler returns, and the signal\n>       mask is restored to the state before the call to sigsuspend().\n>\n>       It is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect on the process's signal mask.\n>\nsigsuspend会暂时用mask参数中的参数去替换当前进程的信号掩码(即当前进程屏蔽的信号)，然后停止当前进程的执行，直到收到mask中的信号，调用对应的处理函数(handler)，并在handler返回后返回，恢复原进程的信号掩码，继续向下执行。\n\n写段代码来验证一下这几个函数。\n\n\n```C\n#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n\n#define ERR_MSG(errno) do { \\\n    perror(errno); \\\n    exit(-1); \\ \n} while (0) \\\n\n\nvoid test_signal_number();\nvoid sig_usr2_handler(int);\n\nint main()\n{\n    sigset_t set;\n    sigset_t pset;\n    struct sigaction act;\n\n    sigemptyset(&set);\n    sigaddset(&set, SIGUSR1);\n    sigaddset(&set, SIGHUP);\n    sigaddset(&set, SIGTERM);\n    act.sa_handler = sig_usr2_handler;\n\n    if (sigaction(SIGUSR2, &act, NULL) == SIG_ERR) {\n        ERR_MSG(\"sigaction error\");\n    }\n    if (sigprocmask(SIG_BLOCK, &set, NULL) == SIG_ERR) {\n        ERR_MSG(\"sigprocmask error\");\n    }\n\n    for ( ; ;) {\n        sigpending(&bset);\n        printsigset(&bset);\n        sleep(2);\n    }\n}\n\nvoid sig_usr2_handler(int signo)\n{\n    printf(\"sig_usr2_handler\\n\");\n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGHUP);\n    sigprocmask(SIG_UNBLOCK, &set, NULL);\n}\n\nvoid printsigset(sigset_t *set)\n{\n    int i;\n    for (i=1; i<NSIG; ++i)\n    {\n        if (sigismember(set, i))\n            putchar('1');\n        else\n            putchar('0');\n    }\n    printf(\"\\n\");\n}\n\n```\n\n首先将 SIGUSR1, SIGHUP, SIGTERM加入到信号集中，并将这些信号屏蔽，然后在SIGUSR2的handler中将SIGHUP信号unblock,然后2秒查看当前收到的未决信号。\n\n我们先向进程发送一个SIGHUP信号，然后发现每次打印的信号集中都有SIGHUP信号，这是因为SIGHUP信号被屏蔽，一直处在未决状态，然后发送SIGUSR2信号，会发现进程因为收到SIGHUP挂掉，符合预期。\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/test/kill_HUP_N_USR2.png)\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/test/SIGHUP_unblock.png)\n\n### 信号handler设置\n\n> int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n\n这个函数第一个参数指定了某个信号，第二个参数是一个复杂的结构体，我们来看下具体的结构。\n\n```C\nstruct sigaction {\n    void     (*sa_handler)(int);\n    void     (*sa_sigaction)(int, siginfo_t *, void *);\n    sigset_t   sa_mask;\n    int        sa_flags;\n    void     (*sa_restorer)(void);\n};\n```\n可以看到，第一个成员sa_handler与第二个成员sa_sigaction都是函数指针，sa_handler比较像signal()函数，接受信号的值为参数。第二个sa_sigaction实际上是比较详细的记录了一些信息，这个会在sa_flags指定SA_SIGINFO参数的时候，才会使用sa_sigaction作为handler。sa_mask指定了在运行handler的时候需要block的信号，如果sa_flags中未设置SA_NODEFER的话，当前在处理的信号也会被屏蔽。\n\nsa_sigaction的第二个参数指向一个siginfo_结构体，看下里面的结构。\n\n```C\nsiginfo_t {\n    int      si_signo;    /* Signal number */\n    int      si_errno;    /* An errno value */\n    int      si_code;     /* Signal code 如何接受信号 / 从何处收到*/\n    int      si_trapno;   /* Trap number that caused\n                             hardware-generated signal\n                             (unused on most architectures) */\n    pid_t    si_pid;      /* Sending process ID */\n    uid_t    si_uid;      /* Real user ID of sending process */\n    int      si_status;   /* Exit value or signal */\n    clock_t  si_utime;    /* User time consumed */\n    clock_t  si_stime;    /* System time consumed */\n    sigval_t si_value;    /* Signal value */\n    int      si_int;      /* POSIX.1b signal */\n    void    *si_ptr;      /* POSIX.1b signal */\n    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */\n    int      si_timerid;  /* Timer ID; POSIX.1b timers */\n    void    *si_addr;     /* Memory location which caused fault */\n    long     si_band;     /* Band event (was int in\n                             glibc 2.3.2 and earlier) */\n    int      si_fd;       /* File descriptor */\n    short    si_addr_lsb; /* Least significant bit of address\n                             (since Linux 2.6.32) */\n}\n```\n### 发送信号sigqueue\n\n> int sigqueue(pid_t pid, int sig, const union sigval value);\n\nsigqueue用于向进程号为pid的发送sig信号，第三个参数指定了一个union，我们来看下其中的具体内容。\n\n```C\nunion sigval {\n    int   sival_int;\n    void *sival_ptr;\n};\n```\n如果收到信号的进程为该信号安装了handler，并且安装的时候sa_flags中使用了SA_SIGINFO，那么sa_sigaction的siginfo_t.si_value就可以通过这个sigval获取到值，并且siginfo_t.si_code字段也会被设置成SI_QUEUE, 代表这个信号是通过sigqueue收到的。\n\n通过一段代码来验证下这两个API。\n\n```C\n#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n\n#define ERR_MSG(errno) do { \\\n    perror(errno); \\\n    exit(-1); \\ \n} while (0) \\\n\n\nvoid test_signal_number();\nvoid sig_handler (int sig, siginfo_t *sig_info, void *osig);\n\nint main()\n{\n    sigset_t set;\n    sigset_t pset;\n    struct sigaction act;\n    union sigval val;\n\n    sigemptyset(&set);\n    sigaddset(&set, SIGUSR1);\n    sigaddset(&set, SIGHUP);\n    sigaddset(&set, SIGTERM);\n\n    act.sa_sigaction = sig_handler;\n    act.sa_flags |= SA_NODEFER | SA_SIGINFO;\n    sigaddset(&act.sa_mask,SIGTERM);\n\n    if (sigaction(SIGUSR1, &act, NULL) == -1) {\n        ERR_MSG(\"sigaction error\");\n    }\n\n    val.sival_int = 123123;\n\n    int pid = getpid();\n    if (pid == -1) {\n        ERR_MSG(\"getpid error\");\n    }\n    sigqueue(pid, SIGUSR1, val);\n}\n\nvoid sig_handler(int sig, siginfo_t *sig_info, void *osig)\n{\n    printf(\"sig_handler\");\n    printf(\"%d\", sig_info->si_value.sival_int);\n}\n\n```\n\n可以看到，在安装信号的时候，把sa_flags设置了SA_SIGINFO，代表发送信号的时候需要传信息给handler，并且将sa_sigaction安装为信号的handler，第二个参数就是我们需要安装的handler以及一些flag，因为把sa_flag中设置了SA_SIGINFO字段，所以实际是用了sa_sigaction作为handler，其中，sa_sigaction的第二个字段siginfo_t，是代表我们会在发信号的时候传递一些信息过去，我们在handler中读取这个数据，并且打印出来。我们在sigqueue发送信号的时候，携带了一个sigval, 并且把union中的数字设置为123123，我们看下运行结果。\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/test/sigqueue.png)\n\n结果符合预期，这篇就先写到这里。\n\n\n```C\n#ifndef _SIGNAL_H\n#defing _SIGNAL_H\n \n#include<sys/types.h>\ntypedef int sig_atomic_t;\ntypedef unsigned int sigset_t;\n \n#define _NSIG     32\t\t\t\t\t//定义信号\n#define NSIG      _NSIG\n \n#define SIGHUP\t\t1  //hang up 挂断控制终端或进程\n#define SIGINT\t\t2  //interrupt 来自键盘的中断\n#define SIGQUIE\t\t3  //quit\t退出\n#define SIGILL\t\t4  //illeagle 非法指令\n#define SIGTRAP  \t5  //trap   跟踪断点\n#define SIGABORT\t6  //Abort  异常结束\n#define SIGIOT\t\t6  //IO trap  异常   \n#define SIGUNUSED\t7  //Unused 没有使用\n#define SIGFPE\t\t8  //FPE 协处理器出错\n#define SIGKILL\t\t9  //kill  强迫终止\n#define SIGUSR1\t\t10 //use1  用户信号1,进程可使用\n#define SIGSEGV\t\t11 //segment violation 无效内存引用\n#define SIGUSR2\t\t12 //user2  用户信号2,进程可使用\n#define SIGPIPE\t\t13 //pipe  管道写出错\n#define SIGALRM\t\t14 //alarm  实时定时器报警\n#define SIGTERM\t\t15 //terminate 进程终止\n#define SIGSTKFLT\t16 //stack Fault 栈出错\n#define SIGCHLD\t\t17 //child 子进程停止\n#define SIGCONT\t\t18 //continue 回复进程继续\n#define SIGSTOP\t\t19 //stop  停止进程执行\n#define SIGTSTP\t\t20 //tty stop tty发出停止进程\n#define SIGTTIN\t\t21 //tty in  后台进程请求输入\n#define SIGTTOU\t\t22 //tty out 后台进程请求输出\n \n#define SA_NOCLDSTOP 1 //进程处于停止状态,就不对sigchild进行处理\n#define SA_NOMASK\t 0X40000000\n//不阻止在指定的信号处理程序中再收到该信号\n#define SA_ONESHOT 0X80000000\n//信号句柄一旦被调用就恢复到默认处理句柄\n#define SIG_BLOCK  //在阻塞信号集中加上给定的信号集\n#define SIG_UNBLOCK//从阻塞信号集中删除指定的信号集\n#define SIG_SETMASK//设置阻塞信号集(信号屏蔽码)\n \n#define SIG_DFL \t((void(*)(int))0) //默认信号处理程序\n#define SIG_IGN\t\t((void (*)(int))1)//忽略信号处理程序\n#define \n \n/*\n*这是sigaction数据结构.sa_handler是对因某信号指定要采取的行动,可以使用上面的SIG_DFL,\n*SIG_IGN.也可以指向处理该信号函数的一个指针.\n*sa_mask给出了对信号的屏蔽码,在信号程序执行时将阻塞对这些信号的处理\n*sa_flag指定改变信号处理过程的信号集\n*sa_restorer是恢复函数指针，由函数库libc提供\n*另外，引起触发信号处理的信号也将被阻塞,\n*/\nstruct sigaction{\n\t\t\t\tvoid (*sa_handler)(int);\n\t\t\t\tsigset_t sa_mask;\n\t\t\t\tint sa_flags;\n\t\t\t\tvoid (*sa_restorer)(void);\n\t};\n\t\n//signal用于向信号_sig安装一个新的信号处理函数\nvoid (*signal(int _sig,void (*_func)(int)))(int);\n \n//raise用于向当前进程自身发信号,kill用于向任何进程或进程组发任何信号\nint raise(int sig);\nint kill(pid_t pid,int sig);\n/*\n*进程的任务结构中有一个以比特位表示当前进程待处理的32位信号段signal,还有一个\n*同样以比特位表示的用于屏蔽进场当前阻塞信号集合blocked。\n*\n*/\n \n//sigaddset和sigdelset用于对信号集中的信号进行增减修改.\n//sigaddset用于向mask指向的信号集合增加指定的信号signo,sigdelset则相反\nint sigaddset(sigset_t *mask,int signo);\nint sigdelset(sigset_t *mask,int signo);\n \n//sigemptyset和sigfillset用于初始化进程屏蔽信号集，每个程序在使用信号集前,都需要使用\n//这两个函数之一对屏蔽信号集进行初始化.sigemptyset用于清空屏蔽的所有信号，也即\n//响应所有信号,sigfillset向信号集加入所有信号,也即屏蔽所有信号\nint sigemptyset(sigset_t *mask);\nint sigfillset(sigset_t *mask);\n//用于测试一个指定信号是否在信号集中\nint sigismember(sigset_t *mask,int signo);\n \n//对set中断额信号进行检测，看是否有挂起的信号,\n//在set中返回进程中当前被阻塞的信号集\nint sigpending(sigset_t *set);\n \n//用于改变进程目前被阻塞的信号集.若oldset不是null，则通过其返回进程当前屏蔽\n信号集,若set指针不是null,则根据how指示修改进程屏蔽信号集\nint sigprocmask(int how,sigset_t *set,sigset_t *oldset);\n \n//用于sigmask临时替换进程的信号屏蔽码，然后暂停该进程直到收到一个信号\n//若捕捉到一个信号并从该信号处理程序中返回,该函数也返回,并信号屏蔽码会恢复到\n//调用前的值\nint sigsuspend(sigset_t *sigmask);\n \n//sigaction用于改变进程在收到指定信号时所采取的的行动\nint sigaction(int sig,struct sigaction *act,sigaction *oldact);\n \n```","tags":["Linux"]},{"title":"Nginx启动流程","url":"/2020/06/09/Nginx启动流程/","content":"\n# Nginx启动流程记录\n\n看《深入理解Nginx》已经很久了，还是决定开始写博客来记录下，来回顾看书学到的东西。\n\n\n## Nginx模块\n\nNginx模块化做的十分优秀，这其实得益于ngx本身的数据结构，先看最基本的模块 ngx_module_t\n\n```c\nstruct ngx_module_s {\n    // 当前模块在本类模块中的顺序   如 http_core_module在所有http模块中的顺序\n    ngx_uint_t            ctx_index;   \n    // 当前类模块在所有模块中的顺序 如 一个http模块在 http src loc模块中的顺序\n    ngx_uint_t            index;        \n\n    ngx_uint_t            spare0;\n    ngx_uint_t            spare1;\n    ngx_uint_t            spare2;\n    ngx_uint_t            spare3;\n\n    ngx_uint_t            version;\n\n    // 指向当前这类模块的公共接口 比如http模块 / mail模块等等，分别对应一系列不容的接口集合\n    void                 *ctx; \n    ngx_command_t        *commands; // 指向这个模块对应的所有命令\n    ngx_uint_t            type; // 模块类型\n\n    /**\n     * 这7个方法在nginx的执行过程中扮演重要角色\n     */\n    ngx_int_t           (*init_master)(ngx_log_t *log);\n\n    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);\n\n    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);\n    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);\n    void                (*exit_thread)(ngx_cycle_t *cycle);\n    void                (*exit_process)(ngx_cycle_t *cycle);\n\n    void                (*exit_master)(ngx_cycle_t *cycle);\n\n    uintptr_t             spare_hook0;\n    uintptr_t             spare_hook1;\n    uintptr_t             spare_hook2;\n    uintptr_t             spare_hook3;\n    uintptr_t             spare_hook4;\n    uintptr_t             spare_hook5;\n    uintptr_t             spare_hook6;\n    uintptr_t             spare_hook7;\n};\n```\n\n通过ctx字段，我们可以获取到当前这一类型的模块中包含的所有公共接口，通过实现这些公共接口，我们可以定制自己的模块。\n\n某类型的模块所包含的公共接口是一样的，共有核心模块，HTTP模块，Mail模块，事件模块，配置模块这几种，其中，核心模块中包括ngx_http_module, ngx_mail_module, ngx_events_module,ngx_errlog_module,ngx_openssl_module,ngx_core_module，每一个核心模块的ctx转成了ngx_core_module_t,类型如下：\n\n```C\ntypedef struct {\n    //当前核心模块的名字\n    ngx_str_t             name; \t\n    void               *(*create_conf)(ngx_cycle_t *cycle);\n    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);\n} ngx_core_module_t\n```\n\n\n\n而每个核心模块都定义了一种类型的模块，核心模块下的模块都属于这种类型，而每种类型模块的ctx接口也都具象成了不同的公共接口集合。\n\n\n\n## ngx_listening_t 类型\n\nNgx_listening_t是nginx用来监听端口的类型，这个应该是在启动的时候就把所有需要监听的端口都初始化成这个结构体了。而且ngx_cycle_t应该会有一个array专门存放所有的ngx_listening_t类型。\n\n\n\n```C\nstruct ngx_listening_s {\n    ngx_socket_t        fd;\n\n    // 监听的地址\n    struct sockaddr    *sockaddr;\n    socklen_t           socklen;    /* size of sockaddr */\n  \n    // addr_text最大长度\n    size_t              addr_text_max_len;\n    // 以字符形式存储ip address\n    ngx_str_t           addr_text;\n    // 套接字类型\n    int                 type;\n\n    // backlog队列 size\n    int                 backlog;\n    // 接收缓冲区大小\n    int                 rcvbuf;\n    // 发送缓冲区大小\n    int                 sndbuf;\n\n    /* handler of accepted connection */\n    // TCP连接建立后的处理方法\n    ngx_connection_handler_pt   handler;\n\n    // 用于HTTP / mail模块 保存监听端口对应的主机名\n    void               *servers;  /* array of ngx_http_in_addr_t, for example */\n\n    ngx_log_t           log;\n    ngx_log_t          *logp;\n\n    // 内存池初始大小 为TCP连接创建的内存池\n    size_t              pool_size;\n    /* should be here because of the AcceptEx() preread */\n    size_t              post_accept_buffer_size;\n    /* should be here because of the deferred accept */\n    // TCP_DEFER_ACCEPT 选项 post_accept_timeout秒内未收到建立成功的客户端的用户数据就断开连接\n    ngx_msec_t          post_accept_timeout;\n\n    // 前一个ngx_listening_t结构\n    ngx_listening_t    *previous;\n    // 当前监听句柄对应的connection\n    ngx_connection_t   *connection;\n\n    // 为1表示当前句柄有效 执行ngx_init_cycle时不关闭监听端口\n    unsigned            open:1;\n    unsigned            remain:1;\n    unsigned            ignore:1;\n\n    unsigned            bound:1;       /* already bound */\n    unsigned            inherited:1;   /* inherited from previous process */\n    unsigned            nonblocking_accept:1;\n    unsigned            listen:1;\n    unsigned            nonblocking:1;\n    unsigned            shared:1;    /* shared between threads or processes */\n    unsigned            addr_ntop:1;\n\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n    unsigned            ipv6only:2;\n#endif\n\n#if (NGX_HAVE_DEFERRED_ACCEPT)\n    unsigned            deferred_accept:1;\n    unsigned            delete_deferred:1;\n    unsigned            add_deferred:1;\n#ifdef SO_ACCEPTFILTER\n    char               *accept_filter;\n#endif\n#endif\n#if (NGX_HAVE_SETFIB)\n    int                 setfib;\n#endif\n\n};\n```\n\n\n\n```C\nstruct ngx_cycle_s {\n    // 一个数组 其中存储的是指针\n    // 每个指针又指向一个存储着指针的数组\n    // 指向的是配置项结构体\n    // 第一个指针指向的是模块下的配置 比如ngx_http_module模块 排第7位\n    // 那么 conf_ctx[6] 指向的就是ngx_http_conf_ctx_t\n    // 感觉这个4层指针就是为了ngx_http_module准备的\n    void                  ****conf_ctx;\n    // 内存池\n    ngx_pool_t               *pool;\n\n    // 没有解析配置前 通过log输出到屏幕\n    // 配置解析完成以后 会用new_log覆盖log的值\n    ngx_log_t                *log;\n    ngx_log_t                 new_log;\n\n    ngx_connection_t        **files;\n    // 可用连接池\n    ngx_connection_t         *free_connections;\n    ngx_uint_t                free_connection_n;\n\n    // 可重复使用的连接队列\n    ngx_queue_t               reusable_connections_queue;\n\n    // 表示监听的端口及相关参数\n    // 每一个elt都是一个ngx_listening_t\n    ngx_array_t               listening;\n    // nginx所有要操作的目录 不存在的会试图创建\n    ngx_array_t               pathes;\n    // 所有打开的文件 由感兴趣的模块向其中添加文件\n    ngx_list_t                open_files;\n    // 共享内存的链表\n    // ngx_shm_zone_t 结构\n    ngx_list_t                shared_memory;\n\n   // 配合connections使用\n    ngx_uint_t                connection_n;\n    ngx_uint_t                files_n;\n\n    // 所有连接对象 每个连接的index都可以在read_events和write_events中取到对应的读事件和写事件\n    ngx_connection_t         *connections;\n    ngx_event_t              *read_events;\n    ngx_event_t              *write_events;\n\n    ngx_cycle_t              *old_cycle;\n\n    // 配置文件相对于安装目录的路径\n    ngx_str_t                 conf_file;\n    // 命令行参数\n    ngx_str_t                 conf_param;\n    // 配置文件所在目录\n    ngx_str_t                 conf_prefix;\n    // 安装目录\n    ngx_str_t                 prefix;\n    // 进程同步的文件锁\n    ngx_str_t                 lock_file;\n    ngx_str_t                 hostname;\n};\n```\n\n\n## Nginx信号处理\n\n偏个题，来分析一下nginx对于nginx -s reload这样的命令是怎么实现的。\n\n```C\nstatic ngx_int_t\nngx_get_options(int argc, char *const *argv)\n{\n    u_char     *p;\n    ngx_int_t   i;\n\n    for (i = 1; i < argc; i++) {\n\n        p = (u_char *) argv[i];\n\n        if (*p++ != '-') {\n            ngx_log_stderr(0, \"invalid option: \\\"%s\\\"\", argv[i]);\n            return NGX_ERROR;\n        }\n\n        while (*p) {\n\n            switch (*p++) {\n            case ...:\n                ...\n         \n            case 's':\n                if (*p) {\n                    ngx_signal = (char *) p;\n\n                } else if (argv[++i]) {\n                    ngx_signal = argv[i];\n\n                } else {\n                    ngx_log_stderr(0, \"option \\\"-s\\\" requires parameter\");\n                    return NGX_ERROR;\n                }\n\n                if (ngx_strcmp(ngx_signal, \"stop\") == 0\n                    || ngx_strcmp(ngx_signal, \"quit\") == 0\n                    || ngx_strcmp(ngx_signal, \"reopen\") == 0\n                    || ngx_strcmp(ngx_signal, \"reload\") == 0)\n                {\n                    ngx_process = NGX_PROCESS_SIGNALLER;\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"invalid option: \\\"-s %s\\\"\", ngx_signal);\n                return NGX_ERROR;\n\n            default:\n                ngx_log_stderr(0, \"invalid option: \\\"%c\\\"\", *(p - 1));\n                return NGX_ERROR;\n            }\n        }\n\n    next:\n        continue;\n    }\n    return NGX_OK;\n}\n\n```\n\n这是nginx刚启动的时候会调用的`ngx_int_t ngx_get_options(int argc, char *const *argv)`函数，通过这个函数，可以解析传进来的参数。别的抛开不谈，我们来看下case 's'的时候，首先将ngx_signal设置为目标字符串(即`stop/reload/quit/reopen`)，然后分别比较，并将ngx_process设置为NGX_PRICESS_SIGNALLER, 设置这一步的目的在这里：\n\n```C\n    if (ngx_process == NGX_PROCESS_SIGNALLER) {\n        return cycle;\n    }\n```\n\n即，在ngx_init_cycle这里，代码会直接返回，只是重新load了配置，达到了我们运行`nginx -s reload`这种命令的目的。\n\n此外， 设置的ngx_signal在哪里被用到了呢？在调用`ngx_init_cycle`返回以后，找到了如下代码:\n\n```C\n\n// nginx.c main\n   if (ngx_signal) {\n        return ngx_signal_process(cycle, ngx_signal);\n    }\n\n```\n\n现在看下ngx_sigal_process函数做了什么事\n```C\n\n// ngx_cycle.c \nngx_int_t\nngx_signal_process(ngx_cycle_t *cycle, char *sig)\n{\n    ssize_t           n;\n    ngx_int_t         pid;\n    ngx_file_t        file;\n    ngx_core_conf_t  *ccf;\n    u_char            buf[NGX_INT64_LEN + 2];\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"signal process started\");\n\n    // 首先获取ngx_core_module的配置\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    // 获取到pid文件的存储位置 (存储进程号)\n    file.name = ccf->pid;\n    file.log = cycle->log;\n\n    // 打开pid文件 \n    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY,\n                            NGX_FILE_OPEN, NGX_FILE_DEFAULT_ACCESS);\n\n    // 判断文件正常打开\n    if (file.fd == NGX_INVALID_FILE) {\n        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,\n                      ngx_open_file_n \" \\\"%s\\\" failed\", file.name.data);\n        return 1;\n    }\n\n    // 从文件中读出pid \n    n = ngx_read_file(&file, buf, NGX_INT64_LEN + 2, 0);\n\n    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n    }\n\n    if (n == NGX_ERROR) {\n        return 1;\n    }\n\n    // 兼容win和unix 去除末尾的CRLF换行符\n    while (n-- && (buf[n] == CR || buf[n] == LF)) { /* void */ }\n\n    // str to int\n    pid = ngx_atoi(buf, ++n);\n\n    if (pid == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_ERR, cycle->log, 0,\n                      \"invalid PID number \\\"%*s\\\" in \\\"%s\\\"\",\n                      n, buf, file.name.data);\n        return 1;\n    }\n\n    // 正式处理pid\n    return ngx_os_signal_process(cycle, sig, pid);\n\n}\n```\n\n下面看下ngx_os_signal_process做了什么事.\n\n```C\n\ntypedef struct {\n    int     signo;\n    char   *signame;\n    char   *name;\n    void  (*handler)(int signo);\n} ngx_signal_t;\n\n// ngx_process.c\nngx_int_t\nngx_os_signal_process(ngx_cycle_t *cycle, char *name, ngx_int_t pid)\n{\n    ngx_signal_t  *sig;\n\n    // 开始遍历全局的signals数组\n    // 这里的name是从main函数里就传进来的ngx_signal\n    for (sig = signals; sig->signo != 0; sig++) {\n        // 找到数组中对应的那个信号名称\n        if (ngx_strcmp(name, sig->name) == 0) {\n            // 发送对应的信号\n            if (kill(pid, sig->signo) != -1) {\n                return 0;\n            }\n\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          \"kill(%P, %d) failed\", pid, sig->signo);\n        }\n    }\n\n    return 1;\n}\n```\n\n这是实际上是通过kill系统调用来向对应的进程发送了信号，那么是在什么地方为对应的信号设置了相应的处理函数，又将ngx_signal(stop/reload/reopen/quit)与每个信号的ngx_signal_t::name对应起来的呢？通过查看全局signals数组，我找到了这里，通过signals数组对信号进行初始化。\n\n```C\n#if !(NGX_WIN32)\n\n    if (ngx_init_signals(cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (!ngx_inherited && ccf->daemon) {\n        if (ngx_daemon(cycle->log) != NGX_OK) {\n            return 1;\n        }\n\n        ngx_daemonized = 1;\n    }\n\n    if (ngx_inherited) {\n        ngx_daemonized = 1;\n    }\n\n#endif\n```\n\n```C\n// ngx_process.c\n\nngx_int_t\nngx_init_signals(ngx_log_t *log)\n{\n    ngx_signal_t      *sig;\n    struct sigaction   sa;\n\n    // 遍历全局的signals数组\n    for (sig = signals; sig->signo != 0; sig++) {\n        ngx_memzero(&sa, sizeof(struct sigaction));\n        // 设置sa_handler\n        sa.sa_handler = sig->handler;\n        // 处理信号时不屏蔽任何信号\n        sigemptyset(&sa.sa_mask);\n        // 通过sigaction方法安装信号处理函数\n        if (sigaction(sig->signo, &sa, NULL) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          \"sigaction(%s) failed\", sig->signame);\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n```\n\n```C\nngx_signal_t  signals[] = {\n    { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),\n      \"SIG\" ngx_value(NGX_RECONFIGURE_SIGNAL),\n      \"reload\",\n      ngx_signal_handler },\n\n    { ngx_signal_value(NGX_REOPEN_SIGNAL),\n      \"SIG\" ngx_value(NGX_REOPEN_SIGNAL),\n      \"reopen\",\n      ngx_signal_handler },\n\n    { ngx_signal_value(NGX_NOACCEPT_SIGNAL),\n      \"SIG\" ngx_value(NGX_NOACCEPT_SIGNAL),\n      \"\",\n      ngx_signal_handler },\n\n    { ngx_signal_value(NGX_TERMINATE_SIGNAL),\n      \"SIG\" ngx_value(NGX_TERMINATE_SIGNAL),\n      \"stop\",\n      ngx_signal_handler },\n\n    { ngx_signal_value(NGX_SHUTDOWN_SIGNAL),\n      \"SIG\" ngx_value(NGX_SHUTDOWN_SIGNAL),\n      \"quit\",\n      ngx_signal_handler },\n\n    { ngx_signal_value(NGX_CHANGEBIN_SIGNAL),\n      \"SIG\" ngx_value(NGX_CHANGEBIN_SIGNAL),\n      \"\",\n      ngx_signal_handler },\n\n    { SIGALRM, \"SIGALRM\", \"\", ngx_signal_handler },\n\n    { SIGINT, \"SIGINT\", \"\", ngx_signal_handler },\n\n    { SIGIO, \"SIGIO\", \"\", ngx_signal_handler },\n\n    { SIGCHLD, \"SIGCHLD\", \"\", ngx_signal_handler },\n\n    { SIGSYS, \"SIGSYS, SIG_IGN\", \"\", SIG_IGN },\n\n    { SIGPIPE, \"SIGPIPE, SIG_IGN\", \"\", SIG_IGN },\n\n    { 0, NULL, \"\", NULL }\n};\n```\n这是全局signals数组，我们先来看下ngx_signal_value这个宏\n\n```C\n#define ngx_signal_helper(n)     SIG##n\n#define ngx_signal_value(n)      ngx_signal_helper(n)\n\n#define ngx_value_helper(n)   #n\n#define ngx_value(n)          ngx_value_helper(n)\n```\n\n看到实际的ngx_signal_value 实际上是通过宏被转成了SIG开头的Linux标准信号量，然后ngx_value实际是通过宏将信号专程了字符串，即\n> \\#\\# 在宏中可以将两个字符连接起来，而 #是将一个变量两边加上双引号。\n\n我们再来看signals数组本身：\n\n可以看到，大部分信号的handler都是ngx_signal_handler，只有两个信号是忽略处理, 剩下的都是通过ngx_signal_handler来处理.\n\n```C\nvoid\nngx_signal_handler(int signo)\n{\n    char            *action;\n    ngx_int_t        ignore;\n    ngx_err_t        err;\n    ngx_signal_t    *sig;\n\n    ignore = 0;\n\n    err = ngx_errno;\n\n    for (sig = signals; sig->signo != 0; sig++) {\n        if (sig->signo == signo) {\n            break;\n        }\n    }\n\n    ngx_time_sigsafe_update();\n\n    action = \"\";\n\n    switch (ngx_process) {\n\n    case NGX_PROCESS_MASTER:\n    case NGX_PROCESS_SINGLE:\n        switch (signo) {\n\n        case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):\n            ngx_quit = 1;\n            action = \", shutting down\";\n            break;\n\n        case ngx_signal_value(NGX_TERMINATE_SIGNAL):\n        case SIGINT:\n            ngx_terminate = 1;\n            action = \", exiting\";\n            break;\n\n        case ngx_signal_value(NGX_NOACCEPT_SIGNAL):\n            if (ngx_daemonized) {\n                ngx_noaccept = 1;\n                action = \", stop accepting connections\";\n            }\n            break;\n\n        case ngx_signal_value(NGX_RECONFIGURE_SIGNAL):\n            ngx_reconfigure = 1;\n            action = \", reconfiguring\";\n            break;\n\n        case ngx_signal_value(NGX_REOPEN_SIGNAL):\n            ngx_reopen = 1;\n            action = \", reopening logs\";\n            break;\n\n        case ngx_signal_value(NGX_CHANGEBIN_SIGNAL):\n            if (getppid() > 1 || ngx_new_binary > 0) {\n\n                /*\n                 * Ignore the signal in the new binary if its parent is\n                 * not the init process, i.e. the old binary's process\n                 * is still running.  Or ignore the signal in the old binary's\n                 * process if the new binary's process is already running.\n                 */\n\n                action = \", ignoring\";\n                ignore = 1;\n                break;\n            }\n\n            ngx_change_binary = 1;\n            action = \", changing binary\";\n            break;\n\n        case SIGALRM:\n            ngx_sigalrm = 1;\n            break;\n\n        case SIGIO:\n            ngx_sigio = 1;\n            break;\n\n        case SIGCHLD:\n            ngx_reap = 1;\n            break;\n        }\n\n        break;\n\n    case NGX_PROCESS_WORKER:\n    case NGX_PROCESS_HELPER:\n        switch (signo) {\n\n        case ngx_signal_value(NGX_NOACCEPT_SIGNAL):\n            if (!ngx_daemonized) {\n                break;\n            }\n            ngx_debug_quit = 1;\n        case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):\n            ngx_quit = 1;\n            action = \", shutting down\";\n            break;\n\n        case ngx_signal_value(NGX_TERMINATE_SIGNAL):\n        case SIGINT:\n            ngx_terminate = 1;\n            action = \", exiting\";\n            break;\n\n        case ngx_signal_value(NGX_REOPEN_SIGNAL):\n            ngx_reopen = 1;\n            action = \", reopening logs\";\n            break;\n\n        case ngx_signal_value(NGX_RECONFIGURE_SIGNAL):\n        case ngx_signal_value(NGX_CHANGEBIN_SIGNAL):\n        case SIGIO:\n            action = \", ignoring\";\n            break;\n        }\n\n        break;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0,\n                  \"signal %d (%s) received%s\", signo, sig->signame, action);\n\n    if (ignore) {\n        ngx_log_error(NGX_LOG_CRIT, ngx_cycle->log, 0,\n                      \"the changing binary signal is ignored: \"\n                      \"you should shutdown or terminate \"\n                      \"before either old or new binary's process\");\n    }\n\n    if (signo == SIGCHLD) {\n        ngx_process_get_status();\n    }\n\n    ngx_set_errno(err);\n}\n\n```\n\n\n可以看到，根据不同的信号设置了不同的标志位，然后再在ngx_master_process_cycle以及ngx_single_process_cycle中进行处理，这里暂时就不再继续分析。\n\n继续更新：\n\n而设置了这些标识位有什么意义呢？这里需要看Master以及Worker进程的循环函数来找到答案。\n我们先来看Master进程的循环：\n\n```C\nvoid\nngx_master_process_cycle(ngx_cycle_t *cycle)\n{\n    char              *title;\n    u_char            *p;\n    size_t             size;\n    ngx_int_t          i;\n    ngx_uint_t         n, sigio;\n    sigset_t           set;\n    struct itimerval   itv;\n    ngx_uint_t         live;\n    ngx_msec_t         delay;\n    ngx_listening_t   *ls;\n    ngx_core_conf_t   *ccf;\n\n    // 将用到的信号加入到set信号集中\n    sigemptyset(&set);\n    sigaddset(&set, SIGCHLD);\n    sigaddset(&set, SIGALRM);\n    sigaddset(&set, SIGIO);\n    sigaddset(&set, SIGINT);\n    sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));\n    sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));\n    sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));\n    sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));\n    sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n    sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));\n\n    // 将信号集中的信号全部block 从而使所有信号 收到以后全部变为阻塞状态\n    if (sigprocmask(SIG_BLOCK, &set, NULL) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      \"sigprocmask() failed\");\n    }\n\n    sigemptyset(&set);\n\n\n    size = sizeof(master_process);\n\n    for (i = 0; i < ngx_argc; i++) {\n        size += ngx_strlen(ngx_argv[i]) + 1;\n    }\n\n    title = ngx_pnalloc(cycle->pool, size);\n\n    p = ngx_cpymem(title, master_process, sizeof(master_process) - 1);\n    for (i = 0; i < ngx_argc; i++) {\n        *p++ = ' ';\n        p = ngx_cpystrn(p, (u_char *) ngx_argv[i], size);\n    }\n\n    // set process title (including args) eg.: \n    /**\n     * root     13603  0.0  0.0 109592  2260 ?        Ss   01:05   0:00 nginx: master process nginx -c /etc/nginx/nginx.conf\n     * root     13604  0.0  0.0 110112  2816 ?        S    01:05   0:00 nginx: worker process\n     * root     13605  0.0  0.0 110112  2816 ?        S    01:05   0:00 nginx: worker process\n     * */\n    ngx_setproctitle(title);\n\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    ngx_start_worker_processes(cycle, ccf->worker_processes,\n                               NGX_PROCESS_RESPAWN);\n    ngx_start_cache_manager_processes(cycle, 0);\n\n    ngx_new_binary = 0;\n    delay = 0;\n    sigio = 0;\n    live = 1;\n\n    for ( ;; ) {\n        if (delay) {\n            if (ngx_sigalrm) {\n                sigio = 0;\n                delay *= 2;\n                ngx_sigalrm = 0;\n            }\n\n            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                           \"termination cycle: %d\", delay);\n\n            itv.it_interval.tv_sec = 0;\n            itv.it_interval.tv_usec = 0;\n            itv.it_value.tv_sec = delay / 1000;\n            itv.it_value.tv_usec = (delay % 1000 ) * 1000;\n\n            if (setitimer(ITIMER_REAL, &itv, NULL) == -1) {\n                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                              \"setitimer() failed\");\n            }\n        }\n\n        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"sigsuspend\");\n\n        sigsuspend(&set);\n\n        ngx_time_update();\n\n        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"wake up, sigio %i\", sigio);\n\n        // 如果ngx_reap为1 即收到子进程发来的SIGCHLD信号  就将未正常退出的进程重新拉起\n        if (ngx_reap) {\n            ngx_reap = 0;\n            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"reap children\");\n\n            live = ngx_reap_children(cycle);\n        }\n\n        // 如果无子进程活着 并且 需要退出 就将父进程退出\n        if (!live && (ngx_terminate || ngx_quit)) {\n            ngx_master_process_exit(cycle);\n        }\n\n        if (ngx_terminate) {\n            if (delay == 0) {\n                delay = 50;\n            }\n\n            if (sigio) {\n                sigio--;\n                continue;\n            }\n\n            sigio = ccf->worker_processes + 2 /* cache processes */;\n\n            if (delay > 1000) {\n                ngx_signal_worker_processes(cycle, SIGKILL);\n            } else {\n                ngx_signal_worker_processes(cycle,\n                                       ngx_signal_value(NGX_TERMINATE_SIGNAL));\n            }\n\n            continue;\n        }\n\n        if (ngx_quit) {\n            // 向每个子进程发送信号 SIGQUIT\n            ngx_signal_worker_processes(cycle,\n                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n\n            ls = cycle->listening.elts;\n            for (n = 0; n < cycle->listening.nelts; n++) {\n                if (ngx_close_socket(ls[n].fd) == -1) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                                  ngx_close_socket_n \" %V failed\",\n                                  &ls[n].addr_text);\n                }\n            }\n            cycle->listening.nelts = 0;\n\n            continue;\n        }\n\n        // 加载新配置文件的时候\n        if (ngx_reconfigure) {\n            ngx_reconfigure = 0;\n\n            //  如果更换了二进制文件，需要全部重启worker进程 此时进程的类型为 NGX_PROCESS_RESPAWN 意为重新生成进程\n            if (ngx_new_binary) {\n                ngx_start_worker_processes(cycle, ccf->worker_processes,\n                                           NGX_PROCESS_RESPAWN);\n                ngx_start_cache_manager_processes(cycle, 0);\n                ngx_noaccepting = 0;\n\n                continue;\n            }\n\n            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reconfiguring\");\n\n            // 重新init cycle 读取变更的配置\n            cycle = ngx_init_cycle(cycle);\n            if (cycle == NULL) {\n                cycle = (ngx_cycle_t *) ngx_cycle;\n                continue;\n            }\n\n            ngx_cycle = cycle;\n            ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,\n                                                   ngx_core_module);\n            // 并将所有进程类型设置为 NGX_PROCESS_JUST_RESPAWN 意为 刚刚重新生成，与NGX_PROCESS_RESPAWN(旧的worker进程区分开) \n            ngx_start_worker_processes(cycle, ccf->worker_processes,\n                                       NGX_PROCESS_JUST_RESPAWN);\n            ngx_start_cache_manager_processes(cycle, 1);\n            live = 1;\n            // 给旧的worker进程发信号 干掉他们\n            ngx_signal_worker_processes(cycle,\n                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n        }\n\n        if (ngx_restart) {\n            ngx_restart = 0;\n            ngx_start_worker_processes(cycle, ccf->worker_processes,\n                                       NGX_PROCESS_RESPAWN);\n            ngx_start_cache_manager_processes(cycle, 0);\n            live = 1;\n        }\n\n        if (ngx_reopen) {\n            ngx_reopen = 0;\n            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reopening logs\");\n            ngx_reopen_files(cycle, ccf->user);\n            ngx_signal_worker_processes(cycle,\n                                        ngx_signal_value(NGX_REOPEN_SIGNAL));\n        }\n\n        if (ngx_change_binary) {\n            ngx_change_binary = 0;\n            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"changing binary\");\n            ngx_new_binary = ngx_exec_new_binary(cycle, ngx_argv);\n        }\n\n        if (ngx_noaccept) {\n            ngx_noaccept = 0;\n            ngx_noaccepting = 1;\n            ngx_signal_worker_processes(cycle,\n                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n        }\n    }\n}\n```\n\n我们来分别看一下这些全局的标志位会如何影响nginx的行为,先来看下ngx_signal_handler中所有出现的标志位。\n\n\n### Master进程:\n\n\n| 标志位            | 信号     |\n| ----------------- | -------- |\n| ngx_reap          | SIGCHLD  |\n| ngx_sigio         | SIGIO    |\n| ngx_sigalrm       | SIGALRM  |\n| ngx_terminate     | SIGINT   |\n| ngx_quit          | SIGQUIT  |\n| ngx_noaccept      | SIGWINCH |\n| ngx_reconfigure   | SIGHUP   |\n| ngx_reopen        | SIGUSR1  |\n| ngx_change_binary | SIGUSR2  |\n\n### Worker进程\n\n| 标志位         | 信号              |\n| -------------- | ----------------- |\n| ngx_daemonized | SIGWINCH          |\n| ngx_quit       | SIGQUIT           |\n| ngx_terminate  | SIGINT \\| SIGTERM |\n| ngx_reopen     | SIGUSR1           |\n\n\n\n#### ngx_reap标志位\n\n先来看Master进程，首先是ngx_reap标志位，会被SIGCHLD信号影响到，这个信号其实是在worker进程死掉的时候会由系统发送到Master进程，告知其子进程死掉，收到这个进程以后nginx需要回收子进程的资源，然后重新拉起一个新的子进程我们来看一下整个流程。\n\n收到这个信号以后，父进程会在信号的handler中判断如果是SIGCHLD信号的话，需要通过ngx_process_get_status(void)方法获取子进程的状态，我们来看下这个方法。\n\n```C\nstatic void\nngx_process_get_status(void)\n{\n    int              status;\n    char            *process;\n    ngx_pid_t        pid;\n    ngx_err_t        err;\n    ngx_int_t        i;\n    ngx_uint_t       one;\n\n    one = 0;\n\n    for ( ;; ) {\n        // 通过waitpid获取到状态改变的子进程\n        pid = waitpid(-1, &status, WNOHANG);\n\n        if (pid == 0) {\n            return;\n        }\n\n        if (pid == -1) {\n            err = ngx_errno;\n\n            if (err == NGX_EINTR) {\n                continue;\n            }\n\n\n            // ECHILD代表 waitpid的第一个参数 指定的pid不存在 / 不属于当前进程的子进程\n            if (err == NGX_ECHILD && one) {\n                return;\n            }\n\n#if (NGX_SOLARIS || NGX_FREEBSD)\n\n            /*\n             * Solaris always calls the signal handler for each exited process\n             * despite waitpid() may be already called for this process.\n             *\n             * When several processes exit at the same time FreeBSD may\n             * erroneously call the signal handler for exited process\n             * despite waitpid() may be already called for this process.\n             */\n\n            if (err == NGX_ECHILD) {\n                ngx_log_error(NGX_LOG_INFO, ngx_cycle->log, err,\n                              \"waitpid() failed\");\n                return;\n            }\n\n#endif\n\n            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,\n                          \"waitpid() failed\");\n            return;\n        }\n\n\n        if (ngx_accept_mutex_ptr) {\n\n            /*\n             * unlock the accept mutex if the abnormally exited process\n             * held it\n             */\n\n            ngx_atomic_cmp_set(ngx_accept_mutex_ptr, pid, 0);\n        }\n\n\n        // 代表有进程非正常退出\n        one = 1;\n        process = \"unknown process\";\n\n        // 遍历所有的子进程，找到这个挂掉的进程，将状态设置为exited\n        for (i = 0; i < ngx_last_process; i++) {\n            if (ngx_processes[i].pid == pid) {\n                ngx_processes[i].status = status;\n                ngx_processes[i].exited = 1;\n                process = ngx_processes[i].name;\n                break;\n            }\n        }\n\n        if (WTERMSIG(status)) {\n#ifdef WCOREDUMP\n            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                          \"%s %P exited on signal %d%s\",\n                          process, pid, WTERMSIG(status),\n                          WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n#else\n            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                          \"%s %P exited on signal %d\",\n                          process, pid, WTERMSIG(status));\n#endif\n\n        } else {\n            ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0,\n                          \"%s %P exited with code %d\",\n                          process, pid, WEXITSTATUS(status));\n        }\n\n        if (WEXITSTATUS(status) == 2 && ngx_processes[i].respawn) {\n            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                          \"%s %P exited with fatal code %d \"\n                          \"and cannot be respawned\",\n                          process, pid, WEXITSTATUS(status));\n            ngx_processes[i].respawn = 0;\n        }\n    }\n}\n\n```\n\n当然，收到SIGCHLD以后，会影响nginx的全局标志位ngx_reap，代表需要回收挂掉的子进程资源，并且重新拉起一个子进程，我们来看下父进程中具体的循环代码。\n\n```C\nif (ngx_reap) {\n    ngx_reap = 0;\n    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"reap children\");\n\n    live = ngx_reap_children(cycle);\n}\n```\n在ngx_reap_children中，我们需要\n\n1. 回收挂掉的子进程的资源\n2. 试着拉起挂掉的子进程，并且告知其余的子进程，这个进程已经恢复,打开进程间通信的channel\n3. 如果未成功拉起，需要根据这个挂掉的进程类型来判断应该如何处理。\n\n```C\nstatic ngx_uint_t\nngx_reap_children(ngx_cycle_t *cycle)\n{\n    ngx_int_t         i, n;\n    ngx_uint_t        live;\n    ngx_channel_t     ch;\n    ngx_core_conf_t  *ccf;\n\n    // 进程间通信，告知其余子进程，那个exited为1的进程已经挂掉\n    ch.command = NGX_CMD_CLOSE_CHANNEL;\n    ch.fd = -1;\n\n    // 标志当前是否有子进程存活\n    live = 0;\n    for (i = 0; i < ngx_last_process; i++) {\n\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"child: %d %P e:%d t:%d d:%d r:%d j:%d\",\n                       i,\n                       ngx_processes[i].pid,\n                       ngx_processes[i].exiting,\n                       ngx_processes[i].exited,\n                       ngx_processes[i].detached,\n                       ngx_processes[i].respawn,\n                       ngx_processes[i].just_spawn);\n\n        // pid为-1 跳过\n        if (ngx_processes[i].pid == -1) {\n            continue;\n        }\n\n        // 上面把异常退出的进程的exited设置为了1\n        if (ngx_processes[i].exited) {\n\n            // 不能是在分离的进程 分离的进程是会单独作为一个进程运行\n            if (!ngx_processes[i].detached) {\n\n                // 关闭死掉进程的channel\n                ngx_close_channel(ngx_processes[i].channel, cycle->log);\n\n                ngx_processes[i].channel[0] = -1;\n                ngx_processes[i].channel[1] = -1;\n\n                // 针对这个死掉的进程\n                ch.pid = ngx_processes[i].pid;\n                ch.slot = i;\n\n                // 告知每个进程，这个进程死掉了\n                for (n = 0; n < ngx_last_process; n++) {\n                    if (ngx_processes[n].exited\n                        || ngx_processes[n].pid == -1\n                        || ngx_processes[n].channel[0] == -1)\n                    {\n                        continue;\n                    }\n\n                    ngx_log_debug3(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n                                   \"pass close channel s:%i pid:%P to:%P\",\n                                   ch.slot, ch.pid, ngx_processes[n].pid);\n\n                    /* TODO: NGX_AGAIN */\n\n                    // 每个子进程关掉和这个死掉进程通信的channel\n                    ngx_write_channel(ngx_processes[n].channel[0],\n                                      &ch, sizeof(ngx_channel_t), cycle->log);\n                }\n            }\n\n            // 进程是由父进程生成的 并且未在退出状态\n            if (ngx_processes[i].respawn\n                && !ngx_processes[i].exiting\n                && !ngx_terminate\n                && !ngx_quit)\n            {\n                // 将进程重新拉起 使用的是原进程的index \n                if (ngx_spawn_process(cycle, ngx_processes[i].proc,\n                                      ngx_processes[i].data,\n                                      ngx_processes[i].name, i)\n                    == NGX_INVALID_PID)\n                {\n                    ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n                                  \"could not respawn %s\",\n                                  ngx_processes[i].name);\n                    continue;\n                }\n\n                // 告知每个进程 针对这个进程 打开通信的channel\n                ch.command = NGX_CMD_OPEN_CHANNEL;\n                ch.pid = ngx_processes[ngx_process_slot].pid;\n                ch.slot = ngx_process_slot;\n                ch.fd = ngx_processes[ngx_process_slot].channel[0];\n\n                ngx_pass_open_channel(cycle, &ch);\n\n                live = 1;\n\n                continue;\n            }\n\n            // 如果是新的进程\n            if (ngx_processes[i].pid == ngx_new_binary) {\n\n                ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,\n                                                       ngx_core_module);\n\n                // 将pid文件恢复成旧的pid文件\n                if (ngx_rename_file((char *) ccf->oldpid.data,\n                                    (char *) ccf->pid.data)\n                    != NGX_OK)\n                {\n                    ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                                  ngx_rename_file_n \" %s back to %s failed \"\n                                  \"after the new binary process \\\"%s\\\" exited\",\n                                  ccf->oldpid.data, ccf->pid.data, ngx_argv[0]);\n                }\n\n                ngx_new_binary = 0;\n                if (ngx_noaccepting) {\n                    ngx_restart = 1;\n                    ngx_noaccepting = 0;\n                }\n            }\n\n            // 如果这个进程位于进程数组的最后一个 就将ngx_last_process-1\n            if (i == ngx_last_process - 1) {\n                ngx_last_process--;\n\n            } else {\n                ngx_processes[i].pid = -1;\n            }\n\n            // 如果有进程未完全退出/无进程分离中 live为1 \n        } else if (ngx_processes[i].exiting || !ngx_processes[i].detached) {\n            live = 1;\n        }\n    }\n\n    return live;\n}\n```\n\n这就是全部的ngx_reap标志被设置为1以后会发生的事，ngx_reap_children的返回值会影响下面代码的行为，我们来来看一下\n\n```C\n// 如果无子进程活着 并且 需要退出 就将父进程退出\nif (!live && (ngx_terminate || ngx_quit)) {\n    // 主要是关闭文件 删除pid文件 等等\n    ngx_master_process_exit(cycle);\n```\n\n### ngx_terminate & ngx_sigalrm标志位\n\n然后来看下ngx_terminate标志 以及 ngx_sigalrm标志位。\n\n```C\nif (ngx_terminate) {\n    if (delay == 0) {\n        delay = 50;\n    }\n\n    if (sigio) {\n        sigio--;\n        continue;\n    }\n\n    sigio = ccf->worker_processes + 2 /* cache processes */;\n\n    if (delay > 1000) {\n        ngx_signal_worker_processes(cycle, SIGKILL);\n    } else {\n        ngx_signal_worker_processes(cycle,\n                               ngx_signal_value(NGX_TERMINATE_SIGNAL));\n    }\n\n    continue;\n}\n```\n\n- ngx_master_process_cycle循环一开始对delay的设置\n```C\nif (delay) {\n    if (ngx_sigalrm) {\n        sigio = 0;\n        delay *= 2;\n        ngx_sigalrm = 0;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                   \"termination cycle: %d\", delay);\n\n    itv.it_interval.tv_sec = 0;\n    itv.it_interval.tv_usec = 0;\n    itv.it_value.tv_sec = delay / 1000;\n    itv.it_value.tv_usec = (delay % 1000 ) * 1000;\n\n    if (setitimer(ITIMER_REAL, &itv, NULL) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      \"setitimer() failed\");\n    }\n}\n```\n\n这里的ngx_terminate是直接暴力退出，没有关闭进程间通信的端口，子进程收到这个信号后会直接调用ngx_worker_process_exit退出, 后面会分析这个方法。\n\n这里有一个delay的设置，其实这个在ngx_master_process_cycle中一开始就对这个dalay进行了设置，在我看来，这个delay其实是为了防止进行terminate操作的时候，子进程卡死（这里不确定），所以会在一定时间内持续用的向子进程发送NGX_TERMINATE_SIGNAL信号，而超过这个限制的时间后，会直接发送SIGKILL信号，相当于直接让子进程暴力退出。而未到限制的时间这段时间里，就会是上面这段代码中的操作，如果收到定时器发出的信号，会把delay * 2, 就像tcp的quick start快启动的模式，然后用新的delay值设置一个定时器，到时间以后会向本进程再发送一个SIGALRM信号，收到这个信号会使ngx_sigalrm标志位置1，然后循环往复下去。   \n当然这里的发送信号是对所有的子进程做了一个遍历操作，具体的操作我们会在另一片文章中进行分析。\n\n### ngx_quit\n\nngx_quit标志是被SIGQUIT信号影响的，我们来看下收到这个信号后，会对进程的行为产生什么影响。\n\n```C\nif (ngx_quit) {\n     // 向每个子进程发送信号 SIGQUIT\n     ngx_signal_worker_processes(cycle,\n                                 ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n\n     ls = cycle->listening.elts;\n     for (n = 0; n < cycle->listening.nelts; n++) {\n         if (ngx_close_socket(ls[n].fd) == -1) {\n             ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                           ngx_close_socket_n \" %V failed\",\n                           &ls[n].addr_text);\n         }\n     }\n     cycle->listening.nelts = 0;\n\n     continue;\n}\n```\n\nmaster进程会向每个子进程都发送SIGQUIT信号，来通知所有子进程要退出，然后关闭所有在监听的端口，执行完这步以后，会continue循环，然后判断如果所有的子进程都已经退出了，那么就直接调用ngx_master_process_exit()退出master进程。\n\n### ngx_reconfigure\n\n现在来看下ngx_reconfigure标志，这里改变了ngx_process_t的标志位来区分出重新加载配置的新旧进程，来看下具体实现。\n\n```C\nif (ngx_reconfigure) {\n    ngx_reconfigure = 0;\n\n    //  如果更换了二进制文件，需要全部重启worker进程 此时进程的类型为 NGX_PROCESS_RESPAWN 意为重新生成进程\n    if (ngx_new_binary) {\n        ngx_start_worker_processes(cycle, ccf->worker_processes,\n                                   NGX_PROCESS_RESPAWN);\n        ngx_start_cache_manager_processes(cycle, 0);\n        ngx_noaccepting = 0;\n\n        continue;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reconfiguring\");\n\n    // 重新init cycle 读取变更的配置\n    cycle = ngx_init_cycle(cycle);\n    if (cycle == NULL) {\n        cycle = (ngx_cycle_t *) ngx_cycle;\n        continue;\n    }\n\n    ngx_cycle = cycle;\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,\n                                           ngx_core_module);\n    // 并将所有进程类型设置为 NGX_PROCESS_JUST_RESPAWN 意为 刚刚重新生成，与NGX_PROCESS_RESPAWN(旧的worker进程区分开) \n    ngx_start_worker_processes(cycle, ccf->worker_processes,\n                               NGX_PROCESS_JUST_RESPAWN);\n    ngx_start_cache_manager_processes(cycle, 1);\n    live = 1;\n    // 给旧的worker进程发信号 干掉他们\n    ngx_signal_worker_processes(cycle,\n                                ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n}\n\nif (ngx_change_binary) {\n    ngx_change_binary = 0;\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"changing binary\");\n    ngx_new_binary = ngx_exec_new_binary(cycle, ngx_argv);\n}\n```\n\n可以看到，首先会进行ngx_new_binary的判断，这个实际是被标志位ngx_change_binary影响的，是实际去执行一个新的二进制文件的返回值, 实际是spawn了一个NGX_PROCESS_DETACHED类型的进程，然后进行进程的分离，独立运行。这里为了防止二进制文件的更新会影响进程的行为，所以要先把进程都更新为最新的，防止出现，代码有BUG，需要去重新加载配置的时候，因为bug原因，导致加载会出错，需要更新二进制文件，然后去重新respawn所有的进程。\n\n然后我们现在来看一下nginx执行新的二进制文件的流程。\n\n```C\nngx_pid_t\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\n{\n    char             **env, *var;\n    u_char            *p;\n    ngx_uint_t         i, n;\n    ngx_pid_t          pid;\n    ngx_exec_ctx_t     ctx;\n    ngx_core_conf_t   *ccf;\n    ngx_listening_t   *ls;\n\n    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));\n\n    ctx.path = argv[0];\n    ctx.name = \"new binary process\";\n    ctx.argv = argv;\n\n    // 设置了TZ环境变量\n    n = 2;\n    env = ngx_set_environment(cycle, &n);\n    if (env == NULL) {\n        return NGX_INVALID_PID;\n    }\n\n    // 为传递给子进程的listen fds分配空间 格式是 fd1;fd2;fd3;...\n    var = ngx_alloc(sizeof(NGINX_VAR)\n                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,\n                    cycle->log);\n\n    p = ngx_cpymem(var, NGINX_VAR \"=\", sizeof(NGINX_VAR));\n\n    // 把所有的监听端口对应的fd全部拷贝到var中\n    ls = cycle->listening.elts;\n    for (i = 0; i < cycle->listening.nelts; i++) {\n        p = ngx_sprintf(p, \"%ud;\", ls[i].fd);\n    }\n\n    *p = '\\0';\n\n    // var存入到env中\n    env[n++] = var;\n\n#if (NGX_SETPROCTITLE_USES_ENV)\n\n    /* allocate the spare 300 bytes for the new binary process title */\n\n    // 分配300字节给新进程的title\n    env[n++] = \"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n\n#endif\n\n    env[n] = NULL;\n\n#if (NGX_DEBUG)\n    {\n    char  **e;\n    for (e = env; *e; e++) {\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"env: %s\", *e);\n    }\n    }\n#endif\n\n    ctx.envp = (char *const *) env;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    // rename pid文件\n    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      ngx_rename_file_n \" %s to %s failed \"\n                      \"before executing new binary process \\\"%s\\\"\",\n                      ccf->pid.data, ccf->oldpid.data, argv[0]);\n\n        ngx_free(env);\n        ngx_free(var);\n\n        return NGX_INVALID_PID;\n    }\n\n    // 执行新进程\n    pid = ngx_execute(cycle, &ctx);\n\n    if (pid == NGX_INVALID_PID) {\n        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data) != NGX_OK) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_rename_file_n \" %s back to %s failed after \"\n                          \"the try to execute the new binary process \\\"%s\\\"\",\n                          ccf->oldpid.data, ccf->pid.data, argv[0]);\n        }\n    }\n\n    ngx_free(env);\n    ngx_free(var);\n\n    return pid;\n}\n```\n\n```C\nngx_pid_t\nngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)\n{\n    // 通过ngx_spawn_process拉起新的进程 并且将进程分离 进程fork后 子进程执行ngx_execute_proc方法 传递ctx进去\n    return ngx_spawn_process(cycle, ngx_execute_proc, ctx, ctx->name,\n                             NGX_PROCESS_DETACHED);\n}\n\n\nstatic void\nngx_execute_proc(ngx_cycle_t *cycle, void *data)\n{\n    ngx_exec_ctx_t  *ctx = data;\n\n    // 为新进程设置环境参数\n    if (execve(ctx->path, ctx->argv, ctx->envp) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      \"execve() failed while executing %s \\\"%s\\\"\",\n                      ctx->name, ctx->path);\n    }\n\n    exit(1);\n}\n```","tags":["C"],"categories":["Nginx"]},{"url":"/2020/05/04/Leetcode 1433/","content":"# Leetcode 1433\n\n\n\n## 题目\n\n给你两个字符串 s1 和 s2 ，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，或者是否存在一个 s2 的排列可以打破 s1 的一个排列。\n\n字符串 x 可以打破字符串 y （两者长度都为 n ）需满足对于所有 i（在 0 到 n - 1 之间）都有 x[i] >= y[i]（字典序意义下的顺序）。\n\n \n\n示例 1：\n\n输入：s1 = \"abc\", s2 = \"xya\"\n输出：true\n解释：\"ayx\" 是 s2=\"xya\" 的一个排列，\"abc\" 是字符串 s1=\"abc\" 的一个排列，且 \"ayx\" 可以打破 \"abc\" 。\n示例 2：\n\n输入：s1 = \"abe\", s2 = \"acd\"\n输出：false \n解释：s1=\"abe\" 的所有排列包括：\"abe\"，\"aeb\"，\"bae\"，\"bea\"，\"eab\" 和 \"eba\" ，s2=\"acd\" 的所有排列包括：\"acd\"，\"adc\"，\"cad\"，\"cda\"，\"dac\" 和 \"dca\"。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。\n示例 3：\n\n输入：s1 = \"leetcodee\", s2 = \"interview\"\n输出：true\n\n\n提示：\n\ns1.length == n\ns2.length == n\n1 <= n <= 10^5\n所有字符串都只包含小写英文字母。\n\n\n\n## 题解\n\n# 首先看字符串打破的定义，s1能把s2打破，说明s1\n\n"},{"title":"python调用C提升性能记录","url":"/2020/04/03/python调用C提升性能记录/","content":"\n## Python通过调用C来提升性能的一次记录\n\n​\t\t昨天遇到的一个事，同事通过Python来处理其他家厂商的日志，将格式转换成内部日志格式，不是复杂的需求，但是遇到了性能瓶颈，单核大概8000qps，500w行的日志处理大概需要3min。申请了的是16核机器，考虑到多线程情况下的调度，单机10w的qps应该是有点勉强能达到的，而且实际测试的时候，虽然能达到，但是16核cpu基本都跑🈵️了。虽然机器只有这一个服务在跑，但是实际占用大量时间的还有磁盘IO等会阻塞的操作，因此想着要给优化一下，思路是通过火焰图分析代码耗费时间的部分，然后通过C来重写该部分的逻辑，并通过Python的ctypes包来调用C的接口。\n\n\n\n### PyFlame安装及生成火焰图&分析\n\n​\t\t首先是通过火焰图来进行性能的分析，因为之前用过标准库的CProfile来查看某个py脚本的性能，命令是`python -m cProfile -s tottime test_parse.py`，可惜代码实际是多进程来做的，cProfile会报错，具体原因没有深究。经过google选了[PyFlame](\"https://github.com/uber-archive/pyflame\")来生成火焰图，具体依赖的库包括autoconf, automake 等等，不再列举，CentOS下的编译安装可参照[这里](\"https://blog.csdn.net/qq_30549833/article/details/72955881\")。[官方文档](\"https://pyflame.readthedocs.io/en/latest/\")对于安装过程写的挺详细的，不再赘述。安装完PyFlame还需要安装一个[FlameGraph](\"https://github.com/brendangregg/FlameGraph\")，通过其中的flamegraph.pl来生成火焰图。\n\n​\t\t用法是，PyFlame会通过attach到具体的进程然后拿到进程调用链和耗费的时间，同时还支持设置采样的总时间以及每次采样的间隔时间，然后采样完成后把数据pipe到flamegraph.pl生成火焰图，可以在chrome中直接打开。\n\n> pyflame -s 10 -p 26788 | ../../FlameGraph/flamegraph.pl > A.svg\n\n（并未设置采样间隔 可通过-r进行设置\n\n\n\n### 通过火焰图进行分析 & 优化\n\n生成的图是这样的：\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/master/1.png)\n\n（一开始不会看火焰图有点尴尬 害 补充一点小知识\n\n> 经过Google，火焰图的颜色与耗费时常啥🐔8⃣️关系都🈚️。需要注意的是横向代码的长度<strong>代表代码执行耗费的时间</strong>，纵向往上的层级越多，越说明<strong>调用链越长</strong>，也就越有可能<strong>占用CPU时间</strong>。\n\n​\t\t我们可以在图中看到，实际最花时间的应该是四个蓝色箭头所指的位置，可优化的也在这里。看了下代码，其中<strong>1号左侧</strong>的代码对应的是在IO磁盘操作，即在硬盘中读取日志出来，这个消耗实际上是不能避免的。1号操作对应的是将某一条日志通过正则提取出某些必要的信息，也就是说<strong>正则匹配</strong>消耗了一定时间，想来想去没有什么好的优化手段，因为日志格式是固定的，所以还是用<strong>split(\" \")</strong>来把正则替换掉（其实是有一些作用的哈哈哈哈哈哈哈哈哈）。\n\n​\t\t再来看2-4号操作，这几个其实都是一样的操作，把原日志中的UTC时间（格林尼治标准时间）转换成CST（东八区北京时间），经过线下与同事商量，去掉了后两个，因为他也没用到（手动狗头。经过这一番操作，火焰图变成了酱：\n\n![image-20200403181338126](https://raw.githubusercontent.com/SilverHL/image_repo/master/2.png)\n\n​\t\t也就是说，<strong>原来的1号</strong>（正则匹配）消耗的时间比较少，上图的1号，涉及到比较深层次的调用，应该是属于磁盘IO，也就是无法避免的消耗。而2号就是时间转换，需要将原日志的字符串转成datetime对象，然后进行时区的转换，在转回字符串。因为实际linux获取时间实际是需要系统调用的，因此还是很消耗时间的，所以这块用C来重写，以期提高性能。\n\n### Python调用C\n\n​\t\t经过一番Google，发现ctypes实际是比较好用的，写C就可以，然后编译成动态链接库，再在python中调用。不像Cython，需要写Python（8是很会写py），实际比python多的就是指定类型，在编译期就完成类型的推导，不像原生的python需要在运行期动态的推导类型，耗费时间过多，（后话，可能会研究下这方面）。\n\n​\t\t首先是用C完成时间转换的步骤，介绍几个API:\n\n  将当前的时区设置为东八区北京时区：\n\n> setenv(\"TZ\", \"GMT-8\", 1) \n\n将char *类型的时间字符串按照format格式转换到struct tm类型\n\n> char *strptime(const char *s, const char *format, struct tm *tm);\n\n将struct tm *类型的timeptr按照format格式转换到char *, maxsize指的需要填充的buffer的最大长度\n\n> size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)\n\n将struct tm *类型转换成unix时间戳\n\n> time_t timegm(struct tm *tm);\n\n将struct tm *类型转换成本地时区的unix时间戳（似乎不需要上面的setenv\n\n> time_t mktime(struct tm *timeptr)\n\n将time_t类型的unix时间戳转换成struct tm*\n\n> struct tm *localtime(const time_t *timer)\n\n\n\n上代码：\n\n```c\n#include <stdio.h>\n#include <sys/times.h>\n#include <time.h>\n#include <string.h>\n\nconst char *\nutc_to_cst(const char *utc_time)\n{\n   setenv(\"TZ\", \"GMT-8\", 1);        // set current timezone beijing\n   struct tm tmstr;\n   struct tm * tmlocal;\n   time_t tslastutc;\n   time_t tslastloc;\n   char cst_time[32];\n   memset(&tmstr, 0, sizeof(struct tm));\n   strptime(utc_time, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert argument to struct tm\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert struct tm to string, still\n\n   tslastutc = timegm(&tmstr);     // get UCT Unix time from argument string time  GMT\n   tslastloc = mktime(&tmstr);     // get local Unix time from argument string time\n   tslastloc += (tslastutc - tslastloc);    // wired operation, seems to reduce deviation\n   tmlocal = localtime (&tslastloc); \t// get local time in struct tm format\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", tmlocal); // convert local struct tm to string\n   return cst_time;\n}\n```\n\n​\t\t通过这个命令将代码编译成动态链接库，并通过python代码进行调用：\n\n> gcc -shared -Wl,-soname,utc_to_cst -o utc_to_cst.so -fPIC utc_to_cst.c\n\n​\t\tpython调用代码如下（其实也是通过指明符号名、变量和返回值类型）：\n\n```python\nfrom ctypes import *\n\ntime_convert = CDLL(\"./utc_to_cst.so\")\t# add dll\nin_arg = c_char_p(\"2018-02-19 00:00:00\") # specify in arg type (char *)\nu_to_c = time_convert.utc_to_cst\t# connect u_to_c with symbol utc_to_cst in .so file\nu_to_c.restype = c_char_p # specify return type in c (char *)\nprint(u_to_c(in_arg))\n\n\n```\n\n实际上到这里就٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎ了，但是应用到的时候出现了一个诡异的现象，他🐎的用完C的模块居然还更慢了！生成的火焰图如下：\n\n![image-20200403181450308](https://raw.githubusercontent.com/SilverHL/image_repo/master/3.png)\n\n​\t\t可以看到2号占用的时间比上一张图长了 = = 实际测试500w行处理完成的时间也有4min，耗费时间实际上花在了ctypes的\\_\\_init\\_\\_()方法上，然后就没有更深的调用链了。我就去实际的看了下ctypes的\\_\\_init\\_\\_到底做了个啥事，代码中有几行是这样的：\n\n```\nif handle is None:\n    self._handle = _dlopen(self._name, mode)\nelse:\n    self._handle = handle\n```\n\n​\t\thandle应该指的就是.so文件中的符号，即utc_to_cst, 代表我们调用的C代码中的处理方法，然后想到用的时候，把`time_convert = CDLL(\"./utc_to_cst.so\")`这行加在了循环，才导致有大量的时间花在了_dlopen()中，果断把这行移除循环，终于得到了满意的结果，火焰图如下：\n\n![image-20200403182202297](https://raw.githubusercontent.com/SilverHL/image_repo/master/4.png)\n\n经过实际测试，完成以上的优化过程后，单核qps可以达到5w左右，就算突发也可以很好的应付。"},{"title":"Leetcode-861-ReverseMatrixScore","url":"/2020/03/10/Leetcode-861-ReverseMatrixScore/","content":"\n# Leetcode 861 ReverseMatrixScore \n\n\n\n## 题目\n\n有一个二维矩阵 A 其中每个元素的值为 0 或 1 。\n\n移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。\n\n在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。\n\n返回尽可能高的分数。\n\n \n\n示例：\n\n> 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n> 输出：39\n> 解释：\n> 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]\n> 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n\n提示：\n\n1 <= A.length <= 20\n1 <= A[0].length <= 20\nA[i][j] 是 0 或 1\n\n\n\n## 题解\n\n这道题分类是贪心算法，首先需要明确，一个横向或纵向的数组翻转两次=》未翻转，所以每个横向或纵向的数组最多翻转一次。 因为最后需要求得最大值，所以每个数组的第0位一定要是1，有了第一个遍历。纵向遍历数组第0位，不为1的，将整个数组<strong>横向翻转</strong>。此时所有数组均<strong>不可以</strong>再横向翻转。由于求最大值，我们只需要求数组中1的数量，因此将sum初始化为<strong>row * (int)pow(2, line - 1)</strong>,而后面的纵向数组，我们只需要保证 <strong>每个纵向数组中1的数量大于0的数量</strong>,然后再通过1的数量可以求出此时的和。\n\n\n\n## Code\n\n```cpp\nint matrixScore(vector<vector<int>>& A)\n{\n    for (auto &vec : A) {\n        if (vec[0] == 0) {\n            for (auto &i : vec)\n                i ^= 1;\n        }\n    }\n\n    const int r = A.size();\n    const int l = A[0].size();\n\n    int sum = r * (int)pow(2, l-1);\n\n    for (int j = 1; j < l; j++) {\n        int one_n = 0;\n        int zero_n = 0;\n\n      \t// 这里可以只计算0或者1的数量\n        for (int i = 0; i < r; ++i) {\n            if (A[i][j] == 0) {\n                zero_n++;\n            } else {\n                one_n++;\n            }\n        }\n\n        if (one_n > zero_n) {\n            sum += one_n * (int)pow(2, l - j - 1);\n        } else {\n            sum += zero_n * (int)pow(2, l - j - 1);\n        }\n    }\n    return sum;\n}\n```\n\n","tags":["C++","算法","greedy"]},{"title":"Nginx ngx_module_t结构体","url":"/2020/03/09/Nginx-ngx-module-t结构体/","content":"\n# Nginx ngx_module_t 结构体\n\n断断续续的记录一些nginx学习的内容。\n\n\n\n```c\nstruct ngx_module_s {\n    ngx_uint_t            ctx_index;    // 当前模块在本类模块中的顺序  比如 过滤类模块 等等  \n    ngx_uint_t            index;        // 当前类模块在所有模块中的顺序 如 一个http模块在 http src loc模块中的顺序\n\n    ngx_uint_t            spare0;\n    ngx_uint_t            spare1;\n    ngx_uint_t            spare2;\n    ngx_uint_t            spare3;\n\n    ngx_uint_t            version;\n\n    void                 *ctx; // 指向当前这类模块的公共接口\n    ngx_command_t        *commands; // 指向这个模块对应的所有命令\n    ngx_uint_t            type; // 模块类型\n\n    /**\n     * 这7个方法在nginx的执行过程中扮演重要角色\n     */\n    ngx_int_t           (*init_master)(ngx_log_t *log);\n\n    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);\n\n    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);\n    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);\n    void                (*exit_thread)(ngx_cycle_t *cycle);\n    void                (*exit_process)(ngx_cycle_t *cycle);\n\n    void                (*exit_master)(ngx_cycle_t *cycle);\n\n    uintptr_t             spare_hook0;\n    uintptr_t             spare_hook1;\n    uintptr_t             spare_hook2;\n    uintptr_t             spare_hook3;\n    uintptr_t             spare_hook4;\n    uintptr_t             spare_hook5;\n    uintptr_t             spare_hook6;\n    uintptr_t             spare_hook7;\n};\n\n```\n\n\n\n\n\n","tags":["nginx"]},{"title":"Leetcode-729-MyCalendarI","url":"/2019/11/22/Leetcode-729-MyCalendarI/","content":"\n\n\nLeetcode 729  MyCalendar I\n\n## 题目\n\nImplement a `MyCalendar` class to store your events. A new event can be added if adding the event will not cause a double booking.\n\nYour class will have the method, `book(int start, int end)`. Formally, this represents a booking on the half open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.\n\nA *double booking* happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\n\nFor each call to the method `MyCalendar.book`, return `true` if the event can be added to the calendar successfully without causing a double booking. Otherwise, return `false` and do not add the event to the calendar.\n\nYour class will be called like this: `MyCalendar cal = new MyCalendar();``MyCalendar.book(start, end)`\n\n**Example 1:**\n\n```\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\nExplanation: \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n```\n\n\n\n## 题意\n\n这道题题意比较简单，给定一个MyCalendar类，有一个book方法，每次传一个start和一个end, 表示从`[start,end)`的日期能否预定（左闭右开区间），可预定的话就定上并返回`true`，否则返回`false`。这个题其实不难，通过一个vector来记录当前记录的所有预定，每次遍历当前所有的预定，看是否和之前的预定有冲突。两个不同的solution就是在遍历方式上有所不同。\n\n## Code 1\n\n假设当前调用为`book(s1, e1)`, 当前遍历所有的预定到了`[s2, e2)`, 我们一共会有以下几个可能的情况：\n\n![411574399768_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/411574399768_.pic.jpg)\n\n我们可以看到，左边的红线只要小于右边的蓝线，都会是有overlap的情况，那么我们可以归结一下，就是<font color=red>max(s1, s2)</font> < <font color=blue>min(e1, e2)</font>的话，就认为是有overlap的情况，代码如下：\n\n```\nclass MyCalendar {\nprivate:\n    vector<int> mp_;\npublic:\n    MyCalendar1() {\n\n    }\n\n    bool book(int start, int end) {\n        int n = mp_.size();\n        for (int i = 0; i < n; i += 2)\n            if (max(mp_[i], start) < min(mp_[i+1], end))\n                return false;\n        mp_.push_back(start);\n        mp_.push_back(end);\n        return true;\n    }\n};\n```\n\n这个代码的空间复杂度是O(N), 时间复杂度最差是O(N^2)。\n\n## Code 2\n\n刚刚说过，两个解法的不同其实就在于搜索已预定的所有序列的时候，<strong>Code 1</strong> 使用的是最朴素的遍历，我们这里将要使用的是二分查找。\n\n首先是两个C++的API:\n\n> map<Key,T,Compare,Allocator>::upper_bound(const Key& key)  获取当前map中第一个Key值小于等于key 的Key-Value pair。\n>\n> map<Key,T,Compare,Allocator>::lower_bound(const Key& key) 获取当前map中第一个Key值大于等于key 的Key-Value pair。\n>\n> 换言之，upper_bound和lower_bound返回的都是以<strong>参数key</strong>作为upper_bound或者lower_bound的第一个目标entry iterator。\n\n然后再来看这道题，假设book传进来的是`book(int start, end)`, 我们获得两个值，floor=upper_bound(start), ceiling=lower_bound(start), 右边是floor，左边是ceiling。我们先看左边的floor, 如果此时，`it->first < end`,说明有overlap。\n\n按理来说这个时候应该通过upper_bound(start)获得左边的ceiling, 但是因为我们可以确定当前map里没有出现overlap，所以我们可以把lower_bound减一，来获得当前的upper_bound, 然后来判断`it->second > start`就说明有overlap。\n\n![421574405947_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/421574405947_.pic.jpg)\n\n上代码：\n\n```\nclass MyCalendar\n{\nprivate:\n    map<int, int> mp;\npublic:\n\n    MyCalendar(){}\n    bool book(int start, int end)\n    {\n        map<int, int>::const_iterator it = mp.lower_bound(start);\n        if (it != mp.cend() && it->first < end)\n            return false;\n        if (it != mp.cend() && (--it)->second > start)\n            return false;\n        mp[start] = end;\n        return true;\n    }\n};\n```\n\n","tags":["C++","算法"]},{"title":"Leetcode-1040-MovingStonesUntilConsecutiveII","url":"/2019/11/19/Leetcode-1040-MovingStonesUntilConsecutiveII/","content":"\nLeetcode 1040 Moving Stones Until Consecutive II \n\n这道题…卡了还挺久的，今天看了一个解法挺好的，记录一下。\n\n## 题目\n\nOn an **infinite** number line, the position of the i-th stone is given by `stones[i]`. Call a stone an *endpoint stone* if it has the smallest or largest position.\n\nEach turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, `stones = [1,2,5]`, you **cannot** move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\n\nWhen the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: `answer = [minimum_moves, maximum_moves]`\n\n \n\n**Example 1:**\n\n```\nInput: [7,4,9]\nOutput: [1,2]\nExplanation: \nWe can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n```\n\n**Example 2:**\n\n```\nInput: [6,5,4,3,10]\nOutput: [2,3]\nWe can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n```\n\n**Example 3:**\n\n```\nInput: [100,101,104,102,103]\nOutput: [0,0]\n```\n\n \n\n**Note:**\n\n1. `3 <= stones.length <= 10^4`\n2. `1 <= stones[i] <= 10^9`\n3. `stones[i]` have distinct values.\n\n## 题意\n\n在一条无限长的线上给定n个数字代表位置，每次可以取一个endpoint，即首尾的点插入到中间的空位，唯一的限制就是每个endpoint不能再插入以后依然作为endpoint，一直到所有的数字都是连续的，我们不能再继续移动endpoint为止，题目需要我们返回移动的最少和最大次数。\n\n我们先来看max_steps, 我们可以将所有的数字从最左边或者最右边开始往中间插，每次插入到第一个空位，举个🌰， 数组`[1, 3, 5, 6, 8, 9]`，我们可以将所有的数字作如下移动：\n\n```\n[1, 3, 5, 6, 8, 9]\n[3, 4, 5, 6, 8, 9]\n[4, 5, 6, 7, 8, 9]\n```\n\n又或者这个数组`[1, 2, 3, 4, 5, 8]`,我们进行的操作如下：\n\n```\n[1, 2, 3, 4, 5, 8]\n[2, 3, 4, 5, 6, 8]\n[3, 4, 5, 6, 7, 8]\n```\n\n所以我们首先可以得出给定的数组中的空位一共有`s1=stones[n-1] - stones[0] + 1 - n`, 但是并不是所有的空位都可以插入数字，举个例子，`[1, 4, 6]`中，把1移到5以后，<strong>2-3</strong>就不能再继续插入数字了，即第一次移动石子的时候，移动以后和原本移动的石子相邻的石子，这两个石子之间的空位不能继续插入数字，即为`s2=min(stones[n-1] - stones[n-2] - 1, stones[1] - stones[0] - 1)`，那么我们的max_steps可以通过`s2-s1`得到，`max_steps=max(stones[n-2] - stones[n-2] + 2 - n, stones[n-1] - stones[1] + 2 - n)`。\n\n然后是最小值min_steps, 我们可以知道，当我们的得到最终结果的时候，一定是一排连续的数字，如果需要求最小的移动数，一定是和最后结果重合数最多的。所以我们用一个滑动窗口来记录当前范围内的所有数字，只要这个窗口大于n我们就计算当前数组和<strong>n个连续数字的数组</strong>的重合数，找最小的就是结果。但是这个题还有一个地方不一样，比如`[1, 2, 3, 4, 6]`, 这个时候我们不能把6移到5，而是把4移到5，然后把6移到4，所以开销（移动数量）为2。\n\n## Code\n\n```cpp\nvector<int> numMovesStonesII(vector<int>& stones)\n{\n    const int n = static_cast<int>(stones.size());\n    sort(begin(stones), end(stones));\n\n    int max_steps = std::max(stones[n-2] - stones[0] + 2 - n, stones[n-1] - stones[1] + 2 -n);\n\n    int min_steps = INT_MAX;\n    int i = 0;\n    int j = 0;\n    for (i = 0; i < n; ++i) {\n        while (j + 1 < n && stones[j+1] - stones[i] + 1 <= n)\n            j++;\n        int cost = n - (j - i + 1);\n        if (j - i + 1 == n-1 && stones[j] - stones[i] + 1 == n-1)\n            cost = 2;\n        min_steps = std::min(min_steps, cost);\n    }\n\n    return {min_steps, max_steps};\n}\n```\n\n","tags":["C++","Leetcode"]},{"title":"Leetcode-926-FlipStringToMonotoneIncreasing","url":"/2019/11/12/Leetcode-926-FlipStringToMonotoneIncreasing/","content":"\nLeetcode 926 Flip String To Monotone Increasing \n\n水一道Leetcode = = \n\n\n\n# 题目\n\n>A string of `'0'`s and `'1'`s is *monotone increasing* if it consists of some number of `'0'`s (possibly 0), followed by some number of `'1'`s (also possibly 0.)\n>\n>We are given a string `S` of `'0'`s and `'1'`s, and we may flip any `'0'` to a `'1'` or a `'1'` to a `'0'`.\n>\n>Return the minimum number of flips to make `S` monotone increasing.\n>\n> \n>\n>**Example 1:**\n>\n>```\n>Input: \"00110\"\n>Output: 1\n>Explanation: We flip the last digit to get 00111.\n>```\n>\n>**Example 2:**\n>\n>```\n>Input: \"010110\"\n>Output: 2\n>Explanation: We flip to get 011111, or alternatively 000111.\n>```\n>\n>**Example 3:**\n>\n>```\n>Input: \"00011000\"\n>Output: 2\n>Explanation: We flip to get 00000000.\n>```\n>\n> \n>\n>**Note:**\n>\n>1. `1 <= S.length <= 20000`\n>2. `S` only consists of `'0'` and `'1'` characters.\n\n# 题意\n\n这个题，题目为给定一个string，由0和1组成，需要判断最少flip多少次才能将这个字符串转变为单调递增的string，可以全为0或1，也可以0-i 全部为0， i+1-n全部为1。这个题一开始看到我是想到用dp的，但是没写出来…这个算是两个解法记录一下，然后第二个解法逐渐优化。\n\n# Code\n\n## 解法1\n\n用两个数组l & r，l[i]表示 从0 ～ i的1的数量，r[i]表示i ～ n的0的数量，两个相加，取最小的一种解法，也可以取两个边界情况，最后的值就是 min(l[i-1] + r[i], r[0], l[n-1]).\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<int> l(n+1, 0);\n    vector<int> r(n+1, 0);\n\n    l[0] = S[0] == '1';\n    for (int i = 1; i < n; ++i)\n        l[i] = l[i-1] + (S[i] == '1');\n\n    r[n-1] = S[n-1] == '0';\n    for (int i = n-2; i >= 0; --i)\n        r[i] = r[i+1] + (S[i] == '0');\n\n    int res = r[0];\n    for (int i = 1; i <= n; i++)\n        res = std::min(l[i-1] + r[i], res);\n    return res;\n}\n```\n\n## 解法2\n\n其实解法2和解法1还是很像的，但是是有一个状态转移方程，我们用一个数组dp\\[n+1\\]\\[2\\]来记录前面的状态。dp[i][0]是我们当前数字作为0，需要翻转的最小数量，我们不关心前面出现的0或者1，只关心当前数字，dp[i][1]则是当前数字作为1需要翻转的最小数量。\n假设我们走到index为i的数字，如果这个数字为0，那么 dp\\[i\\]\\[0\\]=dp[i-1][0]，也就是说，我们需要flip的数字数量与dp[i-1][0]是相同的，不需要再额外flip。如果此时数字为1，那么我们的dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1, 也就是说，我们可以把当前的i作为0和1的分界点，也就是<strong>接下来所有1中的第一个1</strong>,或者前面已经出现1，我们需要将这个0flip成为1。也就是+1。\n当我们走到为1的数字，同样index是i，那么dp[i][0] = dp[i-1][0] + 1,是指如果我们需要这个数字为0，那么需要前一个为0，然后+1次flip。dp[i][1] = min(dp[i-1][0], dp[i-1][1]), 这个同样是指我们将这个数字作为分界点或者继续当1，取最小值即可。\n归纳一下状态转移方程:\n> if s[i] == '0': \n> \tdp[i][0] = dp[i-1][0]\n> \tdp[i][1] = min(dp[i-1][0]m dp[i-1][1]) + 1\n> else if s[i] == '1':\n> \tdp[i][0] = dp[i-1][0] + 1\n> \tdp[i][1] = min(dp[i-1][0], dp[i-1][1])\n\n再精简一下，我们可以看到两个分支其实是比较相像的，所以可以简化为：\n> dp[i][0] = dp[i-1][0] + (s[i] == '1')\n> dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + (s[i] == '0')\n\n然后上代码：\n```cpp \nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<vector<int>> dp(n+1, vector<int>(2));\n    dp[0][0] = S[0] == '1';\n    dp[0][1] = S[1] == '0';\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = dp[i - 1][0] + (S[i] == '1');\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + (S[i] == '0');\n    }\n    return min(dp[n][0], dp[n][1]);\n}\n```\n\n## 解法3 \n\n解法3其实还挺取巧的，也是解法2的进一步优化，因为我们可以在解法2中看到，每一步的状态都只与上一步的状态有关，也就是说，我们完全可以把空间复杂度从O(N)优化到O(1)，不复杂，直接上代码:\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    int dp0 = S[0] == '1';\n    int dp1 = S[0] == '0';\n\n    for (int i = 1; i <= n; ++i) {\n        int tmp0 = dp0 + (S[i] == '1');\n        dp1 = min(dp0, dp1 + (S[i] == '0'));\n        dp0 = tmp0;\n    }\n    return min(dp0, dp1);\n}\n```\n\n","tags":["C++","Leetcode","dp"]},{"title":"Leetcode-39-CombinationSum","url":"/2019/11/07/Leetcode-39-CombinationSum/","content":"\n# Leetcode 39 Combination Sum\n\n## 题目\n\n> Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.\n>\n> The **same** repeated number may be chosen from `candidates` unlimited number of times.\n>\n> **Note:**\n>\n> - All numbers (including `target`) will be positive integers.\n> - The solution set must not contain duplicate combinations.\n>\n> **Example 1:**\n>\n> ```\n> Input: candidates = [2,3,6,7], target = 7,\n> A solution set is:\n> [\n>   [7],\n>   [2,2,3]\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: candidates = [2,3,5], target = 8,\n> A solution set is:\n> [\n>   [2,2,2,2],\n>   [2,3,3],\n>   [3,5]\n> ]\n> ```\n\n## 题意 \n\n这个题其实很久之前刷过，但是今天又刷到了…就又做了一遍，因为之前是看的答案，现在刷了一遍，有一丢丢不同，但是性能反而提高了很多。\n\n这道题给定一个数组和一个target，求数组中的哪些数字之和是target，数字<strong>可以重复使用</strong>，所以思路当然是用dfs啦，原来的思路是把target传到dfs里面，每次到一个 新数字就把target减去这个数字，我这次直接把target和sum一起传了进去然后进行比较，不知道为什么性能会高很多。。。\n\n## Code\n\n```cpp\nvoid dfs(vector<int>& candidates, int sum, int index, int target, vector<vector<int>>& res, vector<int> tmp)\n{\n    if (sum == target) {\n        res.push_back(tmp);\n        return;\n    }\n    if (sum > target)\n        return;\n    int n = candidates.size();\n    for (int i = index; i < n; ++i) {\n        tmp.push_back(candidates[i]);\n        dfs(candidates, sum + candidates[i], i, target, res, tmp);\n        tmp.pop_back();\n    }\n}\n\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target)\n{\n    vector<vector<int>> res;\n    vector<int> tmp;\n    int n = candidates.size();\n    dfs(candidates, 0, 0, target, res, tmp);\n    return res;\n}\n```\n\n大概就是这个思路，如果加到了target，那就把tmp压到res里面，否则就根据大小判断继续dfs or return。\n\n> 但是！！！\n\n我发现了一个性能好强的思路，比我这个高到不知道哪里去了，大概意思是，用一个和给定的数组相同大小的数组来记录当前哪个index被加入到了sum里面去，如果sum没超，就继续遍历给定的数组，超了就把当前这个index所有的数字给清空，如果sum刚好等于target，那么就把新数组中所有index对应的数组写入到结果中。\n\n## Code 2 \n\n```cpp\nvector<vector<int>> combinationSum(const vector<int>& n, int target) {\n    vector<int> factor(n.size());\n    vector<vector<int>> res;\n    int sum = 0;\n\n    do {\n        for (int i = 0; i < n.size(); i++) {\n            if (sum + n[i] <= target) {\n                sum += n[i];\n                factor[i] += 1;\n                break;\n            }\n            sum -= n[i] * factor[i];\n            factor[i] = 0;\n        }\n        if (sum == target) {\n            vector<int> tmp;\n            for (int i = 0; i < factor.size(); i++) {\n                for (int j = 0; j < factor[i]; j++)\n                    tmp.push_back(n[i]);\n            }\n            res.push_back(move(tmp));\n        }\n    } while (sum > 0);\n    return res;\n}\n```\n\n","tags":["C++","算法"]},{"title":"Leetcode-169-MajorityElement","url":"/2019/10/16/Leetcode-169-MajorityElement/","content":"\n# Leetcode 169 Majority Element\n\n\n\n一道挺经典的题，记录下 =  = \n\n## 题目\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n## 题意\n\n这道题意思是说，给定一个数组，长度为n，其中某个数字出现的频率大于n/2,求这个数字，这个题我一开始打算用brute force,直接排序取中位数，一定是这个重复率最高的数字，因为重复超过n/2了嘛。但是提交以后…效率超过了4%的代码哈哈哈哈哈哈哈哈哈，所以又在网上找了一个效率很高的写法。\n\n这个数字出现频率超过其它所有数字，那我们就遍历这个数组，给定一个tmp = nums[0]，遍历数组，下一个数字如果和当前数字相同， 就cnt++，否则cnt-- ,一旦cnt == 0,我们就把tmp覆盖成下一个数字，因为出现频率够高，最后tmp一定就是结果。\n\n## Code\n\n```cpp\nint tmp, cnt = 0, n = nums.size();\n\n    for (int i = 0; i < n; ++i) {\n        if (cnt == 0)\n            tmp = nums[i];\n\n        if (nums[i] == tmp)\n            cnt++;\n        else\n            cnt--;\n    }\n    return tmp;\n```\n\n","tags":["C++"]},{"title":"nginx编译笔记","url":"/2019/10/07/nginx编译笔记/","content":"\n> 最近要开始学习Nginx了，记录下编译的过程\n\n\n\n# 环境准备\n\n先安装了一个虚拟机，VMWare Fusion 11.5 Pro，然后搞了一个Cent OS iso镜像，第一次安装的时候选错了，选成极简版的了，安装也没有GNome桌面 = = ，重新安了一下以后，调整了IPV4，可以正常上网了。\n\n根据书中讲的折腾出来的configure参数。\n\n```\n./configure --with-openssl=/root/openssl-1.0.2f --with-libatomic --with-zlib=/root/zlib-1.2.11 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_stub_status_module --with-google_perftools_module --with-debug --with-pcre=/root/pcre-8.43 --add-module=/root/nginx/test_module/\n```\n\n主要是需要手动下载prce，openssl,以及zlib的源码，下好以后直接交叉编译，然后make -j4 && make install 大法 目前已经编译好了。\n\n\n\n# 启动 & 关闭Nginx\n\n最简单的启动方式，可以通过/usr/local/nginx/sbin/nginx 进行启动，使用默认设置，还可以指定conf以及指定指定pid写入的文件路径等等。\n\n关闭的话可以使用/usr/local/nginx/sbin/nginx -s stop/quit两种。\n\n\n\n# 使用自己的第三方插件\n\n","tags":["nginx"]},{"title":"Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays","url":"/2019/10/05/Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays/","content":"\n# Leetcode 1031 Maxmium Sum of Two Non-overlapping Subarrays\n\n\n\n## 题目\n\nGiven an array `A` of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths `L` and `M`.  (For clarification, the `L`-length subarray could occur before or after the `M`-length subarray.)\n\nFormally, return the largest `V` for which `V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])` and either:\n\n- `0 <= i < i + L - 1 < j < j + M - 1 < A.length`, **or**\n- `0 <= j < j + M - 1 < i < i + L - 1 < A.length`.\n\n**Example 1:**\n\n```\nInput: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n```\n\n**Example 2:**\n\n```\nInput: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n```\n\n**Example 3:**\n\n```\nInput: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.\n```\n\n**Note:**\n\n1. `L >= 1`\n2. `M >= 1`\n3. `L + M <= A.length <= 1000`\n4. `0 <= A[i] <= 1000`\n\n\n\n## 题意\n\n好久没刷题了，看到这个题一点头绪也没有，特此记录一下，<strong>以后涉及到这种求子数组最大和的题目，优先使用前缀和</strong>。\n\n这道题翻译下，给定一个数组，以及两个整数L&M，返回两个字数组之和，要求为最大值，且两个字数组的长度分别为L M。所以这个题我们需要遍历两次，首先是用一个数组记录该数组的前缀和，然后通过动态规划来求的需要的值。\n\n如何进行动态规划？我们需要两个变量max_l & max_m, 分别表示两个字数组各自的最大和，然后此时会有两种情况，一种是L在左，M在右，另一种相反。假设此时遍历到index为i的数字，我们的返回值可能会有两种，一种为情况1，另一种为情况2，如图所示（暂时无图 = = ），我们只需要算出最大值，然后赋值给result就可以了。\n\n但是算出最大值之前我们是需要更新当前的max_l & max_m，至于更新的范围，比如我们需要更新max_l, 此时我们以前i - M个数中最大的长度为L的子序列之和为max_l，所以max_l = max(max_l, pre_sum[i - M] - pre_sum[i - L - M]),max_m也是相同的方法来更新。\n\n## Code\n\n```cpp\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M)\n{\n    int n = A.size();\n    vector<int>& pre_sum = A;\n\n    for (int i = 1; i < n; ++i) {\n        pre_sum[i] = pre_sum[i-1] + A[i];\n    }\n\n    int res = pre_sum[L + M - 1];\n    int max_l = pre_sum[l-1];\n    int max_m = pre_sum[m-1];\n    for (int i = L + M; i < n; ++i) {\n        max_l = max(max_l, pre_sum[i - M] - pre_sum[i - M - L]);\n        max_m = max(max_m, pre_sum[i - L] - pre_sum[i - M - L]);\n        res = max(res, max(max_l + pre_sum[i] - pre_sum[i-M], max_m + pre_sum[i] - pre_sum[i-L]));\n    }\n\n    return res;\n}\n```\n\n","tags":["C++"]},{"title":"Leetcode-1074-NumbersToSubmatricesThatSumToTarget","url":"/2019/09/17/Leetcode-1074-NumbersToSubmatricesThatSumToTarget/","content":"\nLeetcode 1074 Numbers To Submatrices That Sum To Target\n\n一道Leetcode Hard 级别的题目 ，用了一晚来理解，特此记录。\n\n# 题目\n\n> Given a `matrix`, and a `target`, return the number of non-empty submatrices that sum to target.\n>\n> A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.\n>\n> Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.\n>\n>  \n>\n> **Example 1:**\n>\n> ```\n> Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n> Output: 4\n> Explanation: The four 1x1 submatrices that only contain 0.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: matrix = [[1,-1],[-1,1]], target = 0\n> Output: 5\n> Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n> ```\n\n# 题解\n\n这道题意思是说，给定一个矩阵matrix，以及一个target，为int类型，需要你求出所有的submatrix中和为target的数量，这个题乍一看会很复杂，用最简单的brute force是可以求出来的，复杂度为O(N^4)m，这个复杂度其实还挺难接受的 = = ，所以我们有了如下解法：\n\n我们先求prefixSum，可以按行也可以按照列，我采用的方法是按行求，然后我们再固定一个l和一个r指针，用来表示submatrix的左右两边，另通过一个k来从上而下的遍历整列，求得一个sum，将这个sum记录在我们的unordered_map中，并且，我们通过sum - target就可以得到以k为底线，submatrix的sum为target的数量。因为这个sum其实本质上也是一个从上至下叠加的和，所以我们减去target得到的值，其实是一个上限的数量，刚好与k，以及l和r围成了一个submatrix。\n\n\n\n# Code \n\n```cpp\nint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target)\n{\n    int n = matrix.size(), m = matrix[0].size();\n    int ans = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 1; j < m; j++)\n            matrix[i][j] += matrix[i][j - 1];\n\n    for (int l = 0; l < m; l++)\n        for (int r = l; r < m; r++) {\n            unordered_map<int, int> vis;\n            vis[0] = 1;\n            int tot = 0;\n            for (int k = 0; k < n; k++) {\n                if (l == 0) {\n                    tot += matrix[k][r];\n                } else {\n                    tot += matrix[k][r] - matrix[k][l - 1];\n                }\n                if (vis.find(tot - target) != vis.end())\n                    ans += vis[tot - target];\n                vis[tot]++;\n            }\n        }\n    return ans;\n}\n```","tags":["C++","Leetcode"]},{"title":"Leetcode-1122-RelativeSortArray","url":"/2019/09/04/Leetcode-1122-RelativeSortArray/","content":"\nLeetcode 1122 Relative Sort Array\n\n这个题虽然是easy级别的题目，但是这个解法挺高明的，而且在Leetcode上时间和空间都超过了100%的提交，特此记录下。\n\n# 题目\n\n> Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n>\n> Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`.  Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.\n\n# 题解\n\n给定两个数组arr1以及arr2，其中arr2的数字是distinct的，数字1的会有重复，需要我们将arr1中的数字sort成arr2中的顺序，而且对于arr2中不存在的数字，需要将其按升序排列。\n\n举个🌰：\n\n```\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]\n```\n\n本题中的解法使用的是：通过一个自定义sort()函数的第三个参数，即一个function/functor，来对arr1进行sort，因为arr2中的变量是不会重复的，我们将arr2中的变量的index作为排序的依据。即：对于arr1以及arr2中存在的数字，排序的依据是arr2中变量的index，对于arr1中存在，arr2中不存在的数字，我们根据其本身大小进行排序。如果arr1中两个数字，第一个在arr2中存在，第二个不存在，那么第一个应该排在第二个前面，否则就是后面。直接上代码了。\n\n# Code\n\n```cpp\n#include <vector>\n\nusing std::vector;\n\nvector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2)\n{\n    int max = 0;\n    for (auto i : arr2)\n        if (i > max)\n            max = i;\n\n    vector<int> order(max+1, -1);\n\n    int n = arr2.size();\n    for (int i = 0; i < n; i++)\n        order[arr2[i]] = i;\n\n    n = (int)order.size();\n    auto cmp = [&order, &n](const int a, const int b) -> bool\n    {\n        bool contain_a = false, contain_b = false;\n        if (a < n && order[a] != -1)\n            contain_a = true;\n        if (b < n && order[b] != -1)\n            contain_b = true;\n\n        if (contain_a && contain_b)\n            return order[a] < order[b];\n        else if (!contain_a && !contain_b)\n            return a < b;\n        else if (contain_a)\n            return true;\n        else\n            return false;\n    };\n\n    sort(arr1.begin(), arr1.end(), cmp);\n    return arr1;\n}\n```\n\n\n\n-------\n\n又水了一道题，快乐;D","tags":["C++","Leetcode"]},{"title":"Leetcode-845-LongestMountainInArray","url":"/2019/08/24/Leetcode-845-LongestMountainInArray/","content":"\nLeetcode 845 LongestMountainInArray\n\n# 题意\n\nLet's call any (contiguous) subarray B (of A) a *mountain* if the following properties hold:\n\n- `B.length >= 3`\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\n\n(Note that B could be any subarray of A, including the entire array A.)\n\nGiven an array `A` of integers, return the length of the longest *mountain*. \n\nReturn `0` if there is no mountain.\n\n#First Version\n\n## 题解\n\n这个题定义了一种Mountain,即当前subarray的数字先递增后递减，求最长的Mountain子序列的长度。这个题我们可以用一个up和down数组来存储遍历的值，up[i]表示数组中第i个位置的值是当前递增序列的第几个，down的意思也是,down[i]表示数组的第i个值是当前递减序列的第几个（从n-2开始），然后遍历两个数组，当up[i]和down[i]同时为正的时候，通过up[i] + down[i] + 1就可以得出山峰的length.\n\n## Code\n\n```cpp\nint longestMountain(vector<int>& A)\n{\n    if (A.size() == 0)\n        return 0;\n\n    int n = A.size();\n    int len = INT_MIN;\n    vector<int> up(n, 0);\n    vector<int> down(n, 0);\n\n    for (int i = n-2; i >= 0; --i)\n        if (A[i] > A[i+1])\n            down[i] = down[i+1] + 1;\n\n    for (int i = 1; i < n; i++)\n    {\n        if (A[i] > A[i-1])\n            up[i] = up[i-1] + 1;\n\n        if (up[i] > 0 && down[i] > 0)\n            len = max(len, down[i] + up[i] + 1);\n    }\n    return len;\n}\n```\n\n-------\n\n# Anthor Version\n\n\n\n","tags":["C++"],"categories":["算法"]},{"title":"SlideWindow模板","url":"/2019/08/24/SlideWindow模板/","content":"\n# Slide Window模板\n\nSlideWindow类型的题刷了很多了，总结一个模板出来\n\n首先，用两个指针l,r表示左右边界，l = 0, r = 0。通过这个l r来表示一个<strong>左开右闭区间</strong>, 即[l, r)。\n\n然后在一个循环中遍历整个数组，终结条件为 r == array.size(), 每次循环做的第一件事是, sum += array[r++],然后对sum的值进行判断，如果没有达到需要的condition就continue，否则进行判断，但是这边一个容易被忽略过去的地方，即l到r的范围中，如果r-1位目标值，其中，[l,r-1]区间中有可能还有我们需要的结果，所以我们再来将[l,r-1]区间中的值进行遍历。（这步可以理解为，以数组中每一个值作为subarray的最后一个值，判断当前subarray是否符合需求)\n\n最后一个容易忽略的地方，当循环结束后，我们仍有[l,r-1]区间的值未遍历，其中有可能出现我们需要的结果,所以最后一个扫尾，把这段值处理下就可以了。\n\n\n\n## code\n\n```cpp\ntemplate <typename T>\nint SlideWindow(vector<T>& array, T target)\n{\n  if (array.size() == 0)\n    return;\n  \n  int l = 0;\n  int r = 0;\n \tint sum = array[0];\n  int ans = 0;\n  \n  //左开右闭区间，求长度可直接通过 r - l 得到\n  while (r < array.size())\n  {\n    sum += array[r++];\n    \n    if (sum < target)\n      continue;\n    else if (sum == target)\n    \tans++;\n   \telse\n    {\n      while (sum > target && l < r)\n      {\n        sum -= array[l++];\n        if (sum == target)\n          ans++;\n      }\n    }\n  }\n  \n  // 扫尾\n  while (sum > target && l < r)\n  {\n    sum -= array[l++];\n    if (sum == target)\n\t\t\tans++;\n  }\n  \n  return ans;\n}\n```\n\n","tags":["C++"],"categories":["算法"]},{"title":"Leetcode-234-PalindromeLinkedList","url":"/2019/08/18/Leetcode-234-PalindromeLinkedList/","content":"\nLeetcode 234 Palindrome Linked List\n\n刷道水题  = = \n\n我也不知道为啥这题的通过率比hard的级别的通过率都低…我寻思可能是这个边界处理比较复杂？直接看题8.\n\n\n\n# 题目\n\nGiven a singly linked list, determine if it is a palindrome.\n\n**Example 1:**\n\n```\nInput: 1->2\nOutput: false\n```\n\n**Example 2:**\n\n```\nInput: 1->2->2->1\nOutput: true\n```\n\n**Follow up:**\nCould you do it in O(n) time and O(1) space?\n\n# 题意\n\n其实就是最基本的单链表问题，问你给定的链表是否是一个回文链表，我寻思这个题其实一开始在刷牛客的链表题的时候就有过了。基本思路还是很清晰，找到链表的中间节点，然后将链表后半部分倒转，从两边的header分别遍历，最后看经过的路上的值是否一致就可以了。\n\n还有就是，我们没必要关心这个链表的长度是奇数或者偶数，因为即使分开两个链表长度相差1，我们只需要遍历前面相同的就可以了。\n\n最主要的地方还是，一开始找中点的时候，需要一个快慢指针，当快指针的next以及next->next有一个为空时，我们便认为到达了slow指针到达了中点，因为没法继续往下走了。然后是reverse list基本操作，但不要忘记将slow指针的next置为nullptr(C++11 不要像下面的代码一样写NULL).\n\n\n\n# Code\n\n```cpp\nbool isPalindrome(ListNode *head) {\n    if (head == NULL || head->next == NULL)\n        return true;\n\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    /* find middle point */\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    /* reverse half the list */\n    ListNode *cur = slow->next;\n    ListNode *next = cur->next;\n    ListNode *tmp = NULL;\n    cur->next = NULL;\n\n    /* break the list */\n    slow->next = NULL;\n\n    while (next != NULL) {\n        tmp = next->next;\n        next->next = cur;\n        cur = next;\n        next = tmp;\n    }\n\n    /* It doesn't matter the length of the list is odd or even,\n     * because these two pointers will come to an end */\n    while (head && cur) {\n        if (head->val != cur->val)\n            return false;\n        head = head->next;\n        cur = cur->next;\n    }\n\n    return true;\n}\n```\n\n\n\nDone. \n\n今日份的水题。","tags":["C++","Leetcode"]},{"title":"右值引用","url":"/2019/08/13/右值引用/","content":"\n\n> 很久之前看的左值与右值引用这类的东西，但是现在已经记不清楚概念，所以重新写篇博客来记录整理一下。\n\n---------------------------------\n\n# 左值与右值\n\n左值与右值在C语言中就有出现，<strong>\"lvalue\"</strong>与<strong>\"rvalue\"</strong>，字面上l和r为left和right，其实我更愿意把它们理解location与read，一个是在内存中有明确的地址，有一个属于自己的\"名分\"，另一个则是只能被read （literally）， 所以两个的区别其实已经一目了然。在代码中表现出来则是这个样子。\n\n```cpp\nint i = 0; // i 是左值，在栈上有地址，0是右值\n\nint dummy(20);\nint mummy(30);\n\nint foo = dummy;  \t//foo是左值\nfoo = dummy * mummy; // dummy * mummy是右值\n```\n\n在判断一个值是左值还是右值时，我们只需要考虑，这个值是否<strong>真实存在</strong>。如果作为一个函数的返回值，这个值在内存中其实并不存在，所以是右值。\n\n\n# 左值引用与右值引用\n\n这两个也很好理解，顾名思义，左值引用就是对左值的引用，用&表示，右值引用则是对右值的引用，通过&&来表示。\n\n```cpp\nint foo = 50;\nint app = 60;\n\nint &dummy = foo; // dummy是左值引用\nint &&rdummy = 30; // 30是右值 rdummy是右值引用\n\nconst int &ra = a; // const 左值引用\nconst int &&rra = 30; // const 右值引用\n\n// 一种特殊情况 \nconst int &ra = 30;  // const 左值引用绑定在一个右值上，因为这个值不能修改。\n```\n\n右值引用只能绑定在右值上，所以资源要么是立刻被销毁，或者只是一个字面常量，这就意味着对右值进行引用后可以接管这个右值的所有并随意修改，而不用担心会造成什么奇怪的影响。可以说是一个很方便的特性了。\n\n# 引用的值类型与引用叠加\n\n## 值类型\n\n我们先来看左值引用与右值引用本身是左值还是右值呢？\n\n```cpp\nint foo(40);\n\nint &lfoo = foo;\nint &dummy = lfoo;  \t//将一个左值引用作为右值赋值给dummy\n\nint &du = ++foo;  \t//将前置自增的++返回的左值作为右值赋值给du\n```\n\n我们可以看到，左值或者左值引用都可以作为右值赋值给别的变量，更仔细的说，一个左值，作为一个变量被保存下来，那么它就是一个左值，如果只是被当成一个右值用来赋值，那么生命周期与一个右值一样短暂。\n\n同样的，一个右值被返回后被存储在一个变量中，那就应该被当成一个左值来对待，否则就是一个右值。\n\n## 引用叠加\n\n```cpp\n\ntypedef int& intR;\ntypedef intR& intRR;\n\nint main()\n{\n\tint dummy(10);\n\tintR i = dummy;  \n\tintRR rri = i;\n}\n\n```\n\n在这里面，intR其实是一个int &, 但是intRR 其实应该是int& &,表示的是对一个int类型引用的引用，这个其实就是C++的引用叠加，有如下规则。\n\n```cpp\nType& & = Type&;\nType& && = Type&;\nType&& & = Type&;\nType&& && = Type&&;\n```\n\n这就是C++引用的叠加。有点像0与1求&，只要有左值引用那么最后叠加以后一定会是一个左值。\n\n#   右值引用使用场景\n\n所谓的右值引用可以应用在什么地方呢？\n\n## move语义\n\n先来看一段代码。\t\n\n```cpp\n\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n}\n\n```\n\n但是实际应用的时候会发现，简单的几段代码调用的函数分别有：\n\n> Trivial Constructor\n> explicit Constructor\n> operator =\n> Destructor\n> Destructor\n\n本次的调用过程分别有：首先调用Trivial Constructor，对dummy1进行construct，然后进入到get(),调用explicit Constructor对get()中的dummy进行consturct。返回一个dummy后，通过operator=()重载的=预算符赋值给dummy1，代码执行完以后，分别为dummy和dummy1调用destructor。\n\n\n\n在operatro=中，我们是把dummy中的指针取出来然后重新构造，需要重新调用new和Inner的delete，而且我们还可以注意到，get()返回的是一个右值，我们完全可以为operator=和copy constructor重新定制一个右值版本，分别称为move assignment和move constructor.\n\n```cpp\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\n    Dummy(Dummy&& dummy) : inner_(dummy.inner_)\n    {\n        dummy.inner_ = nullptr;\n        cout << \"move Construct \" << endl;\n    }\n\n    Dummy& operator=(Dummy&& dummy)\n    {\n        Inner *tmp = dummy.inner_;\n        dummy.inner_ = inner_;\n        inner_ = tmp;\n        tmp = nullptr;\n        cout << \"move assignment\" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n    return 0;\n}\n```\n\n这段代码的运行结果如下：\n\n> Trivial Constructor\n> explicit Constructor\n> move assignment\n> Destructor\n> Destructor\n\n通过move assignment，我们可以将原来的copy assignment中的一次new & delete给消除掉来提升性能。\n\n本质上来说，我们做了一次浅拷贝来节省性能，而dummy变成了一个dangling pointer, 所以给它赋值为nullptr.\n\n## 完美转发(perfect farward)\n\n假如说我们有很多种类型的class，而且有的可能会是左值有的会是右值，我们需要通过一个函数来进行转发。\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(t);\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\n\n\n但是得到的结果却和我们想象的完全不一样，得到的结果如下：\n\n```cpp\nexplicit Constructor\nin forward\ncopy Constructor\nin func\nDestructor\nDestructor\n```\n\n通过结果我们可以看出，在调用func的时候，我们以get()返回的右值传进去，按照引用叠加的原理来说，应该给func的也是一个右值，但是实际上根据调用的结果来看，传进去的t是以左值引用的方式过去的，而不是以右值引用的move Constructor版本。具体的原因是因为我们传给func的值其实已经被确确实实的存储在了内存中，所以最后给func()的应该是一个左值引用，通过和&&引用叠加一个真正得到了一个左值引用，所以调用了copy Constructor.\n\n那我们如果想要完成的以它本身的状态来传递的话，就应该以forward<T>()来进行<strong>完美转发</strong>,从而保持T本身的状态，代码如下。\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(std::forward<T>(t));\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\n这样得到的结果是：\n\n> explicit Constructor\n> in forward\n> move Construct\n> in func\n> Destructor\n> Destructor\n\n我们可以看到，此时传进func的结果被完整的保留了右值的身份。通过完美转发来达到我们需要的效果。如果我们把输入forward的类型改为左值:\n\n```cpp\nint main()\n{\n  Dummy du = get();\n  forward(du);\n}\n```\n\n通过这个输入得到的结果是：\n\n> Trivial Constructor\n> in forward\n> copy Constructor\n> in func\n> Destructor\n> Destructor\n\n完美的得到了我们需要的结果。\n\n\n\n\n\n\n\n\n\n","tags":["C++"]},{"title":"弱回调","url":"/2019/08/11/弱回调/","content":"# 弱回调技术\n\n> 最近在拜读陈硕老师的《Linux多线程服务器端编程》，从第一章开始就觉得自己菜 = =，因为书中涉及的知识是我之前仅仅了解了皮毛，甚至是仅有耳闻的内容。所以这本书读起来很吃力，而且需要反复的去品味其中运用的技术。\n\n从第一章来看，主要讲的shared_ptr与weak_ptr的运用，其实大学的时候还有去分析过shared_ptr与weak_ptr的用法，但终归并没有实际去使用这两个推动了C++现代化的工具。\n\n## shared_ptr 与 weak_ptr简介\n\n这两个工具基本上可以说是配套使用的，举个🌰，shared_ptr最大的特点是引用计数，对同一个对象的多次引用，其实质只是在 内部的计数器+1而已，但是如果遇到两个对象相互引用，就会形成死锁。此时就需要weak_ptr来打破僵局，weak_ptr引用的 对象，不会造成shared_ptr内部的计数器+1，可以理解为弱引用。但是本书中主要使用weak_ptr的地方多在于试探，看当前 的对象是否能从weak_ptr提升为shared_ptr,以此来保证对象并未被销毁。 \n## 实例\n\n本书的代码其实是一点一点改进的，我就直接贴个最终版，然后一点一点分析好了=3=\n\n```cpp\n//\n// Created by neojxwang(王靖煊) on 2019-08-08.\n//\n\n#include <vector>\n#include <string>\n\nusing std::vector;\nusing std::string;\n\nclass Stock\n{\npublic:\n\n    Stock() {}\n    Stock(string key) : key_(key) {}\n\n    string key()\n    {\n        return key_;\n    }\nprivate:\n    std::string key_;\n\n};\n\nclass StockFactory\n{\npublic:\n    shared_ptr<Stock> get(std::string key)\n    {\n        shared_ptr<Stock> sPtr;\n\n        pthread_mutex_lock(&mutex_);\n        weak_ptr<Stock>& wPtr = mp[key];\n        sPtr = wPtr.lock();\n        if (!sPtr) {\n            sPtr.reset(new Stock(key), std::bind(&StockFactory::delete, weak_ptr<StockFactory>(enable_shared_from_this()), _1));\n            wPtr = sPtr;\n        }\n        pthread_mutex_unlock(&mutex_);\n        return sPtr;\n    }\n\nprivate:\n    pthread_mutex_t mutex_;\n    std::map<std::string, std::weak_ptr<Stock>> mp;\n\n    void delete(weak_ptr<Stock> wPtr, Stock *stock)\n    {\n        shared_ptr<StockFactory> factory(wPtr.lock());\n\n        if (factory)\n        {\n            factory->removeStock(stock);\n        }\n\n        delete stock;\n    }\n\n    void removeStock(Stock * stock)\n    {\n        if (stock)\n        {\n            pthread_mutex_lock(&mutex_);\n            mp.erase(stock->key());\n        }\n    }\n};\n\n\n``` \n\n假设有各个股票，每个股票有一个唯一代码key，我们唯一要做的就是通过这个key来取到股票的对象，但是获得这个对象在多进 程环境下其实是存在竞争的，假设如下情况，进程A刚刚通过get()方法获得了对应的股票对象，进程B被推上CPU，并对那个 股票对象进行了销毁操作，并切回进程A，那么此时，会出现coredump。\n\n所以我们最一开始的使用一个shared_ptr来存储map中的Stock对象，即<strong>std::map<std::string, std::shared_ptr<Stock>></strong> 但是这样虽然可以方便对象的生命周期管理，但是此时的shared_ptr<strong>不会被销毁</strong>,所以我们该用weak_ptr来对 map中的Stock进行管理，只有在真正进行操作的时候，才将weak_ptr提升成shared_ptr。\n\n但是这个样子其实还是会使得内存进行泄漏的，那个map的size其实是只增不减的，因为并没有将map中的元素进行erase， 即使这个元素没有被引用，使用的内存也不会减少，这其实就是变相的内存泄露。所以我们使用shared_ptr的定制内存销毁函数， 也就是使用std::bind()将shared_ptr的第二个元素绑定为一个函数，在这里bind了一个类内部函数，所以使用 std::bind(&StockFactory::delete, this, _1)作为shared_ptr.reset()的第二个参数。 \n> bind 用法可以见上篇文章\n\n但是这个时候我们又出现了新的问题，我们将this指针作为参数传给了函数，这就很有可能造成多进程环境下的竞态，一旦 这个类在进程A中被destroy，那么在另一个进程中调用this指针就会造成coredump，所以我们还是使用shared_ptr指针来管理this指针， 这就用到了enable_shared_from_this()方法，该方法可以返回get()成员函数指向的类本身，且是一个shared_ptr函数， 这就保证我们不会在这个类被销毁以后还能调用到this指针，更准确点，应该是我们会保证this被调用的时候，这个类的实例一定不会被销毁。 解决了this指针的问题，我们会发现，此时bind中绑定的StockFactory类实例的生命周期被延长了，我们此时可以通过 <strong>弱回调技术</strong>来解决这个问题。 \n> 所谓弱回调，顾名思义，我们对一个类实例的调用不会影响其本身的生命周期，只在需要的时候保证该类没有被销毁就可以。（我自己瞎说的\n\n最终版本的code就在上面。我们可以看到，这个enable_shared_from_this()方法产生的shared_ptr指针其实被放在了一个 weak_ptr指针中，这就保证this指针的类实例<strong>一定</strong>不会被意外的延长生命周期，而且在需要对this指针进行 操作时，我们可以通过对weak_ptr指针的lock()操作来确保类实例是存在的，这就是弱回调技术。 \n* 总结一下，运用的技术主要是通过weak_ptr来对对象进行弱引用，以保证不意外延长对象的生命周期，并在需要对象的时候通过lock()来提升级别，以保证在多进程环境中对象实例还活着（XD\n\n\n\n\n\n\n","tags":["C++"]},{"title":"Leetcode-567-PermutationStrings","url":"/2019/08/09/Leetcode-567-PermutationStrings/","content":"\n# Leetcode 567 PermutationString \n\n## 题干 \n\n> Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\n\n## 题意 \n\n其实这个题还是很简单的，给定两个string s1和s2,如果s2的某个子集中包含的字母与s1<strong>完全</strong>一样，那么返回true，否则返回false。可以用最普通的方法，用一个s1.length()长度的窗口来遍历s2,每次检查窗口内的字母是否与\ns1相同。但是这个题还有一个比较有意思的解法，反向思维，用一个map记录s1中所有的字母，每次--1，然后还是用一个s1.length()的窗口来遍历，知道可以让该map所有成员都为0。举个例子，假设s1 = \"ba\", s2 = \"acdeab\", 那么初始\nmap={-1, -1, 0, 0, ... , 0}, 然后以一个size为2的窗口遍历整个s2，一直到map中<strong>所有的元素</strong>都为0，就证明是存在的。\n\n## Code\n\n```cpp\nbool checkInclusion(const string &s1, const string &s2)\n{\n    const int n1 = s1.length(), n2 = s2.length();\n    if (n1 > n2)\n        return false;\n    vector<int> mp(27, 0);\n    int i = 0, j = n1;\n\n    for (const auto &c : s1)\n        --mp[c-'a'];\n\n    for (int i = 0; i < j; i++)\n        ++mp[s2[i]-'a'];\n\n    while (j < n2)\n    {\n        if (equal(mp.begin(), mp.end(), mp.rbegin()))\n            return true;\n\n        ++mp[s2[j++] - 'a'];\n        --mp[s2[i++] - 'a'];\n    }\n\n    return equal(mp.begin(), mp.end(), mp.rbegin());\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Leetcode-828-UniqueLetterString","url":"/2019/08/07/Leetcode-828-UniqueLetterString/","content":"\nLeetcode 828 UniqueLetterString\n\n# 题意 \n\n> A character is unique in string S if it occurs exactly once in it.\n> For example, in string S = \"LETTER\", the only unique characters are \"L\" and \"R\".\n> Let's define UNIQ(S) as the number of unique characters in string S.\n>For example, UNIQ(\"LETTER\") =  2.\n>Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.\n>If there are two or more equal substrings at different positions in S, we consider them different.\n>Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.\n\n题意其实很好理解，给定一个字符串S，其中仅出现一次的字符数量用UNIQ(S)表示，若S=\"LETTER\", 那么其中UNIQ(S)=2, 为\"L\"与\"R\"，这个题需要 求得的结果是，给定的S的所有字串的UNIQ()的值。\n\n# 题解\n\n我们可以换一个角度来思考这道题，以字符串\"XAXXAXXA\"为例，假设我们需要得出以第二个\"A\"作为unique char的所有子串数量，我们可以在左右加入() 来表示，那可能的左边字串有\"XA(XXA\"/\"XAX(XA\"/\"XAXX(A\",可能的右边字串有\"AXX)\"/\"AX)X\"/\"A)XX\",各有3种，3*3=9，所以我们可以遍历每个char， 分别求出以当前char为unique char的所有字串数量即为题解。\n\n# Code\n\n```cpp\n#define LL long long\n\nint uniqueLetterString(string S) {\n    const int mod = 1000000007;\n    int n = S.length();\n    LL ans = 0;\n    vector<int> last(26, -1);\n\n    vector<int> left(n, -1), right(n, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        left[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    last = vector<int> (26, n);\n    for (int i = n-1; i >= 0; i--)\n    {\n        right[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n       ans += (ans + (LL)(i - left[i]) * (right[i] - i)) % mod;\n    }\n\n    return ans;\n}\n\n```\n","tags":["C++","Leetcode"]},{"title":"bind","url":"/2019/07/24/bind/","content":"\n\n# C++ std::bind\n\n很久之前学习过bind，但是现在已经记不清楚了…重新学一哈。\n\nC++中应该有Lvalue，Rvalue，但是其实一共有五种来着…\n\nbind的主要作用应该是将方法与参数相绑定。\n\n其可以绑定两种方法，一种是普通的方法，一种是类的成员方法。\n\n```cpp\n\nclass Test\n{\npublic:\n    void changeAB(int a, int b)\n    {\n        a_ = a;\n        b_ = b;\n    }\nprivate:\n    int a_;\n    int b_;\n}\n\nvoid test(int &a, int &b, const int &c)\n{\n    //此处打印结果是 a = 1\n    //在bind时就已经确定了各个参数的类型，不会因为方法本身改变\n    cout << \"in\" << a << \" \" << b << \" \" << c << endl;\n    ++a;\n    ++b; //此处修改main中b的值\n    // ++c; compile error\n}\n\nint main()\n{\n    using namespace std::placeholders; // 使用占位符\n    int a = 1, b = 2, c = 3;\n\n    //绑定test方法\n    std::function<void()> bound_test = std::bind(test, a, std::ref(b), std::cref(c));\n    a = 10;\n    b = 12;\n    c = 13;\n    cout << a  << \"  \" << b << \" \" << c << endl;\n    bound_test();\n    cout << a  << \"  \" << b << \" \" << c << endl;\n\n    //bind 类成员方法：\n    std::function<void()> bound_changeAB(&Test::changeAB, _1, _2);\n    bound_changeAB(a, b);\n}\n\n```\n\n","tags":["C++"]},{"title":"Weak_Ptr相关","url":"/2019/07/23/Weak-Ptr相关/","content":"\n# weak_ptr\n\nweak_ptr是一个C++11的语法，作为一个智能指针，最大的作用就是在多线程的环境下，配合share_ptr进行引用计\n数，但是weak_ptr是弱引用，也就是说，通过weak_ptr进行引用并不会将share_ptr+1, 只有通过lock()提升为\nshared_ptr才能正常的进行访问其中存储的数据，但同时也会进行引用数字的+1。\n\n```cpp\ntemplate <class T>\nstd::shared_ptr<T> lock() const nonexcept;\n```\n\n> 因weak_ptr是无法访问存储的数据的，必须同lock提升为shared_ptr再进行访问。用一个经典的Observer模式来\n> 演示weak_ptr.\n\n```cpp\nclass Observer\n{\npublic:\n    virtual ~Observer() {\n       subject_->unregister(); \n    }\n    virtual void update() {}\n    \n    void observer(Observable *s) {\n        s->register_(this);\n        subject_ = s;\n    }\nprivate:\n    Observable *subject_;\n}\n\nclass Observable\n{\npublic:\n    void register(Observer* ob);\n    void unregister(Observer* ob);\n\n    void notifyRegeisters()\n    {\n        /*******\n        for (auto x : observers_) {\n            x->update();\n        }\n        ******/\n\n        Iterator iter = observers_.begin();\n        while (iter != observers_.end()) \n        {\n            //通过lock() 提升\n            std::shared_ptr<Observer *> obj(iter->lock());     \n            if (obj) {\n                iter->update();\n                iter++;\n            } else {\n                observers_.erase(iter); //提升失败 直接从vector中删除weakptr\n            }\n        }\n    }\n\nprivate:\n    //std::vector<Observers *> observers_;\n    std::vector<std::weak_ptr<Observer *>> observers_;\n    typedef std::vector<std::weak_ptr<Observer *>>::iterator Iterator; \n}\n```\n\n# shared_ptr\n\n## reset \n\n可通过一个T* 的指针重新赋值给shared_ptr，来填充shared_ptr。\n\ntemplate <class T>\nvoid reset(T *) noexcept;\n","tags":["C++"]},{"title":"Leetcode-42-TrappingRainWaters","url":"/2019/07/22/LeetCode-42-TrappingRainWaters/","content":"\n# Leetcode 42 Trapping Rain Waters\n\n## 题目\n\n\n> Given n non-negative integers representing an elevation map where the width of each bar is 1,\n> compute how much water it is able to trap after raining.\n\n![test](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n## 题解\n\n这个题其实很有意思，一开始刷的时候，感觉无从下手，但是第二次刷就好很多，起码有个大概思路，用了\n两种思路来解这道题。\n\n- Two Pointers\n- MonoStack\n\n### Two Pointers\n\n我们可以先理清楚最基本的问题，能Trap住雨水的，一定是有凹槽存在，而这个凹槽能容纳多少水，一定是\n以它两端中最低的这端作为Base，除此之外，应该是两端各取最大值，以达到容纳最多水的效果。举个🌰。\n\n*Lmax L R Rmax*\n\n此时，如果LMax < Rmax,  我们可以计算L点的水量，因为此时，我们以LMax为短板，那么一定有Rmax > LMax\n所以我们可以将L处的水量，即Lmax - L 加入到水量中，反之，则加入RMax - R。\n\n```cpp\nint trap(vector<int>& height)\n{\n    int left = 0;\n    int right = height.size()-1;\n    int leftMax = 0;\n    int rightMax = 0;\n    int res = 0;\n\n    while (left < right)\n    {\n        leftMax = max(height[left], leftMax);\n        rightMax = max(height[right], rightMax);\n\n        if (leftMax > rightMax) {\n            res += rightMax - height[right];\n            right--;\n        } else {\n            res += leftMax - height[left];\n            left++;\n        }\n    }\n\n    return res;\n}\n```\n### MonoStack\n\n这个解法其实也很有意思，单调栈，顾名思义，就是栈内的元素都保持单调递增或递减，因为我们的目的是\n计算容纳的水，那么就要制造高低差。我们使栈内的元素单调递减，考虑一种极限情况，1-4都为单调递减，\n第5个值 > 第一个值，此时，因为第五个值大于栈顶元素，所以我们将栈顶弹出，并将栈作为一个坑，此时，\n坑的高度应该为当前栈（即弹出栈顶后的栈）的栈顶与第五个值的min（显然为栈顶）与坑的高度做差，得到\n此时坑的高度，坑的宽度应该为5 - 3 - 1，也就是第五个元素的index与栈顶的index相减，因宽度为1，故\n再次减一，相乘即为结果。\n\n```cpp\nint trap1(vector<int>& height)\n{\n    stack<int> stk;\n    int res = 0;\n    int i = 0;\n    int sz = height.size();\n\n    while (i < sz)\n    {\n        if (stk.empty() || height[stk.top()] >= height[i])\n            stk.push(i++);\n        else {\n            int cur  = height[stk.top()];\n            stk.pop();\n            int len = i - stk.top() - 1;\n            int h = min(stk.top(), height[i]);\n            res += (h - cur) * len;\n        }\n    }\n\n    return res;\n}\n```\n\n## 总结 \n其实Two Pointer与MonoStack有相似指出，只不过Two Pointers计算的是纵向的水量，MonoStack计算的是\n横向的水量。反正这个题，应该算是吃透了8. 快乐。\n","tags":["C++","Leetcode"]},{"title":"881_BoatsToSavePeople","url":"/2019/07/22/LeetCode-881-BoatsToSavePeople/","content":"\n# LeetCode 881 Boats To Save People\n\n## 题目\n\n> The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\n\n> Each boat carries at most 2 people at the same time, provided the sum of the weight of those \n> people is at most limit.\n\n> Return the minimum number of boats to carry every given person.  (It is guaranteed each person\n> can be carried by a boat.)\n\n这个还蛮简单的，完全可以类比成，2 Sum，取最接近的值，没啥好说的，直接上代码了。\n\n## Code\n\n```cpp\nint numRescueBoats(vector<int>& people, int limit)\n{\n    sort(begin(people), end(people));\n\n    int beg = 0;\n    int end = people.size()-1;\n    int count = 0;\n\n\n    while (beg <= end)\n    {\n        if (people[beg] + people[end] > limit)\n        {\n            end--;\n            count++;\n        }\n        else\n        {\n            beg++;\n            end--;\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Mutable关键字","url":"/2019/07/21/Mutable关键字/","content":"\n# 关于C++的mutable关键字\n\nC++的mutable关键字今天整理一下。\n\nC++的const概念为 不可以修改，const可用来修饰变量，指针，引用，类成员函数等，当const被用来修饰\n成员函数的时候，代表该成员函数不可以修改类内部的成员变量。\n\n```cpp\n\nclass dummy\n{\npublic:\n    int getX() const\n    {\n        // x = 10  compplie error\n        return x;\n    } \n\nprivate:\n    int x;\n}\n\n```\n\n> getX作为const成员函数，强行修改会造成编译错误.\n> 但是通过mutable关键字，我们可以对mutable修饰的成员变量进行修改。\n\n```cpp\nclass dummy_mutable\n{\npublic:\n    std::string get(std::string key) \n    {\n        if (key == last_key) \n        {\n            return last_value;\n        }\n\n        std::string value = {this->lookup(last_key)};\n\n        last_key_ = key;\n        last_value_ = value;\n    }\nprivate:\n    mutable std::string last_key_;\n    mutable std::string last_value_;\n}\n```\n\n在这个例子中我们可以看到，我们在const成员函数get()中修改了last_key_以及last_value_\n的值，这就是mutable的作用。\n\n\n\n","tags":["C++"]},{"title":"LeetCode 424_LongestRepeatingCharacterReplacement","url":"/2019/07/13/LeetCode-424-LongestRepeatingCharacterReplacement/","content":"\n# LeetCode 424 Longest RepeatingCharacterReplacement\n\n## 题目\n\n> Given a string s that consists of only uppercase English letters, you can perform at \n> most k operations on that string.In one operation, you can choose any character of the \n> string and change it to any other uppercase English character.Find the length of the longest\n> sub-string containing all repeating letters you can get after performing the above operations.\n\n## 题意\n\n本题的意思是，给定一个只含有小写字母的单词，最多可以进行K次替换，找到长度最长的相同字母字串。\n\n本题一开始看的时候还以为是dp = =，后来想起来我最近刷的全是Two Pointers类型… 所以就往Slide Window方向\n想，还是基本操作，一个指向beg，一个指向end…但是后来看了Discuss，这个解法真的惊到我了，属实优雅。\n\n用一个mp来记录slide window中经过的所有字母，但是这个里面只有两种字母，一个是数量最多的相同字母，我们用same\n表示，还有0-k个字母是替换成same字母的，如果此时刚好有k个字母被替换，那么替换字母量达到最大，此时应该有\nk + same == end - beg.一旦end - beg 大于 k + same,说明我们的slide window需要缩小，即beg++，这就是全部过程。\n\n## Code\n\n```cpp\nint characterReplacement(string s, int k)\n{\n    int beg = 0, end = 0;\n    int len = s.length();\n    int same = 0;\n    int mp[130];\n\n    memset(mp, 0, sizeof(mp));\n\n    while (end < len) {\n        same = max(same, ++mp[s[end++]]);\n        if (end - beg - same > k)\n            --mp[s[beg++]];\n    }\n    return end - beg;\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["算法"]},{"title":"LeetCode 992 SubarraysOfKDistincts","url":"/2019/07/12/LeetCode-992-SubarraysOfKDistincts/","content":"\n\n# LeetCode 992 SubarraysOfKDistincts \n\n## 题目\n\n> Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of \n> A good if the number of different integers in that subarray is exactly K.\n> (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\n> Return the number of good subarrays of A.\n\n本题的意思是说，在给定的数组中，有多少个子数组刚好含有K个数字。\n\n## 题解\n\n一开始想到的是用一个Slide Window，但是只是简单的用一个deq来做滑动窗口，有可能会错过一些情况。\n后来和室友讨论的方法是维护一个数组，以数组中的每个元素为起始元素来向后遍历，一直到最右端，\n即当前字数组中包含的数字数量为K位置，后面设置一个特殊标志为如INF等。但是这个样子其实复杂度\n较高，不具有可行性。\n\n后在Youtube上刷到了题解，这个题完全可以以高中时候的思路来做，原题为求刚好含有K个数字，我们改为，\n完整遍历一遍A数组，每次 += f(K) = 以当前字符结尾的子串至多含有K个数字。同时，使用f(k) - f(k-1)\n就可以得出题目的解。 \n\n还有一个要点是：我们计算至多含有K个数字其实有很多种解法，但是可以在遍历的时候，通过滑动窗口的两侧\n的差值+1，就是以当前字符结尾的字串数量.\n\n## Code\n\n```cpp\n\nint subarraysWithKDistinct(vector<int>& A, int k)\n{\n\tint n = A.size();\n\tint res;\n\n\tauto sub = [&A](int k) {\n\t\tint ans = 0;\n\t\tint i = 0;\n\t\tint mp[20005];\n\t\tmemset(mp, 0, sizeof(mp));\n\t\t//循环开始\n\t\tfor (int j = 0; j < A.size(); j++)\n\t\t{\n\t\t\tif (mp[A[j]]++ == 0)\n\t\t\t\t--k;\n\t\t\twhile (k < 0)\n\t\t\t\tif (--mp[A[i++]] == 0) ++k; //k为0时就将滑动窗口的左侧左移\n\t\t\tans += j - i + 1; \t//以当前滑动窗口为最右侧的字符串为end的字串的数量\n\t\t}\n\t\treturn ans;\n\t};\n\treturn sub(k) - sub(k-1);\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["算法"]}]