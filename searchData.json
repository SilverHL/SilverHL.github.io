[{"title":"python调用C提升性能记录","url":"/2020/04/03/python调用C提升性能记录/","content":"\n##Python通过调用C来提升性能的一次记录\n\n​\t\t昨天遇到的一个事，同事通过Python来处理其他家厂商的日志，将格式转换成内部日志格式，不是复杂的需求，但是遇到了性能瓶颈，单核大概8000qps，500w行的日志处理大概需要3min。申请了的是16核机器，考虑到多线程情况下的调度，单机10w的qps应该是有点勉强能达到的，而且实际测试的时候，虽然能达到，但是16核cpu基本都跑🈵️了。虽然机器只有这一个服务在跑，但是实际占用大量时间的还有磁盘IO等会阻塞的操作，因此想着要给优化一下，思路是通过火焰图分析代码耗费时间的部分，然后通过C来重写该部分的逻辑，并通过Python的ctypes包来调用C的接口。\n\n\n\n### PyFlame安装及生成火焰图&分析\n\n​\t\t首先是通过火焰图来进行性能的分析，因为之前用过标准库的CProfile来查看某个py脚本的性能，命令是`python -m cProfile -s tottime test_parse.py`，可惜代码实际是多进程来做的，cProfile会报错，具体原因没有深究。经过google选了[PyFlame](\"https://github.com/uber-archive/pyflame\")来生成火焰图，具体依赖的库包括autoconf, automake 等等，不再列举，CentOS下的编译安装可参照[这里](\"https://blog.csdn.net/qq_30549833/article/details/72955881\")。[官方文档](\"https://pyflame.readthedocs.io/en/latest/\")对于安装过程写的挺详细的，不再赘述。安装完PyFlame还需要安装一个[FlameGraph](\"https://github.com/brendangregg/FlameGraph\")，通过其中的flamegraph.pl来生成火焰图。\n\n​\t\t用法是，PyFlame会通过attach到具体的进程然后拿到进程调用链和耗费的时间，同时还支持设置采样的总时间以及每次采样的间隔时间，然后采样完成后把数据pipe到flamegraph.pl生成火焰图，可以在chrome中直接打开。\n\n> pyflame -s 10 -p 26788 | ../../FlameGraph/flamegraph.pl > A.svg\n\n（并未设置采样间隔 可通过-r进行设置\n\n\n\n### 通过火焰图进行分析 & 优化\n\n生成的图是这样的：\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/master/1.png)\n\n（一开始不会看火焰图有点尴尬 害 补充一点小知识\n\n> 经过Google，火焰图的颜色与耗费时常啥🐔8⃣️关系都🈚️。需要注意的是横向代码的长度<strong>代表代码执行耗费的时间</strong>，纵向往上的层级越多，越说明<strong>调用链越长</strong>strong>，也就越有可能<strong>占用CPU时间</strong>。\n\n​\t\t我们可以在图中看到，实际最花时间的应该是四个蓝色箭头所指的位置，可优化的也在这里。看了下代码，其中<strong>1号左侧</strong>的代码对应的是在IO磁盘操作，即在硬盘中读取日志出来，这个消耗实际上是不能避免的。1号操作对应的是将某一条日志通过正则提取出某些必要的信息，也就是说<strong>正则匹配</strong>消耗了一定时间，想来想去没有什么好的优化手段，因为日志格式是固定的，所以还是用<strong>split(\" \")</strong>来把正则替换掉（其实是有一些作用的哈哈哈哈哈哈哈哈哈）。\n\n​\t\t再来看2-4号操作，这几个其实都是一样的操作，把原日志中的UTC时间（格林尼治标准时间）转换成CST（东八区北京时间），经过线下与同事商量，去掉了后两个，因为他也没用到（手动狗头。经过这一番操作，火焰图变成了酱：\n\n![image-20200403181338126](https://raw.githubusercontent.com/SilverHL/image_repo/master/2.png)\n\n​\t\t也就是说，<strong>原来的1号</strong>（正则匹配）消耗的时间比较少，上图的1号，涉及到比较深层次的调用，应该是属于磁盘IO，也就是无法避免的消耗。而2号就是时间转换，需要将原日志的字符串转成datetime对象，然后进行时区的转换，在转回字符串。因为实际linux获取时间实际是需要系统调用的，因此还是很消耗时间的，所以这块用C来重写，以期提高性能。\n\n### Python调用C\n\n​\t\t经过一番Google，发现ctypes实际是比较好用的，写C就可以，然后编译成动态链接库，再在python中调用。不像Cython，需要写Python（8是很会写py），实际比python多的就是指定类型，在编译期就完成类型的推导，不像原生的python需要在运行期动态的推导类型，耗费时间过多，（后话，可能会研究下这方面）。\n\n​\t\t首先是用C完成时间转换的步骤，介绍几个API:\n\n  将当前的时区设置为东八区北京时区：\n\n> setenv(\"TZ\", \"GMT-8\", 1) \n\n将char *类型的时间字符串按照format格式转换到struct tm类型\n\n> char *strptime(const char *s, const char *format, struct tm *tm);\n\n将struct tm *类型的timeptr按照format格式转换到char *, maxsize指的需要填充的buffer的最大长度\n\n> size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)\n\n将struct tm *类型转换成unix时间戳\n\n> time_t timegm(struct tm *tm);\n\n将struct tm *类型转换成本地时区的unix时间戳（似乎不需要上面的setenv\n\n> time_t mktime(struct tm *timeptr)\n\n将time_t类型的unix时间戳转换成struct tm*\n\n> struct tm *localtime(const time_t *timer)\n\n\n\n上代码：\n\n```c\n#include <stdio.h>\n#include <sys/times.h>\n#include <time.h>\n#include <string.h>\n\nconst char *\nutc_to_cst(const char *utc_time)\n{\n   setenv(\"TZ\", \"GMT-8\", 1);        // set current timezone beijing\n   struct tm tmstr;\n   struct tm * tmlocal;\n   time_t tslastutc;\n   time_t tslastloc;\n   char cst_time[32];\n   memset(&tmstr, 0, sizeof(struct tm));\n   strptime(utc_time, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert argument to struct tm\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert struct tm to string, still\n\n   tslastutc = timegm(&tmstr);     // get UCT Unix time from argument string time  GMT\n   tslastloc = mktime(&tmstr);     // get local Unix time from argument string time\n   tslastloc += (tslastutc - tslastloc);    // wired operation, seems to reduce deviation\n   tmlocal = localtime (&tslastloc); \t// get local time in struct tm format\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", tmlocal); // convert local struct tm to string\n   return cst_time;\n}\n```\n\n​\t\t通过这个命令将代码编译成动态链接库，并通过python代码进行调用：\n\n> gcc -shared -Wl,-soname,utc_to_cst -o utc_to_cst.so -fPIC utc_to_cst.c\n\n​\t\tpython调用代码如下（其实也是通过指明符号名、变量和返回值类型）：\n\n```python\nfrom ctypes import *\n\ntime_convert = CDLL(\"./utc_to_cst.so\")\t# add dll\nin_arg = c_char_p(\"2018-02-19 00:00:00\") # specify in arg type (char *)\nu_to_c = time_convert.utc_to_cst\t# connect u_to_c with symbol utc_to_cst in .so file\nu_to_c.restype = c_char_p # specify return type in c (char *)\nprint(u_to_c(in_arg))\n\n\n```\n\n实际上到这里就٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎ了，但是应用到的时候出现了一个诡异的现象，他🐎的用完C的模块居然还更慢了！生成的火焰图如下：\n\n![image-20200403181450308](https://raw.githubusercontent.com/SilverHL/image_repo/master/3.png)\n\n​\t\t可以看到2号占用的时间比上一张图长了 = = 实际测试500w行处理完成的时间也有4min，耗费时间实际上花在了ctypes的\\_\\_init\\_\\_()方法上，然后就没有更深的调用链了。我就去实际的看了下ctypes的\\_\\_init\\_\\_到底做了个啥事，代码中有几行是这样的：\n\n```\nif handle is None:\n    self._handle = _dlopen(self._name, mode)\nelse:\n    self._handle = handle\n```\n\n​\t\thandle应该指的就是.so文件中的符号，即utc_to_cst, 代表我们调用的C代码中的处理方法，然后想到用的时候，把`time_convert = CDLL(\"./utc_to_cst.so\")`这行加在了循环，才导致有大量的时间花在了_dlopen()中，果断把这行移除循环，终于得到了满意的结果，火焰图如下：\n\n![image-20200403182202297](https://raw.githubusercontent.com/SilverHL/image_repo/master/4.png)\n\n经过实际测试，完成以上的优化过程后，单核qps可以达到5w左右，就算突发也可以很好的应付。"},{"title":"Leetcode-861-ReverseMatrixScore","url":"/2020/03/10/Leetcode-861-ReverseMatrixScore/","content":"\n# Leetcode 861 ReverseMatrixScore \n\n\n\n## 题目\n\n有一个二维矩阵 A 其中每个元素的值为 0 或 1 。\n\n移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。\n\n在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。\n\n返回尽可能高的分数。\n\n \n\n示例：\n\n> 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n> 输出：39\n> 解释：\n> 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]\n> 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n\n提示：\n\n1 <= A.length <= 20\n1 <= A[0].length <= 20\nA[i][j] 是 0 或 1\n\n\n\n## 题解\n\n这道题分类是贪心算法，首先需要明确，一个横向或纵向的数组翻转两次=》未翻转，所以每个横向或纵向的数组最多翻转一次。 因为最后需要求得最大值，所以每个数组的第0位一定要是1，有了第一个遍历。纵向遍历数组第0位，不为1的，将整个数组<strong>横向翻转</strong>。此时所有数组均<strong>不可以</strong>再横向翻转。由于求最大值，我们只需要求数组中1的数量，因此将sum初始化为<strong>row * (int)pow(2, line - 1)</strong>,而后面的纵向数组，我们只需要保证 <strong>每个纵向数组中1的数量大于0的数量</strong>,然后再通过1的数量可以求出此时的和。\n\n\n\n## Code\n\n```cpp\nint matrixScore(vector<vector<int>>& A)\n{\n    for (auto &vec : A) {\n        if (vec[0] == 0) {\n            for (auto &i : vec)\n                i ^= 1;\n        }\n    }\n\n    const int r = A.size();\n    const int l = A[0].size();\n\n    int sum = r * (int)pow(2, l-1);\n\n    for (int j = 1; j < l; j++) {\n        int one_n = 0;\n        int zero_n = 0;\n\n      \t// 这里可以只计算0或者1的数量\n        for (int i = 0; i < r; ++i) {\n            if (A[i][j] == 0) {\n                zero_n++;\n            } else {\n                one_n++;\n            }\n        }\n\n        if (one_n > zero_n) {\n            sum += one_n * (int)pow(2, l - j - 1);\n        } else {\n            sum += zero_n * (int)pow(2, l - j - 1);\n        }\n    }\n    return sum;\n}\n```\n\n","tags":["C++","算法","greedy"]},{"title":"Nginx ngx_module_t结构体","url":"/2020/03/09/Nginx-ngx-module-t结构体/","content":"\n# Nginx ngx_module_t 结构体\n\n断断续续的记录一些nginx学习的内容。\n\n\n\n```c\nstruct ngx_module_s {\n    ngx_uint_t            ctx_index;    // 当前模块在本类模块中的顺序  比如 过滤类模块 等等  \n    ngx_uint_t            index;        // 当前类模块在所有模块中的顺序 如 一个http模块在 http src loc模块中的顺序\n\n    ngx_uint_t            spare0;\n    ngx_uint_t            spare1;\n    ngx_uint_t            spare2;\n    ngx_uint_t            spare3;\n\n    ngx_uint_t            version;\n\n    void                 *ctx; // 指向当前这类模块的公共接口\n    ngx_command_t        *commands; // 指向这个模块对应的所有命令\n    ngx_uint_t            type; // 模块类型\n\n    /**\n     * 这7个方法在nginx的执行过程中扮演重要角色\n     */\n    ngx_int_t           (*init_master)(ngx_log_t *log);\n\n    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);\n\n    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);\n    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);\n    void                (*exit_thread)(ngx_cycle_t *cycle);\n    void                (*exit_process)(ngx_cycle_t *cycle);\n\n    void                (*exit_master)(ngx_cycle_t *cycle);\n\n    uintptr_t             spare_hook0;\n    uintptr_t             spare_hook1;\n    uintptr_t             spare_hook2;\n    uintptr_t             spare_hook3;\n    uintptr_t             spare_hook4;\n    uintptr_t             spare_hook5;\n    uintptr_t             spare_hook6;\n    uintptr_t             spare_hook7;\n};\n\n```\n\n\n\n\n\n","tags":["nginx"]},{"title":"Leetcode-729-MyCalendarI","url":"/2019/11/22/Leetcode-729-MyCalendarI/","content":"\n\n\nLeetcode 729  MyCalendar I\n\n## 题目\n\nImplement a `MyCalendar` class to store your events. A new event can be added if adding the event will not cause a double booking.\n\nYour class will have the method, `book(int start, int end)`. Formally, this represents a booking on the half open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.\n\nA *double booking* happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\n\nFor each call to the method `MyCalendar.book`, return `true` if the event can be added to the calendar successfully without causing a double booking. Otherwise, return `false` and do not add the event to the calendar.\n\nYour class will be called like this: `MyCalendar cal = new MyCalendar();``MyCalendar.book(start, end)`\n\n**Example 1:**\n\n```\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\nExplanation: \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n```\n\n\n\n## 题意\n\n这道题题意比较简单，给定一个MyCalendar类，有一个book方法，每次传一个start和一个end, 表示从`[start,end)`的日期能否预定（左闭右开区间），可预定的话就定上并返回`true`，否则返回`false`。这个题其实不难，通过一个vector来记录当前记录的所有预定，每次遍历当前所有的预定，看是否和之前的预定有冲突。两个不同的solution就是在遍历方式上有所不同。\n\n## Code 1\n\n假设当前调用为`book(s1, e1)`, 当前遍历所有的预定到了`[s2, e2)`, 我们一共会有以下几个可能的情况：\n\n![411574399768_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/411574399768_.pic.jpg)\n\n我们可以看到，左边的红线只要小于右边的蓝线，都会是有overlap的情况，那么我们可以归结一下，就是<font color=red>max(s1, s2)</font> < <font color=blue>min(e1, e2)</font>的话，就认为是有overlap的情况，代码如下：\n\n```\nclass MyCalendar {\nprivate:\n    vector<int> mp_;\npublic:\n    MyCalendar1() {\n\n    }\n\n    bool book(int start, int end) {\n        int n = mp_.size();\n        for (int i = 0; i < n; i += 2)\n            if (max(mp_[i], start) < min(mp_[i+1], end))\n                return false;\n        mp_.push_back(start);\n        mp_.push_back(end);\n        return true;\n    }\n};\n```\n\n这个代码的空间复杂度是O(N), 时间复杂度最差是O(N^2)。\n\n## Code 2\n\n刚刚说过，两个解法的不同其实就在于搜索已预定的所有序列的时候，<strong>Code 1</strong> 使用的是最朴素的遍历，我们这里将要使用的是二分查找。\n\n首先是两个C++的API:\n\n> map<Key,T,Compare,Allocator>::upper_bound(const Key& key)  获取当前map中第一个Key值小于等于key 的Key-Value pair。\n>\n> map<Key,T,Compare,Allocator>::lower_bound(const Key& key) 获取当前map中第一个Key值大于等于key 的Key-Value pair。\n>\n> 换言之，upper_bound和lower_bound返回的都是以<strong>参数key</strong>作为upper_bound或者lower_bound的第一个目标entry iterator。\n\n然后再来看这道题，假设book传进来的是`book(int start, end)`, 我们获得两个值，floor=upper_bound(start), ceiling=lower_bound(start), 右边是floor，左边是ceiling。我们先看左边的floor, 如果此时，`it->first < end`,说明有overlap。\n\n按理来说这个时候应该通过upper_bound(start)获得左边的ceiling, 但是因为我们可以确定当前map里没有出现overlap，所以我们可以把lower_bound减一，来获得当前的upper_bound, 然后来判断`it->second > start`就说明有overlap。\n\n![421574405947_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/421574405947_.pic.jpg)\n\n上代码：\n\n```\nclass MyCalendar\n{\nprivate:\n    map<int, int> mp;\npublic:\n\n    MyCalendar(){}\n    bool book(int start, int end)\n    {\n        map<int, int>::const_iterator it = mp.lower_bound(start);\n        if (it != mp.cend() && it->first < end)\n            return false;\n        if (it != mp.cend() && (--it)->second > start)\n            return false;\n        mp[start] = end;\n        return true;\n    }\n};\n```\n\n","tags":["C++","算法"]},{"title":"Leetcode-1040-MovingStonesUntilConsecutiveII","url":"/2019/11/19/Leetcode-1040-MovingStonesUntilConsecutiveII/","content":"\nLeetcode 1040 Moving Stones Until Consecutive II \n\n这道题…卡了还挺久的，今天看了一个解法挺好的，记录一下。\n\n## 题目\n\nOn an **infinite** number line, the position of the i-th stone is given by `stones[i]`. Call a stone an *endpoint stone* if it has the smallest or largest position.\n\nEach turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, `stones = [1,2,5]`, you **cannot** move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\n\nWhen the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: `answer = [minimum_moves, maximum_moves]`\n\n \n\n**Example 1:**\n\n```\nInput: [7,4,9]\nOutput: [1,2]\nExplanation: \nWe can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n```\n\n**Example 2:**\n\n```\nInput: [6,5,4,3,10]\nOutput: [2,3]\nWe can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n```\n\n**Example 3:**\n\n```\nInput: [100,101,104,102,103]\nOutput: [0,0]\n```\n\n \n\n**Note:**\n\n1. `3 <= stones.length <= 10^4`\n2. `1 <= stones[i] <= 10^9`\n3. `stones[i]` have distinct values.\n\n## 题意\n\n在一条无限长的线上给定n个数字代表位置，每次可以取一个endpoint，即首尾的点插入到中间的空位，唯一的限制就是每个endpoint不能再插入以后依然作为endpoint，一直到所有的数字都是连续的，我们不能再继续移动endpoint为止，题目需要我们返回移动的最少和最大次数。\n\n我们先来看max_steps, 我们可以将所有的数字从最左边或者最右边开始往中间插，每次插入到第一个空位，举个🌰， 数组`[1, 3, 5, 6, 8, 9]`，我们可以将所有的数字作如下移动：\n\n```\n[1, 3, 5, 6, 8, 9]\n[3, 4, 5, 6, 8, 9]\n[4, 5, 6, 7, 8, 9]\n```\n\n又或者这个数组`[1, 2, 3, 4, 5, 8]`,我们进行的操作如下：\n\n```\n[1, 2, 3, 4, 5, 8]\n[2, 3, 4, 5, 6, 8]\n[3, 4, 5, 6, 7, 8]\n```\n\n所以我们首先可以得出给定的数组中的空位一共有`s1=stones[n-1] - stones[0] + 1 - n`, 但是并不是所有的空位都可以插入数字，举个例子，`[1, 4, 6]`中，把1移到5以后，<strong>2-3</strong>就不能再继续插入数字了，即第一次移动石子的时候，移动以后和原本移动的石子相邻的石子，这两个石子之间的空位不能继续插入数字，即为`s2=min(stones[n-1] - stones[n-2] - 1, stones[1] - stones[0] - 1)`，那么我们的max_steps可以通过`s2-s1`得到，`max_steps=max(stones[n-2] - stones[n-2] + 2 - n, stones[n-1] - stones[1] + 2 - n)`。\n\n然后是最小值min_steps, 我们可以知道，当我们的得到最终结果的时候，一定是一排连续的数字，如果需要求最小的移动数，一定是和最后结果重合数最多的。所以我们用一个滑动窗口来记录当前范围内的所有数字，只要这个窗口大于n我们就计算当前数组和<strong>n个连续数字的数组</strong>的重合数，找最小的就是结果。但是这个题还有一个地方不一样，比如`[1, 2, 3, 4, 6]`, 这个时候我们不能把6移到5，而是把4移到5，然后把6移到4，所以开销（移动数量）为2。\n\n## Code\n\n```cpp\nvector<int> numMovesStonesII(vector<int>& stones)\n{\n    const int n = static_cast<int>(stones.size());\n    sort(begin(stones), end(stones));\n\n    int max_steps = std::max(stones[n-2] - stones[0] + 2 - n, stones[n-1] - stones[1] + 2 -n);\n\n    int min_steps = INT_MAX;\n    int i = 0;\n    int j = 0;\n    for (i = 0; i < n; ++i) {\n        while (j + 1 < n && stones[j+1] - stones[i] + 1 <= n)\n            j++;\n        int cost = n - (j - i + 1);\n        if (j - i + 1 == n-1 && stones[j] - stones[i] + 1 == n-1)\n            cost = 2;\n        min_steps = std::min(min_steps, cost);\n    }\n\n    return {min_steps, max_steps};\n}\n```\n\n","tags":["C++","Leetcode"]},{"title":"Leetcode-926-FlipStringToMonotoneIncreasing","url":"/2019/11/12/Leetcode-926-FlipStringToMonotoneIncreasing/","content":"\nLeetcode 926 Flip String To Monotone Increasing \n\n水一道Leetcode = = \n\n\n\n# 题目\n\n>A string of `'0'`s and `'1'`s is *monotone increasing* if it consists of some number of `'0'`s (possibly 0), followed by some number of `'1'`s (also possibly 0.)\n>\n>We are given a string `S` of `'0'`s and `'1'`s, and we may flip any `'0'` to a `'1'` or a `'1'` to a `'0'`.\n>\n>Return the minimum number of flips to make `S` monotone increasing.\n>\n> \n>\n>**Example 1:**\n>\n>```\n>Input: \"00110\"\n>Output: 1\n>Explanation: We flip the last digit to get 00111.\n>```\n>\n>**Example 2:**\n>\n>```\n>Input: \"010110\"\n>Output: 2\n>Explanation: We flip to get 011111, or alternatively 000111.\n>```\n>\n>**Example 3:**\n>\n>```\n>Input: \"00011000\"\n>Output: 2\n>Explanation: We flip to get 00000000.\n>```\n>\n> \n>\n>**Note:**\n>\n>1. `1 <= S.length <= 20000`\n>2. `S` only consists of `'0'` and `'1'` characters.\n\n# 题意\n\n这个题，题目为给定一个string，由0和1组成，需要判断最少flip多少次才能将这个字符串转变为单调递增的string，可以全为0或1，也可以0-i 全部为0， i+1-n全部为1。这个题一开始看到我是想到用dp的，但是没写出来…这个算是两个解法记录一下，然后第二个解法逐渐优化。\n\n# Code\n\n## 解法1\n\n用两个数组l & r，l[i]表示 从0 ～ i的1的数量，r[i]表示i ～ n的0的数量，两个相加，取最小的一种解法，也可以取两个边界情况，最后的值就是 min(l[i-1] + r[i], r[0], l[n-1]).\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<int> l(n+1, 0);\n    vector<int> r(n+1, 0);\n\n    l[0] = S[0] == '1';\n    for (int i = 1; i < n; ++i)\n        l[i] = l[i-1] + (S[i] == '1');\n\n    r[n-1] = S[n-1] == '0';\n    for (int i = n-2; i >= 0; --i)\n        r[i] = r[i+1] + (S[i] == '0');\n\n    int res = r[0];\n    for (int i = 1; i <= n; i++)\n        res = std::min(l[i-1] + r[i], res);\n    return res;\n}\n```\n\n## 解法2\n\n其实解法2和解法1还是很像的，但是是有一个状态转移方程，我们用一个数组dp\\[n+1\\]\\[2\\]来记录前面的状态。dp[i][0]是我们当前数字作为0，需要翻转的最小数量，我们不关心前面出现的0或者1，只关心当前数字，dp[i][1]则是当前数字作为1需要翻转的最小数量。\n假设我们走到index为i的数字，如果这个数字为0，那么 dp\\[i\\]\\[0\\]=dp[i-1][0]，也就是说，我们需要flip的数字数量与dp[i-1][0]是相同的，不需要再额外flip。如果此时数字为1，那么我们的dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1, 也就是说，我们可以把当前的i作为0和1的分界点，也就是<strong>接下来所有1中的第一个1</strong>,或者前面已经出现1，我们需要将这个0flip成为1。也就是+1。\n当我们走到为1的数字，同样index是i，那么dp[i][0] = dp[i-1][0] + 1,是指如果我们需要这个数字为0，那么需要前一个为0，然后+1次flip。dp[i][1] = min(dp[i-1][0], dp[i-1][1]), 这个同样是指我们将这个数字作为分界点或者继续当1，取最小值即可。\n归纳一下状态转移方程:\n> if s[i] == '0': \n> \tdp[i][0] = dp[i-1][0]\n> \tdp[i][1] = min(dp[i-1][0]m dp[i-1][1]) + 1\n> else if s[i] == '1':\n> \tdp[i][0] = dp[i-1][0] + 1\n> \tdp[i][1] = min(dp[i-1][0], dp[i-1][1])\n\n再精简一下，我们可以看到两个分支其实是比较相像的，所以可以简化为：\n> dp[i][0] = dp[i-1][0] + (s[i] == '1')\n> dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + (s[i] == '0')\n\n然后上代码：\n```cpp \nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<vector<int>> dp(n+1, vector<int>(2));\n    dp[0][0] = S[0] == '1';\n    dp[0][1] = S[1] == '0';\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = dp[i - 1][0] + (S[i] == '1');\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + (S[i] == '0');\n    }\n    return min(dp[n][0], dp[n][1]);\n}\n```\n\n## 解法3 \n\n解法3其实还挺取巧的，也是解法2的进一步优化，因为我们可以在解法2中看到，每一步的状态都只与上一步的状态有关，也就是说，我们完全可以把空间复杂度从O(N)优化到O(1)，不复杂，直接上代码:\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    int dp0 = S[0] == '1';\n    int dp1 = S[0] == '0';\n\n    for (int i = 1; i <= n; ++i) {\n        int tmp0 = dp0 + (S[i] == '1');\n        dp1 = min(dp0, dp1 + (S[i] == '0'));\n        dp0 = tmp0;\n    }\n    return min(dp0, dp1);\n}\n```\n\n","tags":["C++","Leetcode","dp"]},{"title":"Leetcode-39-CombinationSum","url":"/2019/11/07/Leetcode-39-CombinationSum/","content":"\n# Leetcode 39 Combination Sum\n\n## 题目\n\n> Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.\n>\n> The **same** repeated number may be chosen from `candidates` unlimited number of times.\n>\n> **Note:**\n>\n> - All numbers (including `target`) will be positive integers.\n> - The solution set must not contain duplicate combinations.\n>\n> **Example 1:**\n>\n> ```\n> Input: candidates = [2,3,6,7], target = 7,\n> A solution set is:\n> [\n>   [7],\n>   [2,2,3]\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: candidates = [2,3,5], target = 8,\n> A solution set is:\n> [\n>   [2,2,2,2],\n>   [2,3,3],\n>   [3,5]\n> ]\n> ```\n\n## 题意 \n\n这个题其实很久之前刷过，但是今天又刷到了…就又做了一遍，因为之前是看的答案，现在刷了一遍，有一丢丢不同，但是性能反而提高了很多。\n\n这道题给定一个数组和一个target，求数组中的哪些数字之和是target，数字<strong>可以重复使用</strong>，所以思路当然是用dfs啦，原来的思路是把target传到dfs里面，每次到一个 新数字就把target减去这个数字，我这次直接把target和sum一起传了进去然后进行比较，不知道为什么性能会高很多。。。\n\n## Code\n\n```cpp\nvoid dfs(vector<int>& candidates, int sum, int index, int target, vector<vector<int>>& res, vector<int> tmp)\n{\n    if (sum == target) {\n        res.push_back(tmp);\n        return;\n    }\n    if (sum > target)\n        return;\n    int n = candidates.size();\n    for (int i = index; i < n; ++i) {\n        tmp.push_back(candidates[i]);\n        dfs(candidates, sum + candidates[i], i, target, res, tmp);\n        tmp.pop_back();\n    }\n}\n\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target)\n{\n    vector<vector<int>> res;\n    vector<int> tmp;\n    int n = candidates.size();\n    dfs(candidates, 0, 0, target, res, tmp);\n    return res;\n}\n```\n\n大概就是这个思路，如果加到了target，那就把tmp压到res里面，否则就根据大小判断继续dfs or return。\n\n> 但是！！！\n\n我发现了一个性能好强的思路，比我这个高到不知道哪里去了，大概意思是，用一个和给定的数组相同大小的数组来记录当前哪个index被加入到了sum里面去，如果sum没超，就继续遍历给定的数组，超了就把当前这个index所有的数字给清空，如果sum刚好等于target，那么就把新数组中所有index对应的数组写入到结果中。\n\n## Code 2 \n\n```cpp\nvector<vector<int>> combinationSum(const vector<int>& n, int target) {\n    vector<int> factor(n.size());\n    vector<vector<int>> res;\n    int sum = 0;\n\n    do {\n        for (int i = 0; i < n.size(); i++) {\n            if (sum + n[i] <= target) {\n                sum += n[i];\n                factor[i] += 1;\n                break;\n            }\n            sum -= n[i] * factor[i];\n            factor[i] = 0;\n        }\n        if (sum == target) {\n            vector<int> tmp;\n            for (int i = 0; i < factor.size(); i++) {\n                for (int j = 0; j < factor[i]; j++)\n                    tmp.push_back(n[i]);\n            }\n            res.push_back(move(tmp));\n        }\n    } while (sum > 0);\n    return res;\n}\n```\n\n","tags":["C++","算法"]},{"title":"Leetcode-169-MajorityElement","url":"/2019/10/16/Leetcode-169-MajorityElement/","content":"\n# Leetcode 169 Majority Element\n\n\n\n一道挺经典的题，记录下 =  = \n\n## 题目\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n## 题意\n\n这道题意思是说，给定一个数组，长度为n，其中某个数字出现的频率大于n/2,求这个数字，这个题我一开始打算用brute force,直接排序取中位数，一定是这个重复率最高的数字，因为重复超过n/2了嘛。但是提交以后…效率超过了4%的代码哈哈哈哈哈哈哈哈哈，所以又在网上找了一个效率很高的写法。\n\n这个数字出现频率超过其它所有数字，那我们就遍历这个数组，给定一个tmp = nums[0]，遍历数组，下一个数字如果和当前数字相同， 就cnt++，否则cnt-- ,一旦cnt == 0,我们就把tmp覆盖成下一个数字，因为出现频率够高，最后tmp一定就是结果。\n\n## Code\n\n```cpp\nint tmp, cnt = 0, n = nums.size();\n\n    for (int i = 0; i < n; ++i) {\n        if (cnt == 0)\n            tmp = nums[i];\n\n        if (nums[i] == tmp)\n            cnt++;\n        else\n            cnt--;\n    }\n    return tmp;\n```\n\n","tags":["C++"]},{"title":"nginx编译笔记","url":"/2019/10/07/nginx编译笔记/","content":"\n> 最近要开始学习Nginx了，记录下编译的过程\n\n\n\n# 环境准备\n\n先安装了一个虚拟机，VMWare Fusion 11.5 Pro，然后搞了一个Cent OS iso镜像，第一次安装的时候选错了，选成极简版的了，安装也没有GNome桌面 = = ，重新安了一下以后，调整了IPV4，可以正常上网了。\n\n根据书中讲的折腾出来的configure参数。\n\n```\n./configure --with-openssl=/root/openssl-1.0.2f --with-libatomic --with-zlib=/root/zlib-1.2.11 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_stub_status_module --with-google_perftools_module --with-debug --with-pcre=/root/pcre-8.43 --add-module=/root/nginx/test_module/\n```\n\n主要是需要手动下载prce，openssl,以及zlib的源码，下好以后直接交叉编译，然后make -j4 && make install 大法 目前已经编译好了。\n\n# 启动 & 关闭Nginx\n\n最简单的启动方式，可以通过/usr/local/nginx/sbin/nginx 进行启动，使用默认设置，还可以指定conf以及指定指定pid写入的文件路径等等。\n\n关闭的话可以使用/usr/local/nginx/sbin/nginx -s stop/quit两种。\n\n\n\n# 使用自己的第三方插件\n\n","tags":["nginx"]},{"title":"Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays","url":"/2019/10/05/Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays/","content":"\n# Leetcode 1031 Maxmium Sum of Two Non-overlapping Subarrays\n\n\n\n## 题目\n\nGiven an array `A` of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths `L` and `M`.  (For clarification, the `L`-length subarray could occur before or after the `M`-length subarray.)\n\nFormally, return the largest `V` for which `V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])` and either:\n\n- `0 <= i < i + L - 1 < j < j + M - 1 < A.length`, **or**\n- `0 <= j < j + M - 1 < i < i + L - 1 < A.length`.\n\n**Example 1:**\n\n```\nInput: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n```\n\n**Example 2:**\n\n```\nInput: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n```\n\n**Example 3:**\n\n```\nInput: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.\n```\n\n**Note:**\n\n1. `L >= 1`\n2. `M >= 1`\n3. `L + M <= A.length <= 1000`\n4. `0 <= A[i] <= 1000`\n\n\n\n## 题意\n\n好久没刷题了，看到这个题一点头绪也没有，特此记录一下，<strong>以后涉及到这种求子数组最大和的题目，优先使用前缀和</strong>。\n\n这道题翻译下，给定一个数组，以及两个整数L&M，返回两个字数组之和，要求为最大值，且两个字数组的长度分别为L M。所以这个题我们需要遍历两次，首先是用一个数组记录该数组的前缀和，然后通过动态规划来求的需要的值。\n\n如何进行动态规划？我们需要两个变量max_l & max_m, 分别表示两个字数组各自的最大和，然后此时会有两种情况，一种是L在左，M在右，另一种相反。假设此时遍历到index为i的数字，我们的返回值可能会有两种，一种为情况1，另一种为情况2，如图所示（暂时无图 = = ），我们只需要算出最大值，然后赋值给result就可以了。\n\n但是算出最大值之前我们是需要更新当前的max_l & max_m，至于更新的范围，比如我们需要更新max_l, 此时我们以前i - M个数中最大的长度为L的子序列之和为max_l，所以max_l = max(max_l, pre_sum[i - M] - pre_sum[i - L - M]),max_m也是相同的方法来更新。\n\n## Code\n\n```cpp\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M)\n{\n    int n = A.size();\n    vector<int>& pre_sum = A;\n\n    for (int i = 1; i < n; ++i) {\n        pre_sum[i] = pre_sum[i-1] + A[i];\n    }\n\n    int res = pre_sum[L + M - 1];\n    int max_l = pre_sum[l-1];\n    int max_m = pre_sum[m-1];\n    for (int i = L + M; i < n; ++i) {\n        max_l = max(max_l, pre_sum[i - M] - pre_sum[i - M - L]);\n        max_m = max(max_m, pre_sum[i - L] - pre_sum[i - M - L]);\n        res = max(res, max(max_l + pre_sum[i] - pre_sum[i-M], max_m + pre_sum[i] - pre_sum[i-L]));\n    }\n\n    return res;\n}\n```\n\n","tags":["C++"]},{"title":"Leetcode-1074-NumbersToSubmatricesThatSumToTarget","url":"/2019/09/17/Leetcode-1074-NumbersToSubmatricesThatSumToTarget/","content":"\nLeetcode 1074 Numbers To Submatrices That Sum To Target\n\n一道Leetcode Hard 级别的题目 ，用了一晚来理解，特此记录。\n\n# 题目\n\n> Given a `matrix`, and a `target`, return the number of non-empty submatrices that sum to target.\n>\n> A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.\n>\n> Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.\n>\n>  \n>\n> **Example 1:**\n>\n> ```\n> Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n> Output: 4\n> Explanation: The four 1x1 submatrices that only contain 0.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: matrix = [[1,-1],[-1,1]], target = 0\n> Output: 5\n> Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n> ```\n\n# 题解\n\n这道题意思是说，给定一个矩阵matrix，以及一个target，为int类型，需要你求出所有的submatrix中和为target的数量，这个题乍一看会很复杂，用最简单的brute force是可以求出来的，复杂度为O(N^4)m，这个复杂度其实还挺难接受的 = = ，所以我们有了如下解法：\n\n我们先求prefixSum，可以按行也可以按照列，我采用的方法是按行求，然后我们再固定一个l和一个r指针，用来表示submatrix的左右两边，另通过一个k来从上而下的遍历整列，求得一个sum，将这个sum记录在我们的unordered_map中，并且，我们通过sum - target就可以得到以k为底线，submatrix的sum为target的数量。因为这个sum其实本质上也是一个从上至下叠加的和，所以我们减去target得到的值，其实是一个上限的数量，刚好与k，以及l和r围成了一个submatrix。\n\n\n\n# Code \n\n```cpp\nint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target)\n{\n    int n = matrix.size(), m = matrix[0].size();\n    int ans = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 1; j < m; j++)\n            matrix[i][j] += matrix[i][j - 1];\n\n    for (int l = 0; l < m; l++)\n        for (int r = l; r < m; r++) {\n            unordered_map<int, int> vis;\n            vis[0] = 1;\n            int tot = 0;\n            for (int k = 0; k < n; k++) {\n                if (l == 0) {\n                    tot += matrix[k][r];\n                } else {\n                    tot += matrix[k][r] - matrix[k][l - 1];\n                }\n                if (vis.find(tot - target) != vis.end())\n                    ans += vis[tot - target];\n                vis[tot]++;\n            }\n        }\n    return ans;\n}\n```","tags":["C++","Leetcode"]},{"title":"Leetcode-1122-RelativeSortArray","url":"/2019/09/04/Leetcode-1122-RelativeSortArray/","content":"\nLeetcode 1122 Relative Sort Array\n\n这个题虽然是easy级别的题目，但是这个解法挺高明的，而且在Leetcode上时间和空间都超过了100%的提交，特此记录下。\n\n# 题目\n\n> Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n>\n> Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`.  Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.\n\n# 题解\n\n给定两个数组arr1以及arr2，其中arr2的数字是distinct的，数字1的会有重复，需要我们将arr1中的数字sort成arr2中的顺序，而且对于arr2中不存在的数字，需要将其按升序排列。\n\n举个🌰：\n\n```\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]\n```\n\n本题中的解法使用的是：通过一个自定义sort()函数的第三个参数，即一个function/functor，来对arr1进行sort，因为arr2中的变量是不会重复的，我们将arr2中的变量的index作为排序的依据。即：对于arr1以及arr2中存在的数字，排序的依据是arr2中变量的index，对于arr1中存在，arr2中不存在的数字，我们根据其本身大小进行排序。如果arr1中两个数字，第一个在arr2中存在，第二个不存在，那么第一个应该排在第二个前面，否则就是后面。直接上代码了。\n\n# Code\n\n```cpp\n#include <vector>\n\nusing std::vector;\n\nvector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2)\n{\n    int max = 0;\n    for (auto i : arr2)\n        if (i > max)\n            max = i;\n\n    vector<int> order(max+1, -1);\n\n    int n = arr2.size();\n    for (int i = 0; i < n; i++)\n        order[arr2[i]] = i;\n\n    n = (int)order.size();\n    auto cmp = [&order, &n](const int a, const int b) -> bool\n    {\n        bool contain_a = false, contain_b = false;\n        if (a < n && order[a] != -1)\n            contain_a = true;\n        if (b < n && order[b] != -1)\n            contain_b = true;\n\n        if (contain_a && contain_b)\n            return order[a] < order[b];\n        else if (!contain_a && !contain_b)\n            return a < b;\n        else if (contain_a)\n            return true;\n        else\n            return false;\n    };\n\n    sort(arr1.begin(), arr1.end(), cmp);\n    return arr1;\n}\n```\n\n\n\n-------\n\n又水了一道题，快乐;D","tags":["C++","Leetcode"]},{"title":"Leetcode-845-LongestMountainInArray","url":"/2019/08/24/Leetcode-845-LongestMountainInArray/","content":"\nLeetcode 845 LongestMountainInArray\n\n# 题意\n\nLet's call any (contiguous) subarray B (of A) a *mountain* if the following properties hold:\n\n- `B.length >= 3`\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\n\n(Note that B could be any subarray of A, including the entire array A.)\n\nGiven an array `A` of integers, return the length of the longest *mountain*. \n\nReturn `0` if there is no mountain.\n\n#First Version\n\n## 题解\n\n这个题定义了一种Mountain,即当前subarray的数字先递增后递减，求最长的Mountain子序列的长度。这个题我们可以用一个up和down数组来存储遍历的值，up[i]表示数组中第i个位置的值是当前递增序列的第几个，down的意思也是,down[i]表示数组的第i个值是当前递减序列的第几个（从n-2开始），然后遍历两个数组，当up[i]和down[i]同时为正的时候，通过up[i] + down[i] + 1就可以得出山峰的length.\n\n## Code\n\n```cpp\nint longestMountain(vector<int>& A)\n{\n    if (A.size() == 0)\n        return 0;\n\n    int n = A.size();\n    int len = INT_MIN;\n    vector<int> up(n, 0);\n    vector<int> down(n, 0);\n\n    for (int i = n-2; i >= 0; --i)\n        if (A[i] > A[i+1])\n            down[i] = down[i+1] + 1;\n\n    for (int i = 1; i < n; i++)\n    {\n        if (A[i] > A[i-1])\n            up[i] = up[i-1] + 1;\n\n        if (up[i] > 0 && down[i] > 0)\n            len = max(len, down[i] + up[i] + 1);\n    }\n    return len;\n}\n```\n\n-------\n\n# Anthor Version\n\n\n\n","tags":["C++"],"categories":["算法"]},{"title":"SlideWindow模板","url":"/2019/08/24/SlideWindow模板/","content":"\n# Slide Window模板\n\nSlideWindow类型的题刷了很多了，总结一个模板出来\n\n首先，用两个指针l,r表示左右边界，l = 0, r = 0。通过这个l r来表示一个<strong>左开右闭区间</strong>, 即[l, r)。\n\n然后在一个循环中遍历整个数组，终结条件为 r == array.size(), 每次循环做的第一件事是, sum += array[r++],然后对sum的值进行判断，如果没有达到需要的condition就continue，否则进行判断，但是这边一个容易被忽略过去的地方，即l到r的范围中，如果r-1位目标值，其中，[l,r-1]区间中有可能还有我们需要的结果，所以我们再来将[l,r-1]区间中的值进行遍历。（这步可以理解为，以数组中每一个值作为subarray的最后一个值，判断当前subarray是否符合需求)\n\n最后一个容易忽略的地方，当循环结束后，我们仍有[l,r-1]区间的值未遍历，其中有可能出现我们需要的结果,所以最后一个扫尾，把这段值处理下就可以了。\n\n\n\n## code\n\n```cpp\ntemplate <typename T>\nint SlideWindow(vector<T>& array, T target)\n{\n  if (array.size() == 0)\n    return;\n  \n  int l = 0;\n  int r = 0;\n \tint sum = array[0];\n  int ans = 0;\n  \n  //左开右闭区间，求长度可直接通过 r - l 得到\n  while (r < array.size())\n  {\n    sum += array[r++];\n    \n    if (sum < target)\n      continue;\n    else if (sum == target)\n    \tans++;\n   \telse\n    {\n      while (sum > target && l < r)\n      {\n        sum -= array[l++];\n        if (sum == target)\n          ans++;\n      }\n    }\n  }\n  \n  // 扫尾\n  while (sum > target && l < r)\n  {\n    sum -= array[l++];\n    if (sum == target)\n\t\t\tans++;\n  }\n  \n  return ans;\n}\n```\n\n","tags":["C++"],"categories":["算法"]},{"title":"Leetcode-234-PalindromeLinkedList","url":"/2019/08/18/Leetcode-234-PalindromeLinkedList/","content":"\nLeetcode 234 Palindrome Linked List\n\n刷道水题  = = \n\n我也不知道为啥这题的通过率比hard的级别的通过率都低…我寻思可能是这个边界处理比较复杂？直接看题8.\n\n\n\n# 题目\n\nGiven a singly linked list, determine if it is a palindrome.\n\n**Example 1:**\n\n```\nInput: 1->2\nOutput: false\n```\n\n**Example 2:**\n\n```\nInput: 1->2->2->1\nOutput: true\n```\n\n**Follow up:**\nCould you do it in O(n) time and O(1) space?\n\n# 题意\n\n其实就是最基本的单链表问题，问你给定的链表是否是一个回文链表，我寻思这个题其实一开始在刷牛客的链表题的时候就有过了。基本思路还是很清晰，找到链表的中间节点，然后将链表后半部分倒转，从两边的header分别遍历，最后看经过的路上的值是否一致就可以了。\n\n还有就是，我们没必要关心这个链表的长度是奇数或者偶数，因为即使分开两个链表长度相差1，我们只需要遍历前面相同的就可以了。\n\n最主要的地方还是，一开始找中点的时候，需要一个快慢指针，当快指针的next以及next->next有一个为空时，我们便认为到达了slow指针到达了中点，因为没法继续往下走了。然后是reverse list基本操作，但不要忘记将slow指针的next置为nullptr(C++11 不要像下面的代码一样写NULL).\n\n\n\n# Code\n\n```cpp\nbool isPalindrome(ListNode *head) {\n    if (head == NULL || head->next == NULL)\n        return true;\n\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    /* find middle point */\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    /* reverse half the list */\n    ListNode *cur = slow->next;\n    ListNode *next = cur->next;\n    ListNode *tmp = NULL;\n    cur->next = NULL;\n\n    /* break the list */\n    slow->next = NULL;\n\n    while (next != NULL) {\n        tmp = next->next;\n        next->next = cur;\n        cur = next;\n        next = tmp;\n    }\n\n    /* It doesn't matter the length of the list is odd or even,\n     * because these two pointers will come to an end */\n    while (head && cur) {\n        if (head->val != cur->val)\n            return false;\n        head = head->next;\n        cur = cur->next;\n    }\n\n    return true;\n}\n```\n\n\n\nDone. \n\n今日份的水题。","tags":["C++","Leetcode"]},{"title":"右值引用","url":"/2019/08/13/右值引用/","content":"\n\n> 很久之前看的左值与右值引用这类的东西，但是现在已经记不清楚概念，所以重新写篇博客来记录整理一下。\n\n---------------------------------\n\n# 左值与右值\n\n左值与右值在C语言中就有出现，<strong>\"lvalue\"</strong>与<strong>\"rvalue\"</strong>，字面上l和r为left和right，其实我更愿意把它们理解location与read，一个是在内存中有明确的地址，有一个属于自己的\"名分\"，另一个则是只能被read （literally）， 所以两个的区别其实已经一目了然。在代码中表现出来则是这个样子。\n\n```cpp\nint i = 0; // i 是左值，在栈上有地址，0是右值\n\nint dummy(20);\nint mummy(30);\n\nint foo = dummy;  \t//foo是左值\nfoo = dummy * mummy; // dummy * mummy是右值\n```\n\n在判断一个值是左值还是右值时，我们只需要考虑，这个值是否<strong>真实存在</strong>。如果作为一个函数的返回值，这个值在内存中其实并不存在，所以是右值。\n\n\n# 左值引用与右值引用\n\n这两个也很好理解，顾名思义，左值引用就是对左值的引用，用&表示，右值引用则是对右值的引用，通过&&来表示。\n\n```cpp\nint foo = 50;\nint app = 60;\n\nint &dummy = foo; // dummy是左值引用\nint &&rdummy = 30; // 30是右值 rdummy是右值引用\n\nconst int &ra = a; // const 左值引用\nconst int &&rra = 30; // const 右值引用\n\n// 一种特殊情况 \nconst int &ra = 30;  // const 左值引用绑定在一个右值上，因为这个值不能修改。\n```\n\n右值引用只能绑定在右值上，所以资源要么是立刻被销毁，或者只是一个字面常量，这就意味着对右值进行引用后可以接管这个右值的所有并随意修改，而不用担心会造成什么奇怪的影响。可以说是一个很方便的特性了。\n\n# 引用的值类型与引用叠加\n\n## 值类型\n\n我们先来看左值引用与右值引用本身是左值还是右值呢？\n\n```cpp\nint foo(40);\n\nint &lfoo = foo;\nint &dummy = lfoo;  \t//将一个左值引用作为右值赋值给dummy\n\nint &du = ++foo;  \t//将前置自增的++返回的左值作为右值赋值给du\n```\n\n我们可以看到，左值或者左值引用都可以作为右值赋值给别的变量，更仔细的说，一个左值，作为一个变量被保存下来，那么它就是一个左值，如果只是被当成一个右值用来赋值，那么生命周期与一个右值一样短暂。\n\n同样的，一个右值被返回后被存储在一个变量中，那就应该被当成一个左值来对待，否则就是一个右值。\n\n## 引用叠加\n\n```cpp\n\ntypedef int& intR;\ntypedef intR& intRR;\n\nint main()\n{\n\tint dummy(10);\n\tintR i = dummy;  \n\tintRR rri = i;\n}\n\n```\n\n在这里面，intR其实是一个int &, 但是intRR 其实应该是int& &,表示的是对一个int类型引用的引用，这个其实就是C++的引用叠加，有如下规则。\n\n```cpp\nType& & = Type&;\nType& && = Type&;\nType&& & = Type&;\nType&& && = Type&&;\n```\n\n这就是C++引用的叠加。有点像0与1求&，只要有左值引用那么最后叠加以后一定会是一个左值。\n\n#   右值引用使用场景\n\n所谓的右值引用可以应用在什么地方呢？\n\n## move语义\n\n先来看一段代码。\t\n\n```cpp\n\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n}\n\n```\n\n但是实际应用的时候会发现，简单的几段代码调用的函数分别有：\n\n> Trivial Constructor\n> explicit Constructor\n> operator =\n> Destructor\n> Destructor\n\n本次的调用过程分别有：首先调用Trivial Constructor，对dummy1进行construct，然后进入到get(),调用explicit Constructor对get()中的dummy进行consturct。返回一个dummy后，通过operator=()重载的=预算符赋值给dummy1，代码执行完以后，分别为dummy和dummy1调用destructor。\n\n\n\n在operatro=中，我们是把dummy中的指针取出来然后重新构造，需要重新调用new和Inner的delete，而且我们还可以注意到，get()返回的是一个右值，我们完全可以为operator=和copy constructor重新定制一个右值版本，分别称为move assignment和move constructor.\n\n```cpp\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\n    Dummy(Dummy&& dummy) : inner_(dummy.inner_)\n    {\n        dummy.inner_ = nullptr;\n        cout << \"move Construct \" << endl;\n    }\n\n    Dummy& operator=(Dummy&& dummy)\n    {\n        Inner *tmp = dummy.inner_;\n        dummy.inner_ = inner_;\n        inner_ = tmp;\n        tmp = nullptr;\n        cout << \"move assignment\" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n    return 0;\n}\n```\n\n这段代码的运行结果如下：\n\n> Trivial Constructor\n> explicit Constructor\n> move assignment\n> Destructor\n> Destructor\n\n通过move assignment，我们可以将原来的copy assignment中的一次new & delete给消除掉来提升性能。\n\n本质上来说，我们做了一次浅拷贝来节省性能，而dummy变成了一个dangling pointer, 所以给它赋值为nullptr.\n\n## 完美转发(perfect farward)\n\n假如说我们有很多种类型的class，而且有的可能会是左值有的会是右值，我们需要通过一个函数来进行转发。\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(t);\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\n\n\n但是得到的结果却和我们想象的完全不一样，得到的结果如下：\n\n```cpp\nexplicit Constructor\nin forward\ncopy Constructor\nin func\nDestructor\nDestructor\n```\n\n通过结果我们可以看出，在调用func的时候，我们以get()返回的右值传进去，按照引用叠加的原理来说，应该给func的也是一个右值，但是实际上根据调用的结果来看，传进去的t是以左值引用的方式过去的，而不是以右值引用的move Constructor版本。具体的原因是因为我们传给func的值其实已经被确确实实的存储在了内存中，所以最后给func()的应该是一个左值引用，通过和&&引用叠加一个真正得到了一个左值引用，所以调用了copy Constructor.\n\n那我们如果想要完成的以它本身的状态来传递的话，就应该以forward<T>()来进行<strong>完美转发</strong>,从而保持T本身的状态，代码如下。\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(std::forward<T>(t));\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\n这样得到的结果是：\n\n> explicit Constructor\n> in forward\n> move Construct\n> in func\n> Destructor\n> Destructor\n\n我们可以看到，此时传进func的结果被完整的保留了右值的身份。通过完美转发来达到我们需要的效果。如果我们把输入forward的类型改为左值:\n\n```cpp\nint main()\n{\n  Dummy du = get();\n  forward(du);\n}\n```\n\n通过这个输入得到的结果是：\n\n> Trivial Constructor\n> in forward\n> copy Constructor\n> in func\n> Destructor\n> Destructor\n\n完美的得到了我们需要的结果。\n\n\n\n\n\n\n\n\n\n","tags":["C++"]},{"title":"弱回调","url":"/2019/08/11/弱回调/","content":"# 弱回调技术\n\n> 最近在拜读陈硕老师的《Linux多线程服务器端编程》，从第一章开始就觉得自己菜 = =，因为书中涉及的知识是我之前仅仅了解了皮毛，甚至是仅有耳闻的内容。所以这本书读起来很吃力，而且需要反复的去品味其中运用的技术。\n\n从第一章来看，主要讲的shared_ptr与weak_ptr的运用，其实大学的时候还有去分析过shared_ptr与weak_ptr的用法，但终归并没有实际去使用这两个推动了C++现代化的工具。\n\n## shared_ptr 与 weak_ptr简介\n\n这两个工具基本上可以说是配套使用的，举个🌰，shared_ptr最大的特点是引用计数，对同一个对象的多次引用，其实质只是在 内部的计数器+1而已，但是如果遇到两个对象相互引用，就会形成死锁。此时就需要weak_ptr来打破僵局，weak_ptr引用的 对象，不会造成shared_ptr内部的计数器+1，可以理解为弱引用。但是本书中主要使用weak_ptr的地方多在于试探，看当前 的对象是否能从weak_ptr提升为shared_ptr,以此来保证对象并未被销毁。 \n## 实例\n\n本书的代码其实是一点一点改进的，我就直接贴个最终版，然后一点一点分析好了=3=\n\n```cpp\n//\n// Created by neojxwang(王靖煊) on 2019-08-08.\n//\n\n#include <vector>\n#include <string>\n\nusing std::vector;\nusing std::string;\n\nclass Stock\n{\npublic:\n\n    Stock() {}\n    Stock(string key) : key_(key) {}\n\n    string key()\n    {\n        return key_;\n    }\nprivate:\n    std::string key_;\n\n};\n\nclass StockFactory\n{\npublic:\n    shared_ptr<Stock> get(std::string key)\n    {\n        shared_ptr<Stock> sPtr;\n\n        pthread_mutex_lock(&mutex_);\n        weak_ptr<Stock>& wPtr = mp[key];\n        sPtr = wPtr.lock();\n        if (!sPtr) {\n            sPtr.reset(new Stock(key), std::bind(&StockFactory::delete, weak_ptr<StockFactory>(enable_shared_from_this()), _1));\n            wPtr = sPtr;\n        }\n        pthread_mutex_unlock(&mutex_);\n        return sPtr;\n    }\n\nprivate:\n    pthread_mutex_t mutex_;\n    std::map<std::string, std::weak_ptr<Stock>> mp;\n\n    void delete(weak_ptr<Stock> wPtr, Stock *stock)\n    {\n        shared_ptr<StockFactory> factory(wPtr.lock());\n\n        if (factory)\n        {\n            factory->removeStock(stock);\n        }\n\n        delete stock;\n    }\n\n    void removeStock(Stock * stock)\n    {\n        if (stock)\n        {\n            pthread_mutex_lock(&mutex_);\n            mp.erase(stock->key());\n        }\n    }\n};\n\n\n``` \n\n假设有各个股票，每个股票有一个唯一代码key，我们唯一要做的就是通过这个key来取到股票的对象，但是获得这个对象在多进 程环境下其实是存在竞争的，假设如下情况，进程A刚刚通过get()方法获得了对应的股票对象，进程B被推上CPU，并对那个 股票对象进行了销毁操作，并切回进程A，那么此时，会出现coredump。\n\n所以我们最一开始的使用一个shared_ptr来存储map中的Stock对象，即<strong>std::map<std::string, std::shared_ptr<Stock>></strong> 但是这样虽然可以方便对象的生命周期管理，但是此时的shared_ptr<strong>不会被销毁</strong>,所以我们该用weak_ptr来对 map中的Stock进行管理，只有在真正进行操作的时候，才将weak_ptr提升成shared_ptr。\n\n但是这个样子其实还是会使得内存进行泄漏的，那个map的size其实是只增不减的，因为并没有将map中的元素进行erase， 即使这个元素没有被引用，使用的内存也不会减少，这其实就是变相的内存泄露。所以我们使用shared_ptr的定制内存销毁函数， 也就是使用std::bind()将shared_ptr的第二个元素绑定为一个函数，在这里bind了一个类内部函数，所以使用 std::bind(&StockFactory::delete, this, _1)作为shared_ptr.reset()的第二个参数。 \n> bind 用法可以见上篇文章\n\n但是这个时候我们又出现了新的问题，我们将this指针作为参数传给了函数，这就很有可能造成多进程环境下的竞态，一旦 这个类在进程A中被destroy，那么在另一个进程中调用this指针就会造成coredump，所以我们还是使用shared_ptr指针来管理this指针， 这就用到了enable_shared_from_this()方法，该方法可以返回get()成员函数指向的类本身，且是一个shared_ptr函数， 这就保证我们不会在这个类被销毁以后还能调用到this指针，更准确点，应该是我们会保证this被调用的时候，这个类的实例一定不会被销毁。 解决了this指针的问题，我们会发现，此时bind中绑定的StockFactory类实例的生命周期被延长了，我们此时可以通过 <strong>弱回调技术</strong>来解决这个问题。 \n> 所谓弱回调，顾名思义，我们对一个类实例的调用不会影响其本身的生命周期，只在需要的时候保证该类没有被销毁就可以。（我自己瞎说的\n\n最终版本的code就在上面。我们可以看到，这个enable_shared_from_this()方法产生的shared_ptr指针其实被放在了一个 weak_ptr指针中，这就保证this指针的类实例<strong>一定</strong>不会被意外的延长生命周期，而且在需要对this指针进行 操作时，我们可以通过对weak_ptr指针的lock()操作来确保类实例是存在的，这就是弱回调技术。 \n* 总结一下，运用的技术主要是通过weak_ptr来对对象进行弱引用，以保证不意外延长对象的生命周期，并在需要对象的时候通过lock()来提升级别，以保证在多进程环境中对象实例还活着（XD\n\n\n\n\n\n\n","tags":["C++"]},{"title":"Leetcode-567-PermutationStrings","url":"/2019/08/09/Leetcode-567-PermutationStrings/","content":"\n# Leetcode 567 PermutationString \n\n## 题干 \n\n> Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\n\n## 题意 \n\n其实这个题还是很简单的，给定两个string s1和s2,如果s2的某个子集中包含的字母与s1<strong>完全</strong>一样，那么返回true，否则返回false。可以用最普通的方法，用一个s1.length()长度的窗口来遍历s2,每次检查窗口内的字母是否与\ns1相同。但是这个题还有一个比较有意思的解法，反向思维，用一个map记录s1中所有的字母，每次--1，然后还是用一个s1.length()的窗口来遍历，知道可以让该map所有成员都为0。举个例子，假设s1 = \"ba\", s2 = \"acdeab\", 那么初始\nmap={-1, -1, 0, 0, ... , 0}, 然后以一个size为2的窗口遍历整个s2，一直到map中<strong>所有的元素</strong>都为0，就证明是存在的。\n\n## Code\n\n```cpp\nbool checkInclusion(const string &s1, const string &s2)\n{\n    const int n1 = s1.length(), n2 = s2.length();\n    if (n1 > n2)\n        return false;\n    vector<int> mp(27, 0);\n    int i = 0, j = n1;\n\n    for (const auto &c : s1)\n        --mp[c-'a'];\n\n    for (int i = 0; i < j; i++)\n        ++mp[s2[i]-'a'];\n\n    while (j < n2)\n    {\n        if (equal(mp.begin(), mp.end(), mp.rbegin()))\n            return true;\n\n        ++mp[s2[j++] - 'a'];\n        --mp[s2[i++] - 'a'];\n    }\n\n    return equal(mp.begin(), mp.end(), mp.rbegin());\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Leetcode-828-UniqueLetterString","url":"/2019/08/07/Leetcode-828-UniqueLetterString/","content":"\nLeetcode 828 UniqueLetterString\n\n# 题意 \n\n> A character is unique in string S if it occurs exactly once in it.\n> For example, in string S = \"LETTER\", the only unique characters are \"L\" and \"R\".\n> Let's define UNIQ(S) as the number of unique characters in string S.\n>For example, UNIQ(\"LETTER\") =  2.\n>Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.\n>If there are two or more equal substrings at different positions in S, we consider them different.\n>Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.\n\n题意其实很好理解，给定一个字符串S，其中仅出现一次的字符数量用UNIQ(S)表示，若S=\"LETTER\", 那么其中UNIQ(S)=2, 为\"L\"与\"R\"，这个题需要 求得的结果是，给定的S的所有字串的UNIQ()的值。\n\n# 题解\n\n我们可以换一个角度来思考这道题，以字符串\"XAXXAXXA\"为例，假设我们需要得出以第二个\"A\"作为unique char的所有子串数量，我们可以在左右加入() 来表示，那可能的左边字串有\"XA(XXA\"/\"XAX(XA\"/\"XAXX(A\",可能的右边字串有\"AXX)\"/\"AX)X\"/\"A)XX\",各有3种，3*3=9，所以我们可以遍历每个char， 分别求出以当前char为unique char的所有字串数量即为题解。\n\n# Code\n\n```cpp\n#define LL long long\n\nint uniqueLetterString(string S) {\n    const int mod = 1000000007;\n    int n = S.length();\n    LL ans = 0;\n    vector<int> last(26, -1);\n\n    vector<int> left(n, -1), right(n, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        left[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    last = vector<int> (26, n);\n    for (int i = n-1; i >= 0; i--)\n    {\n        right[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n       ans += (ans + (LL)(i - left[i]) * (right[i] - i)) % mod;\n    }\n\n    return ans;\n}\n\n```\n","tags":["C++","Leetcode"]},{"title":"bind","url":"/2019/07/24/bind/","content":"\n\n# C++ std::bind\n\n很久之前学习过bind，但是现在已经记不清楚了…重新学一哈。\n\nC++中应该有Lvalue，Rvalue，但是其实一共有五种来着…\n\nbind的主要作用应该是将方法与参数相绑定。\n\n其可以绑定两种方法，一种是普通的方法，一种是类的成员方法。\n\n```cpp\n\nclass Test\n{\npublic:\n    void changeAB(int a, int b)\n    {\n        a_ = a;\n        b_ = b;\n    }\nprivate:\n    int a_;\n    int b_;\n}\n\nvoid test(int &a, int &b, const int &c)\n{\n    //此处打印结果是 a = 1\n    //在bind时就已经确定了各个参数的类型，不会因为方法本身改变\n    cout << \"in\" << a << \" \" << b << \" \" << c << endl;\n    ++a;\n    ++b; //此处修改main中b的值\n    // ++c; compile error\n}\n\nint main()\n{\n    using namespace std::placeholders; // 使用占位符\n    int a = 1, b = 2, c = 3;\n\n    //绑定test方法\n    std::function<void()> bound_test = std::bind(test, a, std::ref(b), std::cref(c));\n    a = 10;\n    b = 12;\n    c = 13;\n    cout << a  << \"  \" << b << \" \" << c << endl;\n    bound_test();\n    cout << a  << \"  \" << b << \" \" << c << endl;\n\n    //bind 类成员方法：\n    std::function<void()> bound_changeAB(&Test::changeAB, _1, _2);\n    bound_changeAB(a, b);\n}\n\n```\n\n","tags":["C++"]},{"title":"Weak_Ptr相关","url":"/2019/07/23/Weak-Ptr相关/","content":"\n# weak_ptr\n\nweak_ptr是一个C++11的语法，作为一个智能指针，最大的作用就是在多线程的环境下，配合share_ptr进行引用计\n数，但是weak_ptr是弱引用，也就是说，通过weak_ptr进行引用并不会将share_ptr+1, 只有通过lock()提升为\nshared_ptr才能正常的进行访问其中存储的数据，但同时也会进行引用数字的+1。\n\n```cpp\ntemplate <class T>\nstd::shared_ptr<T> lock() const nonexcept;\n```\n\n> 因weak_ptr是无法访问存储的数据的，必须同lock提升为shared_ptr再进行访问。用一个经典的Observer模式来\n> 演示weak_ptr.\n\n```cpp\nclass Observer\n{\npublic:\n    virtual ~Observer() {\n       subject_->unregister(); \n    }\n    virtual void update() {}\n    \n    void observer(Observable *s) {\n        s->register_(this);\n        subject_ = s;\n    }\nprivate:\n    Observable *subject_;\n}\n\nclass Observable\n{\npublic:\n    void register(Observer* ob);\n    void unregister(Observer* ob);\n\n    void notifyRegeisters()\n    {\n        /*******\n        for (auto x : observers_) {\n            x->update();\n        }\n        ******/\n\n        Iterator iter = observers_.begin();\n        while (iter != observers_.end()) \n        {\n            //通过lock() 提升\n            std::shared_ptr<Observer *> obj(iter->lock());     \n            if (obj) {\n                iter->update();\n                iter++;\n            } else {\n                observers_.erase(iter); //提升失败 直接从vector中删除weakptr\n            }\n        }\n    }\n\nprivate:\n    //std::vector<Observers *> observers_;\n    std::vector<std::weak_ptr<Observer *>> observers_;\n    typedef std::vector<std::weak_ptr<Observer *>>::iterator Iterator; \n}\n```\n\n# shared_ptr\n\n## reset \n\n可通过一个T* 的指针重新赋值给shared_ptr，来填充shared_ptr。\n\ntemplate <class T>\nvoid reset(T *) noexcept;\n","tags":["C++"]},{"title":"Leetcode-42-TrappingRainWaters","url":"/2019/07/22/LeetCode-42-TrappingRainWaters/","content":"\n# Leetcode 42 Trapping Rain Waters\n\n## 题目\n\n\n> Given n non-negative integers representing an elevation map where the width of each bar is 1,\n> compute how much water it is able to trap after raining.\n\n![test](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n## 题解\n\n这个题其实很有意思，一开始刷的时候，感觉无从下手，但是第二次刷就好很多，起码有个大概思路，用了\n两种思路来解这道题。\n\n- Two Pointers\n- MonoStack\n\n### Two Pointers\n\n我们可以先理清楚最基本的问题，能Trap住雨水的，一定是有凹槽存在，而这个凹槽能容纳多少水，一定是\n以它两端中最低的这端作为Base，除此之外，应该是两端各取最大值，以达到容纳最多水的效果。举个🌰。\n\n*Lmax L R Rmax*\n\n此时，如果LMax < Rmax,  我们可以计算L点的水量，因为此时，我们以LMax为短板，那么一定有Rmax > LMax\n所以我们可以将L处的水量，即Lmax - L 加入到水量中，反之，则加入RMax - R。\n\n```cpp\nint trap(vector<int>& height)\n{\n    int left = 0;\n    int right = height.size()-1;\n    int leftMax = 0;\n    int rightMax = 0;\n    int res = 0;\n\n    while (left < right)\n    {\n        leftMax = max(height[left], leftMax);\n        rightMax = max(height[right], rightMax);\n\n        if (leftMax > rightMax) {\n            res += rightMax - height[right];\n            right--;\n        } else {\n            res += leftMax - height[left];\n            left++;\n        }\n    }\n\n    return res;\n}\n```\n### MonoStack\n\n这个解法其实也很有意思，单调栈，顾名思义，就是栈内的元素都保持单调递增或递减，因为我们的目的是\n计算容纳的水，那么就要制造高低差。我们使栈内的元素单调递减，考虑一种极限情况，1-4都为单调递减，\n第5个值 > 第一个值，此时，因为第五个值大于栈顶元素，所以我们将栈顶弹出，并将栈作为一个坑，此时，\n坑的高度应该为当前栈（即弹出栈顶后的栈）的栈顶与第五个值的min（显然为栈顶）与坑的高度做差，得到\n此时坑的高度，坑的宽度应该为5 - 3 - 1，也就是第五个元素的index与栈顶的index相减，因宽度为1，故\n再次减一，相乘即为结果。\n\n```cpp\nint trap1(vector<int>& height)\n{\n    stack<int> stk;\n    int res = 0;\n    int i = 0;\n    int sz = height.size();\n\n    while (i < sz)\n    {\n        if (stk.empty() || height[stk.top()] >= height[i])\n            stk.push(i++);\n        else {\n            int cur  = height[stk.top()];\n            stk.pop();\n            int len = i - stk.top() - 1;\n            int h = min(stk.top(), height[i]);\n            res += (h - cur) * len;\n        }\n    }\n\n    return res;\n}\n```\n\n## 总结 \n其实Two Pointer与MonoStack有相似指出，只不过Two Pointers计算的是纵向的水量，MonoStack计算的是\n横向的水量。反正这个题，应该算是吃透了8. 快乐。\n","tags":["C++","Leetcode"]},{"title":"881_BoatsToSavePeople","url":"/2019/07/22/LeetCode-881-BoatsToSavePeople/","content":"\n# LeetCode 881 Boats To Save People\n\n## 题目\n\n> The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\n\n> Each boat carries at most 2 people at the same time, provided the sum of the weight of those \n> people is at most limit.\n\n> Return the minimum number of boats to carry every given person.  (It is guaranteed each person\n> can be carried by a boat.)\n\n这个还蛮简单的，完全可以类比成，2 Sum，取最接近的值，没啥好说的，直接上代码了。\n\n## Code\n\n```cpp\nint numRescueBoats(vector<int>& people, int limit)\n{\n    sort(begin(people), end(people));\n\n    int beg = 0;\n    int end = people.size()-1;\n    int count = 0;\n\n\n    while (beg <= end)\n    {\n        if (people[beg] + people[end] > limit)\n        {\n            end--;\n            count++;\n        }\n        else\n        {\n            beg++;\n            end--;\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Mutable关键字","url":"/2019/07/21/Mutable关键字/","content":"\n# 关于C++的mutable关键字\n\nC++的mutable关键字今天整理一下。\n\nC++的const概念为 不可以修改，const可用来修饰变量，指针，引用，类成员函数等，当const被用来修饰\n成员函数的时候，代表该成员函数不可以修改类内部的成员变量。\n\n```cpp\n\nclass dummy\n{\npublic:\n    int getX() const\n    {\n        // x = 10  compplie error\n        return x;\n    } \n\nprivate:\n    int x;\n}\n\n```\n\n> getX作为const成员函数，强行修改会造成编译错误.\n> 但是通过mutable关键字，我们可以对mutable修饰的成员变量进行修改。\n\n```cpp\nclass dummy_mutable\n{\npublic:\n    std::string get(std::string key) \n    {\n        if (key == last_key) \n        {\n            return last_value;\n        }\n\n        std::string value = {this->lookup(last_key)};\n\n        last_key_ = key;\n        last_value_ = value;\n    }\nprivate:\n    mutable std::string last_key_;\n    mutable std::string last_value_;\n}\n```\n\n在这个例子中我们可以看到，我们在const成员函数get()中修改了last_key_以及last_value_\n的值，这就是mutable的作用。\n\n\n\n","tags":["C++"]},{"title":"LeetCode 424_LongestRepeatingCharacterReplacement","url":"/2019/07/13/LeetCode-424-LongestRepeatingCharacterReplacement/","content":"\n# LeetCode 424 Longest RepeatingCharacterReplacement\n\n## 题目\n\n> Given a string s that consists of only uppercase English letters, you can perform at \n> most k operations on that string.In one operation, you can choose any character of the \n> string and change it to any other uppercase English character.Find the length of the longest\n> sub-string containing all repeating letters you can get after performing the above operations.\n\n## 题意\n\n本题的意思是，给定一个只含有小写字母的单词，最多可以进行K次替换，找到长度最长的相同字母字串。\n\n本题一开始看的时候还以为是dp = =，后来想起来我最近刷的全是Two Pointers类型… 所以就往Slide Window方向\n想，还是基本操作，一个指向beg，一个指向end…但是后来看了Discuss，这个解法真的惊到我了，属实优雅。\n\n用一个mp来记录slide window中经过的所有字母，但是这个里面只有两种字母，一个是数量最多的相同字母，我们用same\n表示，还有0-k个字母是替换成same字母的，如果此时刚好有k个字母被替换，那么替换字母量达到最大，此时应该有\nk + same == end - beg.一旦end - beg 大于 k + same,说明我们的slide window需要缩小，即beg++，这就是全部过程。\n\n## Code\n\n```cpp\nint characterReplacement(string s, int k)\n{\n    int beg = 0, end = 0;\n    int len = s.length();\n    int same = 0;\n    int mp[130];\n\n    memset(mp, 0, sizeof(mp));\n\n    while (end < len) {\n        same = max(same, ++mp[s[end++]]);\n        if (end - beg - same > k)\n            --mp[s[beg++]];\n    }\n    return end - beg;\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["算法"]},{"title":"LeetCode 992 SubarraysOfKDistincts","url":"/2019/07/12/LeetCode-992-SubarraysOfKDistincts/","content":"\n\n# LeetCode 992 SubarraysOfKDistincts \n\n## 题目\n\n> Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of \n> A good if the number of different integers in that subarray is exactly K.\n> (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\n> Return the number of good subarrays of A.\n\n本题的意思是说，在给定的数组中，有多少个子数组刚好含有K个数字。\n\n## 题解\n\n一开始想到的是用一个Slide Window，但是只是简单的用一个deq来做滑动窗口，有可能会错过一些情况。\n后来和室友讨论的方法是维护一个数组，以数组中的每个元素为起始元素来向后遍历，一直到最右端，\n即当前字数组中包含的数字数量为K位置，后面设置一个特殊标志为如INF等。但是这个样子其实复杂度\n较高，不具有可行性。\n\n后在Youtube上刷到了题解，这个题完全可以以高中时候的思路来做，原题为求刚好含有K个数字，我们改为，\n完整遍历一遍A数组，每次 += f(K) = 以当前字符结尾的子串至多含有K个数字。同时，使用f(k) - f(k-1)\n就可以得出题目的解。 \n\n还有一个要点是：我们计算至多含有K个数字其实有很多种解法，但是可以在遍历的时候，通过滑动窗口的两侧\n的差值+1，就是以当前字符结尾的字串数量.\n\n## Code\n\n```cpp\n\nint subarraysWithKDistinct(vector<int>& A, int k)\n{\n\tint n = A.size();\n\tint res;\n\n\tauto sub = [&A](int k) {\n\t\tint ans = 0;\n\t\tint i = 0;\n\t\tint mp[20005];\n\t\tmemset(mp, 0, sizeof(mp));\n\t\t//循环开始\n\t\tfor (int j = 0; j < A.size(); j++)\n\t\t{\n\t\t\tif (mp[A[j]]++ == 0)\n\t\t\t\t--k;\n\t\t\twhile (k < 0)\n\t\t\t\tif (--mp[A[i++]] == 0) ++k; //k为0时就将滑动窗口的左侧左移\n\t\t\tans += j - i + 1; \t//以当前滑动窗口为最右侧的字符串为end的字串的数量\n\t\t}\n\t\treturn ans;\n\t};\n\treturn sub(k) - sub(k-1);\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["算法"]}]