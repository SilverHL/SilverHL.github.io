[{"title":"pythonè°ƒç”¨Cæå‡æ€§èƒ½è®°å½•","url":"/2020/04/03/pythonè°ƒç”¨Cæå‡æ€§èƒ½è®°å½•/","content":"\n##Pythoné€šè¿‡è°ƒç”¨Cæ¥æå‡æ€§èƒ½çš„ä¸€æ¬¡è®°å½•\n\nâ€‹\t\tæ˜¨å¤©é‡åˆ°çš„ä¸€ä¸ªäº‹ï¼ŒåŒäº‹é€šè¿‡Pythonæ¥å¤„ç†å…¶ä»–å®¶å‚å•†çš„æ—¥å¿—ï¼Œå°†æ ¼å¼è½¬æ¢æˆå†…éƒ¨æ—¥å¿—æ ¼å¼ï¼Œä¸æ˜¯å¤æ‚çš„éœ€æ±‚ï¼Œä½†æ˜¯é‡åˆ°äº†æ€§èƒ½ç“¶é¢ˆï¼Œå•æ ¸å¤§æ¦‚8000qpsï¼Œ500wè¡Œçš„æ—¥å¿—å¤„ç†å¤§æ¦‚éœ€è¦3minã€‚ç”³è¯·äº†çš„æ˜¯16æ ¸æœºå™¨ï¼Œè€ƒè™‘åˆ°å¤šçº¿ç¨‹æƒ…å†µä¸‹çš„è°ƒåº¦ï¼Œå•æœº10wçš„qpsåº”è¯¥æ˜¯æœ‰ç‚¹å‹‰å¼ºèƒ½è¾¾åˆ°çš„ï¼Œè€Œä¸”å®é™…æµ‹è¯•çš„æ—¶å€™ï¼Œè™½ç„¶èƒ½è¾¾åˆ°ï¼Œä½†æ˜¯16æ ¸cpuåŸºæœ¬éƒ½è·‘ğŸˆµï¸äº†ã€‚è™½ç„¶æœºå™¨åªæœ‰è¿™ä¸€ä¸ªæœåŠ¡åœ¨è·‘ï¼Œä½†æ˜¯å®é™…å ç”¨å¤§é‡æ—¶é—´çš„è¿˜æœ‰ç£ç›˜IOç­‰ä¼šé˜»å¡çš„æ“ä½œï¼Œå› æ­¤æƒ³ç€è¦ç»™ä¼˜åŒ–ä¸€ä¸‹ï¼Œæ€è·¯æ˜¯é€šè¿‡ç«ç„°å›¾åˆ†æä»£ç è€—è´¹æ—¶é—´çš„éƒ¨åˆ†ï¼Œç„¶åé€šè¿‡Cæ¥é‡å†™è¯¥éƒ¨åˆ†çš„é€»è¾‘ï¼Œå¹¶é€šè¿‡Pythonçš„ctypesåŒ…æ¥è°ƒç”¨Cçš„æ¥å£ã€‚\n\n\n\n### PyFlameå®‰è£…åŠç”Ÿæˆç«ç„°å›¾&åˆ†æ\n\nâ€‹\t\té¦–å…ˆæ˜¯é€šè¿‡ç«ç„°å›¾æ¥è¿›è¡Œæ€§èƒ½çš„åˆ†æï¼Œå› ä¸ºä¹‹å‰ç”¨è¿‡æ ‡å‡†åº“çš„CProfileæ¥æŸ¥çœ‹æŸä¸ªpyè„šæœ¬çš„æ€§èƒ½ï¼Œå‘½ä»¤æ˜¯`python -m cProfile -s tottime test_parse.py`ï¼Œå¯æƒœä»£ç å®é™…æ˜¯å¤šè¿›ç¨‹æ¥åšçš„ï¼ŒcProfileä¼šæŠ¥é”™ï¼Œå…·ä½“åŸå› æ²¡æœ‰æ·±ç©¶ã€‚ç»è¿‡googleé€‰äº†[PyFlame](\"https://github.com/uber-archive/pyflame\")æ¥ç”Ÿæˆç«ç„°å›¾ï¼Œå…·ä½“ä¾èµ–çš„åº“åŒ…æ‹¬autoconf, automake ç­‰ç­‰ï¼Œä¸å†åˆ—ä¸¾ï¼ŒCentOSä¸‹çš„ç¼–è¯‘å®‰è£…å¯å‚ç…§[è¿™é‡Œ](\"https://blog.csdn.net/qq_30549833/article/details/72955881\")ã€‚[å®˜æ–¹æ–‡æ¡£](\"https://pyflame.readthedocs.io/en/latest/\")å¯¹äºå®‰è£…è¿‡ç¨‹å†™çš„æŒºè¯¦ç»†çš„ï¼Œä¸å†èµ˜è¿°ã€‚å®‰è£…å®ŒPyFlameè¿˜éœ€è¦å®‰è£…ä¸€ä¸ª[FlameGraph](\"https://github.com/brendangregg/FlameGraph\")ï¼Œé€šè¿‡å…¶ä¸­çš„flamegraph.plæ¥ç”Ÿæˆç«ç„°å›¾ã€‚\n\nâ€‹\t\tç”¨æ³•æ˜¯ï¼ŒPyFlameä¼šé€šè¿‡attachåˆ°å…·ä½“çš„è¿›ç¨‹ç„¶åæ‹¿åˆ°è¿›ç¨‹è°ƒç”¨é“¾å’Œè€—è´¹çš„æ—¶é—´ï¼ŒåŒæ—¶è¿˜æ”¯æŒè®¾ç½®é‡‡æ ·çš„æ€»æ—¶é—´ä»¥åŠæ¯æ¬¡é‡‡æ ·çš„é—´éš”æ—¶é—´ï¼Œç„¶åé‡‡æ ·å®ŒæˆåæŠŠæ•°æ®pipeåˆ°flamegraph.plç”Ÿæˆç«ç„°å›¾ï¼Œå¯ä»¥åœ¨chromeä¸­ç›´æ¥æ‰“å¼€ã€‚\n\n> pyflame -s 10 -p 26788 | ../../FlameGraph/flamegraph.pl > A.svg\n\nï¼ˆå¹¶æœªè®¾ç½®é‡‡æ ·é—´éš” å¯é€šè¿‡-rè¿›è¡Œè®¾ç½®\n\n\n\n### é€šè¿‡ç«ç„°å›¾è¿›è¡Œåˆ†æ & ä¼˜åŒ–\n\nç”Ÿæˆçš„å›¾æ˜¯è¿™æ ·çš„ï¼š\n\n![](https://raw.githubusercontent.com/SilverHL/image_repo/master/1.png)\n\nï¼ˆä¸€å¼€å§‹ä¸ä¼šçœ‹ç«ç„°å›¾æœ‰ç‚¹å°´å°¬ å®³ è¡¥å……ä¸€ç‚¹å°çŸ¥è¯†\n\n> ç»è¿‡Googleï¼Œç«ç„°å›¾çš„é¢œè‰²ä¸è€—è´¹æ—¶å¸¸å•¥ğŸ”8âƒ£ï¸å…³ç³»éƒ½ğŸˆšï¸ã€‚éœ€è¦æ³¨æ„çš„æ˜¯æ¨ªå‘ä»£ç çš„é•¿åº¦<strong>ä»£è¡¨ä»£ç æ‰§è¡Œè€—è´¹çš„æ—¶é—´</strong>ï¼Œçºµå‘å¾€ä¸Šçš„å±‚çº§è¶Šå¤šï¼Œè¶Šè¯´æ˜<strong>è°ƒç”¨é“¾è¶Šé•¿</strong>strong>ï¼Œä¹Ÿå°±è¶Šæœ‰å¯èƒ½<strong>å ç”¨CPUæ—¶é—´</strong>ã€‚\n\nâ€‹\t\tæˆ‘ä»¬å¯ä»¥åœ¨å›¾ä¸­çœ‹åˆ°ï¼Œå®é™…æœ€èŠ±æ—¶é—´çš„åº”è¯¥æ˜¯å››ä¸ªè“è‰²ç®­å¤´æ‰€æŒ‡çš„ä½ç½®ï¼Œå¯ä¼˜åŒ–çš„ä¹Ÿåœ¨è¿™é‡Œã€‚çœ‹äº†ä¸‹ä»£ç ï¼Œå…¶ä¸­<strong>1å·å·¦ä¾§</strong>çš„ä»£ç å¯¹åº”çš„æ˜¯åœ¨IOç£ç›˜æ“ä½œï¼Œå³åœ¨ç¡¬ç›˜ä¸­è¯»å–æ—¥å¿—å‡ºæ¥ï¼Œè¿™ä¸ªæ¶ˆè€—å®é™…ä¸Šæ˜¯ä¸èƒ½é¿å…çš„ã€‚1å·æ“ä½œå¯¹åº”çš„æ˜¯å°†æŸä¸€æ¡æ—¥å¿—é€šè¿‡æ­£åˆ™æå–å‡ºæŸäº›å¿…è¦çš„ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯è¯´<strong>æ­£åˆ™åŒ¹é…</strong>æ¶ˆè€—äº†ä¸€å®šæ—¶é—´ï¼Œæƒ³æ¥æƒ³å»æ²¡æœ‰ä»€ä¹ˆå¥½çš„ä¼˜åŒ–æ‰‹æ®µï¼Œå› ä¸ºæ—¥å¿—æ ¼å¼æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥è¿˜æ˜¯ç”¨<strong>split(\" \")</strong>æ¥æŠŠæ­£åˆ™æ›¿æ¢æ‰ï¼ˆå…¶å®æ˜¯æœ‰ä¸€äº›ä½œç”¨çš„å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼‰ã€‚\n\nâ€‹\t\tå†æ¥çœ‹2-4å·æ“ä½œï¼Œè¿™å‡ ä¸ªå…¶å®éƒ½æ˜¯ä¸€æ ·çš„æ“ä½œï¼ŒæŠŠåŸæ—¥å¿—ä¸­çš„UTCæ—¶é—´ï¼ˆæ ¼æ—å°¼æ²»æ ‡å‡†æ—¶é—´ï¼‰è½¬æ¢æˆCSTï¼ˆä¸œå…«åŒºåŒ—äº¬æ—¶é—´ï¼‰ï¼Œç»è¿‡çº¿ä¸‹ä¸åŒäº‹å•†é‡ï¼Œå»æ‰äº†åä¸¤ä¸ªï¼Œå› ä¸ºä»–ä¹Ÿæ²¡ç”¨åˆ°ï¼ˆæ‰‹åŠ¨ç‹—å¤´ã€‚ç»è¿‡è¿™ä¸€ç•ªæ“ä½œï¼Œç«ç„°å›¾å˜æˆäº†é…±ï¼š\n\n![image-20200403181338126](https://raw.githubusercontent.com/SilverHL/image_repo/master/2.png)\n\nâ€‹\t\tä¹Ÿå°±æ˜¯è¯´ï¼Œ<strong>åŸæ¥çš„1å·</strong>ï¼ˆæ­£åˆ™åŒ¹é…ï¼‰æ¶ˆè€—çš„æ—¶é—´æ¯”è¾ƒå°‘ï¼Œä¸Šå›¾çš„1å·ï¼Œæ¶‰åŠåˆ°æ¯”è¾ƒæ·±å±‚æ¬¡çš„è°ƒç”¨ï¼Œåº”è¯¥æ˜¯å±äºç£ç›˜IOï¼Œä¹Ÿå°±æ˜¯æ— æ³•é¿å…çš„æ¶ˆè€—ã€‚è€Œ2å·å°±æ˜¯æ—¶é—´è½¬æ¢ï¼Œéœ€è¦å°†åŸæ—¥å¿—çš„å­—ç¬¦ä¸²è½¬æˆdatetimeå¯¹è±¡ï¼Œç„¶åè¿›è¡Œæ—¶åŒºçš„è½¬æ¢ï¼Œåœ¨è½¬å›å­—ç¬¦ä¸²ã€‚å› ä¸ºå®é™…linuxè·å–æ—¶é—´å®é™…æ˜¯éœ€è¦ç³»ç»Ÿè°ƒç”¨çš„ï¼Œå› æ­¤è¿˜æ˜¯å¾ˆæ¶ˆè€—æ—¶é—´çš„ï¼Œæ‰€ä»¥è¿™å—ç”¨Cæ¥é‡å†™ï¼Œä»¥æœŸæé«˜æ€§èƒ½ã€‚\n\n### Pythonè°ƒç”¨C\n\nâ€‹\t\tç»è¿‡ä¸€ç•ªGoogleï¼Œå‘ç°ctypeså®é™…æ˜¯æ¯”è¾ƒå¥½ç”¨çš„ï¼Œå†™Cå°±å¯ä»¥ï¼Œç„¶åç¼–è¯‘æˆåŠ¨æ€é“¾æ¥åº“ï¼Œå†åœ¨pythonä¸­è°ƒç”¨ã€‚ä¸åƒCythonï¼Œéœ€è¦å†™Pythonï¼ˆ8æ˜¯å¾ˆä¼šå†™pyï¼‰ï¼Œå®é™…æ¯”pythonå¤šçš„å°±æ˜¯æŒ‡å®šç±»å‹ï¼Œåœ¨ç¼–è¯‘æœŸå°±å®Œæˆç±»å‹çš„æ¨å¯¼ï¼Œä¸åƒåŸç”Ÿçš„pythonéœ€è¦åœ¨è¿è¡ŒæœŸåŠ¨æ€çš„æ¨å¯¼ç±»å‹ï¼Œè€—è´¹æ—¶é—´è¿‡å¤šï¼Œï¼ˆåè¯ï¼Œå¯èƒ½ä¼šç ”ç©¶ä¸‹è¿™æ–¹é¢ï¼‰ã€‚\n\nâ€‹\t\té¦–å…ˆæ˜¯ç”¨Cå®Œæˆæ—¶é—´è½¬æ¢çš„æ­¥éª¤ï¼Œä»‹ç»å‡ ä¸ªAPI:\n\n  å°†å½“å‰çš„æ—¶åŒºè®¾ç½®ä¸ºä¸œå…«åŒºåŒ—äº¬æ—¶åŒºï¼š\n\n> setenv(\"TZ\", \"GMT-8\", 1) \n\nå°†char *ç±»å‹çš„æ—¶é—´å­—ç¬¦ä¸²æŒ‰ç…§formatæ ¼å¼è½¬æ¢åˆ°struct tmç±»å‹\n\n> char *strptime(const char *s, const char *format, struct tm *tm);\n\nå°†struct tm *ç±»å‹çš„timeptræŒ‰ç…§formatæ ¼å¼è½¬æ¢åˆ°char *, maxsizeæŒ‡çš„éœ€è¦å¡«å……çš„bufferçš„æœ€å¤§é•¿åº¦\n\n> size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)\n\nå°†struct tm *ç±»å‹è½¬æ¢æˆunixæ—¶é—´æˆ³\n\n> time_t timegm(struct tm *tm);\n\nå°†struct tm *ç±»å‹è½¬æ¢æˆæœ¬åœ°æ—¶åŒºçš„unixæ—¶é—´æˆ³ï¼ˆä¼¼ä¹ä¸éœ€è¦ä¸Šé¢çš„setenv\n\n> time_t mktime(struct tm *timeptr)\n\nå°†time_tç±»å‹çš„unixæ—¶é—´æˆ³è½¬æ¢æˆstruct tm*\n\n> struct tm *localtime(const time_t *timer)\n\n\n\nä¸Šä»£ç ï¼š\n\n```c\n#include <stdio.h>\n#include <sys/times.h>\n#include <time.h>\n#include <string.h>\n\nconst char *\nutc_to_cst(const char *utc_time)\n{\n   setenv(\"TZ\", \"GMT-8\", 1);        // set current timezone beijing\n   struct tm tmstr;\n   struct tm * tmlocal;\n   time_t tslastutc;\n   time_t tslastloc;\n   char cst_time[32];\n   memset(&tmstr, 0, sizeof(struct tm));\n   strptime(utc_time, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert argument to struct tm\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", &tmstr); // convert struct tm to string, still\n\n   tslastutc = timegm(&tmstr);     // get UCT Unix time from argument string time  GMT\n   tslastloc = mktime(&tmstr);     // get local Unix time from argument string time\n   tslastloc += (tslastutc - tslastloc);    // wired operation, seems to reduce deviation\n   tmlocal = localtime (&tslastloc); \t// get local time in struct tm format\n   memset(cst_time, 0, 32);\n   strftime(cst_time, 32, \"%Y-%m-%d %H:%M:%S\", tmlocal); // convert local struct tm to string\n   return cst_time;\n}\n```\n\nâ€‹\t\té€šè¿‡è¿™ä¸ªå‘½ä»¤å°†ä»£ç ç¼–è¯‘æˆåŠ¨æ€é“¾æ¥åº“ï¼Œå¹¶é€šè¿‡pythonä»£ç è¿›è¡Œè°ƒç”¨ï¼š\n\n> gcc -shared -Wl,-soname,utc_to_cst -o utc_to_cst.so -fPIC utc_to_cst.c\n\nâ€‹\t\tpythonè°ƒç”¨ä»£ç å¦‚ä¸‹ï¼ˆå…¶å®ä¹Ÿæ˜¯é€šè¿‡æŒ‡æ˜ç¬¦å·åã€å˜é‡å’Œè¿”å›å€¼ç±»å‹ï¼‰ï¼š\n\n```python\nfrom ctypes import *\n\ntime_convert = CDLL(\"./utc_to_cst.so\")\t# add dll\nin_arg = c_char_p(\"2018-02-19 00:00:00\") # specify in arg type (char *)\nu_to_c = time_convert.utc_to_cst\t# connect u_to_c with symbol utc_to_cst in .so file\nu_to_c.restype = c_char_p # specify return type in c (char *)\nprint(u_to_c(in_arg))\n\n\n```\n\nå®é™…ä¸Šåˆ°è¿™é‡Œå°±Ù©(â€¢Ì¤Ì€áµ•â€¢Ì¤Ìà¹‘)áµ’áµáµáµáµäº†ï¼Œä½†æ˜¯åº”ç”¨åˆ°çš„æ—¶å€™å‡ºç°äº†ä¸€ä¸ªè¯¡å¼‚çš„ç°è±¡ï¼Œä»–ğŸçš„ç”¨å®ŒCçš„æ¨¡å—å±…ç„¶è¿˜æ›´æ…¢äº†ï¼ç”Ÿæˆçš„ç«ç„°å›¾å¦‚ä¸‹ï¼š\n\n![image-20200403181450308](https://raw.githubusercontent.com/SilverHL/image_repo/master/3.png)\n\nâ€‹\t\tå¯ä»¥çœ‹åˆ°2å·å ç”¨çš„æ—¶é—´æ¯”ä¸Šä¸€å¼ å›¾é•¿äº† = = å®é™…æµ‹è¯•500wè¡Œå¤„ç†å®Œæˆçš„æ—¶é—´ä¹Ÿæœ‰4minï¼Œè€—è´¹æ—¶é—´å®é™…ä¸ŠèŠ±åœ¨äº†ctypesçš„\\_\\_init\\_\\_()æ–¹æ³•ä¸Šï¼Œç„¶åå°±æ²¡æœ‰æ›´æ·±çš„è°ƒç”¨é“¾äº†ã€‚æˆ‘å°±å»å®é™…çš„çœ‹äº†ä¸‹ctypesçš„\\_\\_init\\_\\_åˆ°åº•åšäº†ä¸ªå•¥äº‹ï¼Œä»£ç ä¸­æœ‰å‡ è¡Œæ˜¯è¿™æ ·çš„ï¼š\n\n```\nif handle is None:\n    self._handle = _dlopen(self._name, mode)\nelse:\n    self._handle = handle\n```\n\nâ€‹\t\thandleåº”è¯¥æŒ‡çš„å°±æ˜¯.soæ–‡ä»¶ä¸­çš„ç¬¦å·ï¼Œå³utc_to_cst, ä»£è¡¨æˆ‘ä»¬è°ƒç”¨çš„Cä»£ç ä¸­çš„å¤„ç†æ–¹æ³•ï¼Œç„¶åæƒ³åˆ°ç”¨çš„æ—¶å€™ï¼ŒæŠŠ`time_convert = CDLL(\"./utc_to_cst.so\")`è¿™è¡ŒåŠ åœ¨äº†å¾ªç¯ï¼Œæ‰å¯¼è‡´æœ‰å¤§é‡çš„æ—¶é—´èŠ±åœ¨äº†_dlopen()ä¸­ï¼Œæœæ–­æŠŠè¿™è¡Œç§»é™¤å¾ªç¯ï¼Œç»ˆäºå¾—åˆ°äº†æ»¡æ„çš„ç»“æœï¼Œç«ç„°å›¾å¦‚ä¸‹ï¼š\n\n![image-20200403182202297](https://raw.githubusercontent.com/SilverHL/image_repo/master/4.png)\n\nç»è¿‡å®é™…æµ‹è¯•ï¼Œå®Œæˆä»¥ä¸Šçš„ä¼˜åŒ–è¿‡ç¨‹åï¼Œå•æ ¸qpså¯ä»¥è¾¾åˆ°5wå·¦å³ï¼Œå°±ç®—çªå‘ä¹Ÿå¯ä»¥å¾ˆå¥½çš„åº”ä»˜ã€‚"},{"title":"Leetcode-861-ReverseMatrixScore","url":"/2020/03/10/Leetcode-861-ReverseMatrixScore/","content":"\n# Leetcode 861 ReverseMatrixScore \n\n\n\n## é¢˜ç›®\n\næœ‰ä¸€ä¸ªäºŒç»´çŸ©é˜µ A å…¶ä¸­æ¯ä¸ªå…ƒç´ çš„å€¼ä¸º 0 æˆ– 1 ã€‚\n\nç§»åŠ¨æ˜¯æŒ‡é€‰æ‹©ä»»ä¸€è¡Œæˆ–åˆ—ï¼Œå¹¶è½¬æ¢è¯¥è¡Œæˆ–åˆ—ä¸­çš„æ¯ä¸€ä¸ªå€¼ï¼šå°†æ‰€æœ‰ 0 éƒ½æ›´æ”¹ä¸º 1ï¼Œå°†æ‰€æœ‰ 1 éƒ½æ›´æ”¹ä¸º 0ã€‚\n\nåœ¨åšå‡ºä»»æ„æ¬¡æ•°çš„ç§»åŠ¨åï¼Œå°†è¯¥çŸ©é˜µçš„æ¯ä¸€è¡Œéƒ½æŒ‰ç…§äºŒè¿›åˆ¶æ•°æ¥è§£é‡Šï¼ŒçŸ©é˜µçš„å¾—åˆ†å°±æ˜¯è¿™äº›æ•°å­—çš„æ€»å’Œã€‚\n\nè¿”å›å°½å¯èƒ½é«˜çš„åˆ†æ•°ã€‚\n\n \n\nç¤ºä¾‹ï¼š\n\n> è¾“å…¥ï¼š[[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n> è¾“å‡ºï¼š39\n> è§£é‡Šï¼š\n> è½¬æ¢ä¸º [[1,1,1,1],[1,0,0,1],[1,1,1,1]]\n> 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n\næç¤ºï¼š\n\n1 <= A.length <= 20\n1 <= A[0].length <= 20\nA[i][j] æ˜¯ 0 æˆ– 1\n\n\n\n## é¢˜è§£\n\nè¿™é“é¢˜åˆ†ç±»æ˜¯è´ªå¿ƒç®—æ³•ï¼Œé¦–å…ˆéœ€è¦æ˜ç¡®ï¼Œä¸€ä¸ªæ¨ªå‘æˆ–çºµå‘çš„æ•°ç»„ç¿»è½¬ä¸¤æ¬¡=ã€‹æœªç¿»è½¬ï¼Œæ‰€ä»¥æ¯ä¸ªæ¨ªå‘æˆ–çºµå‘çš„æ•°ç»„æœ€å¤šç¿»è½¬ä¸€æ¬¡ã€‚ å› ä¸ºæœ€åéœ€è¦æ±‚å¾—æœ€å¤§å€¼ï¼Œæ‰€ä»¥æ¯ä¸ªæ•°ç»„çš„ç¬¬0ä½ä¸€å®šè¦æ˜¯1ï¼Œæœ‰äº†ç¬¬ä¸€ä¸ªéå†ã€‚çºµå‘éå†æ•°ç»„ç¬¬0ä½ï¼Œä¸ä¸º1çš„ï¼Œå°†æ•´ä¸ªæ•°ç»„<strong>æ¨ªå‘ç¿»è½¬</strong>ã€‚æ­¤æ—¶æ‰€æœ‰æ•°ç»„å‡<strong>ä¸å¯ä»¥</strong>å†æ¨ªå‘ç¿»è½¬ã€‚ç”±äºæ±‚æœ€å¤§å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚æ•°ç»„ä¸­1çš„æ•°é‡ï¼Œå› æ­¤å°†sumåˆå§‹åŒ–ä¸º<strong>row * (int)pow(2, line - 1)</strong>,è€Œåé¢çš„çºµå‘æ•°ç»„ï¼Œæˆ‘ä»¬åªéœ€è¦ä¿è¯ <strong>æ¯ä¸ªçºµå‘æ•°ç»„ä¸­1çš„æ•°é‡å¤§äº0çš„æ•°é‡</strong>,ç„¶åå†é€šè¿‡1çš„æ•°é‡å¯ä»¥æ±‚å‡ºæ­¤æ—¶çš„å’Œã€‚\n\n\n\n## Code\n\n```cpp\nint matrixScore(vector<vector<int>>& A)\n{\n    for (auto &vec : A) {\n        if (vec[0] == 0) {\n            for (auto &i : vec)\n                i ^= 1;\n        }\n    }\n\n    const int r = A.size();\n    const int l = A[0].size();\n\n    int sum = r * (int)pow(2, l-1);\n\n    for (int j = 1; j < l; j++) {\n        int one_n = 0;\n        int zero_n = 0;\n\n      \t// è¿™é‡Œå¯ä»¥åªè®¡ç®—0æˆ–è€…1çš„æ•°é‡\n        for (int i = 0; i < r; ++i) {\n            if (A[i][j] == 0) {\n                zero_n++;\n            } else {\n                one_n++;\n            }\n        }\n\n        if (one_n > zero_n) {\n            sum += one_n * (int)pow(2, l - j - 1);\n        } else {\n            sum += zero_n * (int)pow(2, l - j - 1);\n        }\n    }\n    return sum;\n}\n```\n\n","tags":["C++","ç®—æ³•","greedy"]},{"title":"Nginx ngx_module_tç»“æ„ä½“","url":"/2020/03/09/Nginx-ngx-module-tç»“æ„ä½“/","content":"\n# Nginx ngx_module_t ç»“æ„ä½“\n\næ–­æ–­ç»­ç»­çš„è®°å½•ä¸€äº›nginxå­¦ä¹ çš„å†…å®¹ã€‚\n\n\n\n```c\nstruct ngx_module_s {\n    ngx_uint_t            ctx_index;    // å½“å‰æ¨¡å—åœ¨æœ¬ç±»æ¨¡å—ä¸­çš„é¡ºåº  æ¯”å¦‚ è¿‡æ»¤ç±»æ¨¡å— ç­‰ç­‰  \n    ngx_uint_t            index;        // å½“å‰ç±»æ¨¡å—åœ¨æ‰€æœ‰æ¨¡å—ä¸­çš„é¡ºåº å¦‚ ä¸€ä¸ªhttpæ¨¡å—åœ¨ http src locæ¨¡å—ä¸­çš„é¡ºåº\n\n    ngx_uint_t            spare0;\n    ngx_uint_t            spare1;\n    ngx_uint_t            spare2;\n    ngx_uint_t            spare3;\n\n    ngx_uint_t            version;\n\n    void                 *ctx; // æŒ‡å‘å½“å‰è¿™ç±»æ¨¡å—çš„å…¬å…±æ¥å£\n    ngx_command_t        *commands; // æŒ‡å‘è¿™ä¸ªæ¨¡å—å¯¹åº”çš„æ‰€æœ‰å‘½ä»¤\n    ngx_uint_t            type; // æ¨¡å—ç±»å‹\n\n    /**\n     * è¿™7ä¸ªæ–¹æ³•åœ¨nginxçš„æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰®æ¼”é‡è¦è§’è‰²\n     */\n    ngx_int_t           (*init_master)(ngx_log_t *log);\n\n    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);\n\n    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);\n    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);\n    void                (*exit_thread)(ngx_cycle_t *cycle);\n    void                (*exit_process)(ngx_cycle_t *cycle);\n\n    void                (*exit_master)(ngx_cycle_t *cycle);\n\n    uintptr_t             spare_hook0;\n    uintptr_t             spare_hook1;\n    uintptr_t             spare_hook2;\n    uintptr_t             spare_hook3;\n    uintptr_t             spare_hook4;\n    uintptr_t             spare_hook5;\n    uintptr_t             spare_hook6;\n    uintptr_t             spare_hook7;\n};\n\n```\n\n\n\n\n\n","tags":["nginx"]},{"title":"Leetcode-729-MyCalendarI","url":"/2019/11/22/Leetcode-729-MyCalendarI/","content":"\n\n\nLeetcode 729  MyCalendar I\n\n## é¢˜ç›®\n\nImplement a `MyCalendar` class to store your events. A new event can be added if adding the event will not cause a double booking.\n\nYour class will have the method, `book(int start, int end)`. Formally, this represents a booking on the half open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.\n\nA *double booking* happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\n\nFor each call to the method `MyCalendar.book`, return `true` if the event can be added to the calendar successfully without causing a double booking. Otherwise, return `false` and do not add the event to the calendar.\n\nYour class will be called like this: `MyCalendar cal = new MyCalendar();``MyCalendar.book(start, end)`\n\n**Example 1:**\n\n```\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\nExplanation: \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n```\n\n\n\n## é¢˜æ„\n\nè¿™é“é¢˜é¢˜æ„æ¯”è¾ƒç®€å•ï¼Œç»™å®šä¸€ä¸ªMyCalendarç±»ï¼Œæœ‰ä¸€ä¸ªbookæ–¹æ³•ï¼Œæ¯æ¬¡ä¼ ä¸€ä¸ªstartå’Œä¸€ä¸ªend, è¡¨ç¤ºä»`[start,end)`çš„æ—¥æœŸèƒ½å¦é¢„å®šï¼ˆå·¦é—­å³å¼€åŒºé—´ï¼‰ï¼Œå¯é¢„å®šçš„è¯å°±å®šä¸Šå¹¶è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚è¿™ä¸ªé¢˜å…¶å®ä¸éš¾ï¼Œé€šè¿‡ä¸€ä¸ªvectoræ¥è®°å½•å½“å‰è®°å½•çš„æ‰€æœ‰é¢„å®šï¼Œæ¯æ¬¡éå†å½“å‰æ‰€æœ‰çš„é¢„å®šï¼Œçœ‹æ˜¯å¦å’Œä¹‹å‰çš„é¢„å®šæœ‰å†²çªã€‚ä¸¤ä¸ªä¸åŒçš„solutionå°±æ˜¯åœ¨éå†æ–¹å¼ä¸Šæœ‰æ‰€ä¸åŒã€‚\n\n## Code 1\n\nå‡è®¾å½“å‰è°ƒç”¨ä¸º`book(s1, e1)`, å½“å‰éå†æ‰€æœ‰çš„é¢„å®šåˆ°äº†`[s2, e2)`, æˆ‘ä»¬ä¸€å…±ä¼šæœ‰ä»¥ä¸‹å‡ ä¸ªå¯èƒ½çš„æƒ…å†µï¼š\n\n![411574399768_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/411574399768_.pic.jpg)\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå·¦è¾¹çš„çº¢çº¿åªè¦å°äºå³è¾¹çš„è“çº¿ï¼Œéƒ½ä¼šæ˜¯æœ‰overlapçš„æƒ…å†µï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å½’ç»“ä¸€ä¸‹ï¼Œå°±æ˜¯<font color=red>max(s1, s2)</font> < <font color=blue>min(e1, e2)</font>çš„è¯ï¼Œå°±è®¤ä¸ºæ˜¯æœ‰overlapçš„æƒ…å†µï¼Œä»£ç å¦‚ä¸‹ï¼š\n\n```\nclass MyCalendar {\nprivate:\n    vector<int> mp_;\npublic:\n    MyCalendar1() {\n\n    }\n\n    bool book(int start, int end) {\n        int n = mp_.size();\n        for (int i = 0; i < n; i += 2)\n            if (max(mp_[i], start) < min(mp_[i+1], end))\n                return false;\n        mp_.push_back(start);\n        mp_.push_back(end);\n        return true;\n    }\n};\n```\n\nè¿™ä¸ªä»£ç çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(N), æ—¶é—´å¤æ‚åº¦æœ€å·®æ˜¯O(N^2)ã€‚\n\n## Code 2\n\nåˆšåˆšè¯´è¿‡ï¼Œä¸¤ä¸ªè§£æ³•çš„ä¸åŒå…¶å®å°±åœ¨äºæœç´¢å·²é¢„å®šçš„æ‰€æœ‰åºåˆ—çš„æ—¶å€™ï¼Œ<strong>Code 1</strong> ä½¿ç”¨çš„æ˜¯æœ€æœ´ç´ çš„éå†ï¼Œæˆ‘ä»¬è¿™é‡Œå°†è¦ä½¿ç”¨çš„æ˜¯äºŒåˆ†æŸ¥æ‰¾ã€‚\n\né¦–å…ˆæ˜¯ä¸¤ä¸ªC++çš„API:\n\n> map<Key,T,Compare,Allocator>::upper_bound(const Key& key)  è·å–å½“å‰mapä¸­ç¬¬ä¸€ä¸ªKeyå€¼å°äºç­‰äºkey çš„Key-Value pairã€‚\n>\n> map<Key,T,Compare,Allocator>::lower_bound(const Key& key) è·å–å½“å‰mapä¸­ç¬¬ä¸€ä¸ªKeyå€¼å¤§äºç­‰äºkey çš„Key-Value pairã€‚\n>\n> æ¢è¨€ä¹‹ï¼Œupper_boundå’Œlower_boundè¿”å›çš„éƒ½æ˜¯ä»¥<strong>å‚æ•°key</strong>ä½œä¸ºupper_boundæˆ–è€…lower_boundçš„ç¬¬ä¸€ä¸ªç›®æ ‡entry iteratorã€‚\n\nç„¶åå†æ¥çœ‹è¿™é“é¢˜ï¼Œå‡è®¾bookä¼ è¿›æ¥çš„æ˜¯`book(int start, end)`, æˆ‘ä»¬è·å¾—ä¸¤ä¸ªå€¼ï¼Œfloor=upper_bound(start), ceiling=lower_bound(start), å³è¾¹æ˜¯floorï¼Œå·¦è¾¹æ˜¯ceilingã€‚æˆ‘ä»¬å…ˆçœ‹å·¦è¾¹çš„floor, å¦‚æœæ­¤æ—¶ï¼Œ`it->first < end`,è¯´æ˜æœ‰overlapã€‚\n\næŒ‰ç†æ¥è¯´è¿™ä¸ªæ—¶å€™åº”è¯¥é€šè¿‡upper_bound(start)è·å¾—å·¦è¾¹çš„ceiling, ä½†æ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥ç¡®å®šå½“å‰mapé‡Œæ²¡æœ‰å‡ºç°overlapï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠlower_boundå‡ä¸€ï¼Œæ¥è·å¾—å½“å‰çš„upper_bound, ç„¶åæ¥åˆ¤æ–­`it->second > start`å°±è¯´æ˜æœ‰overlapã€‚\n\n![421574405947_.pic](https://raw.githubusercontent.com/SilverHL/image_repo/master/421574405947_.pic.jpg)\n\nä¸Šä»£ç ï¼š\n\n```\nclass MyCalendar\n{\nprivate:\n    map<int, int> mp;\npublic:\n\n    MyCalendar(){}\n    bool book(int start, int end)\n    {\n        map<int, int>::const_iterator it = mp.lower_bound(start);\n        if (it != mp.cend() && it->first < end)\n            return false;\n        if (it != mp.cend() && (--it)->second > start)\n            return false;\n        mp[start] = end;\n        return true;\n    }\n};\n```\n\n","tags":["C++","ç®—æ³•"]},{"title":"Leetcode-1040-MovingStonesUntilConsecutiveII","url":"/2019/11/19/Leetcode-1040-MovingStonesUntilConsecutiveII/","content":"\nLeetcode 1040 Moving Stones Until Consecutive II \n\nè¿™é“é¢˜â€¦å¡äº†è¿˜æŒºä¹…çš„ï¼Œä»Šå¤©çœ‹äº†ä¸€ä¸ªè§£æ³•æŒºå¥½çš„ï¼Œè®°å½•ä¸€ä¸‹ã€‚\n\n## é¢˜ç›®\n\nOn an **infinite** number line, the position of the i-th stone is given by `stones[i]`. Call a stone an *endpoint stone* if it has the smallest or largest position.\n\nEach turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, `stones = [1,2,5]`, you **cannot** move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves, ie. the stones are in consecutive positions.\n\nWhen the game ends, what is the minimum and maximum number of moves that you could have made? Return the answer as an length 2 array: `answer = [minimum_moves, maximum_moves]`\n\n \n\n**Example 1:**\n\n```\nInput: [7,4,9]\nOutput: [1,2]\nExplanation: \nWe can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n```\n\n**Example 2:**\n\n```\nInput: [6,5,4,3,10]\nOutput: [2,3]\nWe can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n```\n\n**Example 3:**\n\n```\nInput: [100,101,104,102,103]\nOutput: [0,0]\n```\n\n \n\n**Note:**\n\n1. `3 <= stones.length <= 10^4`\n2. `1 <= stones[i] <= 10^9`\n3. `stones[i]` have distinct values.\n\n## é¢˜æ„\n\nåœ¨ä¸€æ¡æ— é™é•¿çš„çº¿ä¸Šç»™å®šnä¸ªæ•°å­—ä»£è¡¨ä½ç½®ï¼Œæ¯æ¬¡å¯ä»¥å–ä¸€ä¸ªendpointï¼Œå³é¦–å°¾çš„ç‚¹æ’å…¥åˆ°ä¸­é—´çš„ç©ºä½ï¼Œå”¯ä¸€çš„é™åˆ¶å°±æ˜¯æ¯ä¸ªendpointä¸èƒ½å†æ’å…¥ä»¥åä¾ç„¶ä½œä¸ºendpointï¼Œä¸€ç›´åˆ°æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯è¿ç»­çš„ï¼Œæˆ‘ä»¬ä¸èƒ½å†ç»§ç»­ç§»åŠ¨endpointä¸ºæ­¢ï¼Œé¢˜ç›®éœ€è¦æˆ‘ä»¬è¿”å›ç§»åŠ¨çš„æœ€å°‘å’Œæœ€å¤§æ¬¡æ•°ã€‚\n\næˆ‘ä»¬å…ˆæ¥çœ‹max_steps, æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„æ•°å­—ä»æœ€å·¦è¾¹æˆ–è€…æœ€å³è¾¹å¼€å§‹å¾€ä¸­é—´æ’ï¼Œæ¯æ¬¡æ’å…¥åˆ°ç¬¬ä¸€ä¸ªç©ºä½ï¼Œä¸¾ä¸ªğŸŒ°ï¼Œ æ•°ç»„`[1, 3, 5, 6, 8, 9]`ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„æ•°å­—ä½œå¦‚ä¸‹ç§»åŠ¨ï¼š\n\n```\n[1, 3, 5, 6, 8, 9]\n[3, 4, 5, 6, 8, 9]\n[4, 5, 6, 7, 8, 9]\n```\n\nåˆæˆ–è€…è¿™ä¸ªæ•°ç»„`[1, 2, 3, 4, 5, 8]`,æˆ‘ä»¬è¿›è¡Œçš„æ“ä½œå¦‚ä¸‹ï¼š\n\n```\n[1, 2, 3, 4, 5, 8]\n[2, 3, 4, 5, 6, 8]\n[3, 4, 5, 6, 7, 8]\n```\n\næ‰€ä»¥æˆ‘ä»¬é¦–å…ˆå¯ä»¥å¾—å‡ºç»™å®šçš„æ•°ç»„ä¸­çš„ç©ºä½ä¸€å…±æœ‰`s1=stones[n-1] - stones[0] + 1 - n`, ä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰çš„ç©ºä½éƒ½å¯ä»¥æ’å…¥æ•°å­—ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œ`[1, 4, 6]`ä¸­ï¼ŒæŠŠ1ç§»åˆ°5ä»¥åï¼Œ<strong>2-3</strong>å°±ä¸èƒ½å†ç»§ç»­æ’å…¥æ•°å­—äº†ï¼Œå³ç¬¬ä¸€æ¬¡ç§»åŠ¨çŸ³å­çš„æ—¶å€™ï¼Œç§»åŠ¨ä»¥åå’ŒåŸæœ¬ç§»åŠ¨çš„çŸ³å­ç›¸é‚»çš„çŸ³å­ï¼Œè¿™ä¸¤ä¸ªçŸ³å­ä¹‹é—´çš„ç©ºä½ä¸èƒ½ç»§ç»­æ’å…¥æ•°å­—ï¼Œå³ä¸º`s2=min(stones[n-1] - stones[n-2] - 1, stones[1] - stones[0] - 1)`ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„max_stepså¯ä»¥é€šè¿‡`s2-s1`å¾—åˆ°ï¼Œ`max_steps=max(stones[n-2] - stones[n-2] + 2 - n, stones[n-1] - stones[1] + 2 - n)`ã€‚\n\nç„¶åæ˜¯æœ€å°å€¼min_steps, æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå½“æˆ‘ä»¬çš„å¾—åˆ°æœ€ç»ˆç»“æœçš„æ—¶å€™ï¼Œä¸€å®šæ˜¯ä¸€æ’è¿ç»­çš„æ•°å­—ï¼Œå¦‚æœéœ€è¦æ±‚æœ€å°çš„ç§»åŠ¨æ•°ï¼Œä¸€å®šæ˜¯å’Œæœ€åç»“æœé‡åˆæ•°æœ€å¤šçš„ã€‚æ‰€ä»¥æˆ‘ä»¬ç”¨ä¸€ä¸ªæ»‘åŠ¨çª—å£æ¥è®°å½•å½“å‰èŒƒå›´å†…çš„æ‰€æœ‰æ•°å­—ï¼Œåªè¦è¿™ä¸ªçª—å£å¤§äºnæˆ‘ä»¬å°±è®¡ç®—å½“å‰æ•°ç»„å’Œ<strong>nä¸ªè¿ç»­æ•°å­—çš„æ•°ç»„</strong>çš„é‡åˆæ•°ï¼Œæ‰¾æœ€å°çš„å°±æ˜¯ç»“æœã€‚ä½†æ˜¯è¿™ä¸ªé¢˜è¿˜æœ‰ä¸€ä¸ªåœ°æ–¹ä¸ä¸€æ ·ï¼Œæ¯”å¦‚`[1, 2, 3, 4, 6]`, è¿™ä¸ªæ—¶å€™æˆ‘ä»¬ä¸èƒ½æŠŠ6ç§»åˆ°5ï¼Œè€Œæ˜¯æŠŠ4ç§»åˆ°5ï¼Œç„¶åæŠŠ6ç§»åˆ°4ï¼Œæ‰€ä»¥å¼€é”€ï¼ˆç§»åŠ¨æ•°é‡ï¼‰ä¸º2ã€‚\n\n## Code\n\n```cpp\nvector<int> numMovesStonesII(vector<int>& stones)\n{\n    const int n = static_cast<int>(stones.size());\n    sort(begin(stones), end(stones));\n\n    int max_steps = std::max(stones[n-2] - stones[0] + 2 - n, stones[n-1] - stones[1] + 2 -n);\n\n    int min_steps = INT_MAX;\n    int i = 0;\n    int j = 0;\n    for (i = 0; i < n; ++i) {\n        while (j + 1 < n && stones[j+1] - stones[i] + 1 <= n)\n            j++;\n        int cost = n - (j - i + 1);\n        if (j - i + 1 == n-1 && stones[j] - stones[i] + 1 == n-1)\n            cost = 2;\n        min_steps = std::min(min_steps, cost);\n    }\n\n    return {min_steps, max_steps};\n}\n```\n\n","tags":["C++","Leetcode"]},{"title":"Leetcode-926-FlipStringToMonotoneIncreasing","url":"/2019/11/12/Leetcode-926-FlipStringToMonotoneIncreasing/","content":"\nLeetcode 926 Flip String To Monotone Increasing \n\næ°´ä¸€é“Leetcode = = \n\n\n\n# é¢˜ç›®\n\n>A string of `'0'`s and `'1'`s is *monotone increasing* if it consists of some number of `'0'`s (possibly 0), followed by some number of `'1'`s (also possibly 0.)\n>\n>We are given a string `S` of `'0'`s and `'1'`s, and we may flip any `'0'` to a `'1'` or a `'1'` to a `'0'`.\n>\n>Return the minimum number of flips to make `S` monotone increasing.\n>\n> \n>\n>**Example 1:**\n>\n>```\n>Input: \"00110\"\n>Output: 1\n>Explanation: We flip the last digit to get 00111.\n>```\n>\n>**Example 2:**\n>\n>```\n>Input: \"010110\"\n>Output: 2\n>Explanation: We flip to get 011111, or alternatively 000111.\n>```\n>\n>**Example 3:**\n>\n>```\n>Input: \"00011000\"\n>Output: 2\n>Explanation: We flip to get 00000000.\n>```\n>\n> \n>\n>**Note:**\n>\n>1. `1 <= S.length <= 20000`\n>2. `S` only consists of `'0'` and `'1'` characters.\n\n# é¢˜æ„\n\nè¿™ä¸ªé¢˜ï¼Œé¢˜ç›®ä¸ºç»™å®šä¸€ä¸ªstringï¼Œç”±0å’Œ1ç»„æˆï¼Œéœ€è¦åˆ¤æ–­æœ€å°‘flipå¤šå°‘æ¬¡æ‰èƒ½å°†è¿™ä¸ªå­—ç¬¦ä¸²è½¬å˜ä¸ºå•è°ƒé€’å¢çš„stringï¼Œå¯ä»¥å…¨ä¸º0æˆ–1ï¼Œä¹Ÿå¯ä»¥0-i å…¨éƒ¨ä¸º0ï¼Œ i+1-nå…¨éƒ¨ä¸º1ã€‚è¿™ä¸ªé¢˜ä¸€å¼€å§‹çœ‹åˆ°æˆ‘æ˜¯æƒ³åˆ°ç”¨dpçš„ï¼Œä½†æ˜¯æ²¡å†™å‡ºæ¥â€¦è¿™ä¸ªç®—æ˜¯ä¸¤ä¸ªè§£æ³•è®°å½•ä¸€ä¸‹ï¼Œç„¶åç¬¬äºŒä¸ªè§£æ³•é€æ¸ä¼˜åŒ–ã€‚\n\n# Code\n\n## è§£æ³•1\n\nç”¨ä¸¤ä¸ªæ•°ç»„l & rï¼Œl[i]è¡¨ç¤º ä»0 ï½ içš„1çš„æ•°é‡ï¼Œr[i]è¡¨ç¤ºi ï½ nçš„0çš„æ•°é‡ï¼Œä¸¤ä¸ªç›¸åŠ ï¼Œå–æœ€å°çš„ä¸€ç§è§£æ³•ï¼Œä¹Ÿå¯ä»¥å–ä¸¤ä¸ªè¾¹ç•Œæƒ…å†µï¼Œæœ€åçš„å€¼å°±æ˜¯ min(l[i-1] + r[i], r[0], l[n-1]).\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<int> l(n+1, 0);\n    vector<int> r(n+1, 0);\n\n    l[0] = S[0] == '1';\n    for (int i = 1; i < n; ++i)\n        l[i] = l[i-1] + (S[i] == '1');\n\n    r[n-1] = S[n-1] == '0';\n    for (int i = n-2; i >= 0; --i)\n        r[i] = r[i+1] + (S[i] == '0');\n\n    int res = r[0];\n    for (int i = 1; i <= n; i++)\n        res = std::min(l[i-1] + r[i], res);\n    return res;\n}\n```\n\n## è§£æ³•2\n\nå…¶å®è§£æ³•2å’Œè§£æ³•1è¿˜æ˜¯å¾ˆåƒçš„ï¼Œä½†æ˜¯æ˜¯æœ‰ä¸€ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„dp\\[n+1\\]\\[2\\]æ¥è®°å½•å‰é¢çš„çŠ¶æ€ã€‚dp[i][0]æ˜¯æˆ‘ä»¬å½“å‰æ•°å­—ä½œä¸º0ï¼Œéœ€è¦ç¿»è½¬çš„æœ€å°æ•°é‡ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒå‰é¢å‡ºç°çš„0æˆ–è€…1ï¼Œåªå…³å¿ƒå½“å‰æ•°å­—ï¼Œdp[i][1]åˆ™æ˜¯å½“å‰æ•°å­—ä½œä¸º1éœ€è¦ç¿»è½¬çš„æœ€å°æ•°é‡ã€‚\nå‡è®¾æˆ‘ä»¬èµ°åˆ°indexä¸ºiçš„æ•°å­—ï¼Œå¦‚æœè¿™ä¸ªæ•°å­—ä¸º0ï¼Œé‚£ä¹ˆ dp\\[i\\]\\[0\\]=dp[i-1][0]ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦flipçš„æ•°å­—æ•°é‡ä¸dp[i-1][0]æ˜¯ç›¸åŒçš„ï¼Œä¸éœ€è¦å†é¢å¤–flipã€‚å¦‚æœæ­¤æ—¶æ•°å­—ä¸º1ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1, ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå½“å‰çš„iä½œä¸º0å’Œ1çš„åˆ†ç•Œç‚¹ï¼Œä¹Ÿå°±æ˜¯<strong>æ¥ä¸‹æ¥æ‰€æœ‰1ä¸­çš„ç¬¬ä¸€ä¸ª1</strong>,æˆ–è€…å‰é¢å·²ç»å‡ºç°1ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™ä¸ª0flipæˆä¸º1ã€‚ä¹Ÿå°±æ˜¯+1ã€‚\nå½“æˆ‘ä»¬èµ°åˆ°ä¸º1çš„æ•°å­—ï¼ŒåŒæ ·indexæ˜¯iï¼Œé‚£ä¹ˆdp[i][0] = dp[i-1][0] + 1,æ˜¯æŒ‡å¦‚æœæˆ‘ä»¬éœ€è¦è¿™ä¸ªæ•°å­—ä¸º0ï¼Œé‚£ä¹ˆéœ€è¦å‰ä¸€ä¸ªä¸º0ï¼Œç„¶å+1æ¬¡flipã€‚dp[i][1] = min(dp[i-1][0], dp[i-1][1]), è¿™ä¸ªåŒæ ·æ˜¯æŒ‡æˆ‘ä»¬å°†è¿™ä¸ªæ•°å­—ä½œä¸ºåˆ†ç•Œç‚¹æˆ–è€…ç»§ç»­å½“1ï¼Œå–æœ€å°å€¼å³å¯ã€‚\nå½’çº³ä¸€ä¸‹çŠ¶æ€è½¬ç§»æ–¹ç¨‹:\n> if s[i] == '0': \n> \tdp[i][0] = dp[i-1][0]\n> \tdp[i][1] = min(dp[i-1][0]m dp[i-1][1]) + 1\n> else if s[i] == '1':\n> \tdp[i][0] = dp[i-1][0] + 1\n> \tdp[i][1] = min(dp[i-1][0], dp[i-1][1])\n\nå†ç²¾ç®€ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªåˆ†æ”¯å…¶å®æ˜¯æ¯”è¾ƒç›¸åƒçš„ï¼Œæ‰€ä»¥å¯ä»¥ç®€åŒ–ä¸ºï¼š\n> dp[i][0] = dp[i-1][0] + (s[i] == '1')\n> dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + (s[i] == '0')\n\nç„¶åä¸Šä»£ç ï¼š\n```cpp \nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    vector<vector<int>> dp(n+1, vector<int>(2));\n    dp[0][0] = S[0] == '1';\n    dp[0][1] = S[1] == '0';\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = dp[i - 1][0] + (S[i] == '1');\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + (S[i] == '0');\n    }\n    return min(dp[n][0], dp[n][1]);\n}\n```\n\n## è§£æ³•3 \n\nè§£æ³•3å…¶å®è¿˜æŒºå–å·§çš„ï¼Œä¹Ÿæ˜¯è§£æ³•2çš„è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥åœ¨è§£æ³•2ä¸­çœ‹åˆ°ï¼Œæ¯ä¸€æ­¥çš„çŠ¶æ€éƒ½åªä¸ä¸Šä¸€æ­¥çš„çŠ¶æ€æœ‰å…³ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥æŠŠç©ºé—´å¤æ‚åº¦ä»O(N)ä¼˜åŒ–åˆ°O(1)ï¼Œä¸å¤æ‚ï¼Œç›´æ¥ä¸Šä»£ç :\n\n```cpp\nint minFlipsMonoIncr(string S)\n{\n    int n = S.size();\n    int dp0 = S[0] == '1';\n    int dp1 = S[0] == '0';\n\n    for (int i = 1; i <= n; ++i) {\n        int tmp0 = dp0 + (S[i] == '1');\n        dp1 = min(dp0, dp1 + (S[i] == '0'));\n        dp0 = tmp0;\n    }\n    return min(dp0, dp1);\n}\n```\n\n","tags":["C++","Leetcode","dp"]},{"title":"Leetcode-39-CombinationSum","url":"/2019/11/07/Leetcode-39-CombinationSum/","content":"\n# Leetcode 39 Combination Sum\n\n## é¢˜ç›®\n\n> Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.\n>\n> The **same** repeated number may be chosen from `candidates` unlimited number of times.\n>\n> **Note:**\n>\n> - All numbers (including `target`) will be positive integers.\n> - The solution set must not contain duplicate combinations.\n>\n> **Example 1:**\n>\n> ```\n> Input: candidates = [2,3,6,7], target = 7,\n> A solution set is:\n> [\n>   [7],\n>   [2,2,3]\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: candidates = [2,3,5], target = 8,\n> A solution set is:\n> [\n>   [2,2,2,2],\n>   [2,3,3],\n>   [3,5]\n> ]\n> ```\n\n## é¢˜æ„ \n\nè¿™ä¸ªé¢˜å…¶å®å¾ˆä¹…ä¹‹å‰åˆ·è¿‡ï¼Œä½†æ˜¯ä»Šå¤©åˆåˆ·åˆ°äº†â€¦å°±åˆåšäº†ä¸€éï¼Œå› ä¸ºä¹‹å‰æ˜¯çœ‹çš„ç­”æ¡ˆï¼Œç°åœ¨åˆ·äº†ä¸€éï¼Œæœ‰ä¸€ä¸¢ä¸¢ä¸åŒï¼Œä½†æ˜¯æ€§èƒ½åè€Œæé«˜äº†å¾ˆå¤šã€‚\n\nè¿™é“é¢˜ç»™å®šä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªtargetï¼Œæ±‚æ•°ç»„ä¸­çš„å“ªäº›æ•°å­—ä¹‹å’Œæ˜¯targetï¼Œæ•°å­—<strong>å¯ä»¥é‡å¤ä½¿ç”¨</strong>ï¼Œæ‰€ä»¥æ€è·¯å½“ç„¶æ˜¯ç”¨dfså•¦ï¼ŒåŸæ¥çš„æ€è·¯æ˜¯æŠŠtargetä¼ åˆ°dfsé‡Œé¢ï¼Œæ¯æ¬¡åˆ°ä¸€ä¸ª æ–°æ•°å­—å°±æŠŠtargetå‡å»è¿™ä¸ªæ•°å­—ï¼Œæˆ‘è¿™æ¬¡ç›´æ¥æŠŠtargetå’Œsumä¸€èµ·ä¼ äº†è¿›å»ç„¶åè¿›è¡Œæ¯”è¾ƒï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆæ€§èƒ½ä¼šé«˜å¾ˆå¤šã€‚ã€‚ã€‚\n\n## Code\n\n```cpp\nvoid dfs(vector<int>& candidates, int sum, int index, int target, vector<vector<int>>& res, vector<int> tmp)\n{\n    if (sum == target) {\n        res.push_back(tmp);\n        return;\n    }\n    if (sum > target)\n        return;\n    int n = candidates.size();\n    for (int i = index; i < n; ++i) {\n        tmp.push_back(candidates[i]);\n        dfs(candidates, sum + candidates[i], i, target, res, tmp);\n        tmp.pop_back();\n    }\n}\n\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target)\n{\n    vector<vector<int>> res;\n    vector<int> tmp;\n    int n = candidates.size();\n    dfs(candidates, 0, 0, target, res, tmp);\n    return res;\n}\n```\n\nå¤§æ¦‚å°±æ˜¯è¿™ä¸ªæ€è·¯ï¼Œå¦‚æœåŠ åˆ°äº†targetï¼Œé‚£å°±æŠŠtmpå‹åˆ°resé‡Œé¢ï¼Œå¦åˆ™å°±æ ¹æ®å¤§å°åˆ¤æ–­ç»§ç»­dfs or returnã€‚\n\n> ä½†æ˜¯ï¼ï¼ï¼\n\næˆ‘å‘ç°äº†ä¸€ä¸ªæ€§èƒ½å¥½å¼ºçš„æ€è·¯ï¼Œæ¯”æˆ‘è¿™ä¸ªé«˜åˆ°ä¸çŸ¥é“å“ªé‡Œå»äº†ï¼Œå¤§æ¦‚æ„æ€æ˜¯ï¼Œç”¨ä¸€ä¸ªå’Œç»™å®šçš„æ•°ç»„ç›¸åŒå¤§å°çš„æ•°ç»„æ¥è®°å½•å½“å‰å“ªä¸ªindexè¢«åŠ å…¥åˆ°äº†sumé‡Œé¢å»ï¼Œå¦‚æœsumæ²¡è¶…ï¼Œå°±ç»§ç»­éå†ç»™å®šçš„æ•°ç»„ï¼Œè¶…äº†å°±æŠŠå½“å‰è¿™ä¸ªindexæ‰€æœ‰çš„æ•°å­—ç»™æ¸…ç©ºï¼Œå¦‚æœsumåˆšå¥½ç­‰äºtargetï¼Œé‚£ä¹ˆå°±æŠŠæ–°æ•°ç»„ä¸­æ‰€æœ‰indexå¯¹åº”çš„æ•°ç»„å†™å…¥åˆ°ç»“æœä¸­ã€‚\n\n## Code 2 \n\n```cpp\nvector<vector<int>> combinationSum(const vector<int>& n, int target) {\n    vector<int> factor(n.size());\n    vector<vector<int>> res;\n    int sum = 0;\n\n    do {\n        for (int i = 0; i < n.size(); i++) {\n            if (sum + n[i] <= target) {\n                sum += n[i];\n                factor[i] += 1;\n                break;\n            }\n            sum -= n[i] * factor[i];\n            factor[i] = 0;\n        }\n        if (sum == target) {\n            vector<int> tmp;\n            for (int i = 0; i < factor.size(); i++) {\n                for (int j = 0; j < factor[i]; j++)\n                    tmp.push_back(n[i]);\n            }\n            res.push_back(move(tmp));\n        }\n    } while (sum > 0);\n    return res;\n}\n```\n\n","tags":["C++","ç®—æ³•"]},{"title":"Leetcode-169-MajorityElement","url":"/2019/10/16/Leetcode-169-MajorityElement/","content":"\n# Leetcode 169 Majority Element\n\n\n\nä¸€é“æŒºç»å…¸çš„é¢˜ï¼Œè®°å½•ä¸‹ =  = \n\n## é¢˜ç›®\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `âŒŠ n/2 âŒ‹` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n## é¢˜æ„\n\nè¿™é“é¢˜æ„æ€æ˜¯è¯´ï¼Œç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œé•¿åº¦ä¸ºnï¼Œå…¶ä¸­æŸä¸ªæ•°å­—å‡ºç°çš„é¢‘ç‡å¤§äºn/2,æ±‚è¿™ä¸ªæ•°å­—ï¼Œè¿™ä¸ªé¢˜æˆ‘ä¸€å¼€å§‹æ‰“ç®—ç”¨brute force,ç›´æ¥æ’åºå–ä¸­ä½æ•°ï¼Œä¸€å®šæ˜¯è¿™ä¸ªé‡å¤ç‡æœ€é«˜çš„æ•°å­—ï¼Œå› ä¸ºé‡å¤è¶…è¿‡n/2äº†å˜›ã€‚ä½†æ˜¯æäº¤ä»¥åâ€¦æ•ˆç‡è¶…è¿‡äº†4%çš„ä»£ç å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼Œæ‰€ä»¥åˆåœ¨ç½‘ä¸Šæ‰¾äº†ä¸€ä¸ªæ•ˆç‡å¾ˆé«˜çš„å†™æ³•ã€‚\n\nè¿™ä¸ªæ•°å­—å‡ºç°é¢‘ç‡è¶…è¿‡å…¶å®ƒæ‰€æœ‰æ•°å­—ï¼Œé‚£æˆ‘ä»¬å°±éå†è¿™ä¸ªæ•°ç»„ï¼Œç»™å®šä¸€ä¸ªtmp = nums[0]ï¼Œéå†æ•°ç»„ï¼Œä¸‹ä¸€ä¸ªæ•°å­—å¦‚æœå’Œå½“å‰æ•°å­—ç›¸åŒï¼Œ å°±cnt++ï¼Œå¦åˆ™cnt-- ,ä¸€æ—¦cnt == 0,æˆ‘ä»¬å°±æŠŠtmpè¦†ç›–æˆä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå› ä¸ºå‡ºç°é¢‘ç‡å¤Ÿé«˜ï¼Œæœ€åtmpä¸€å®šå°±æ˜¯ç»“æœã€‚\n\n## Code\n\n```cpp\nint tmp, cnt = 0, n = nums.size();\n\n    for (int i = 0; i < n; ++i) {\n        if (cnt == 0)\n            tmp = nums[i];\n\n        if (nums[i] == tmp)\n            cnt++;\n        else\n            cnt--;\n    }\n    return tmp;\n```\n\n","tags":["C++"]},{"title":"nginxç¼–è¯‘ç¬”è®°","url":"/2019/10/07/nginxç¼–è¯‘ç¬”è®°/","content":"\n> æœ€è¿‘è¦å¼€å§‹å­¦ä¹ Nginxäº†ï¼Œè®°å½•ä¸‹ç¼–è¯‘çš„è¿‡ç¨‹\n\n\n\n# ç¯å¢ƒå‡†å¤‡\n\nå…ˆå®‰è£…äº†ä¸€ä¸ªè™šæ‹Ÿæœºï¼ŒVMWare Fusion 11.5 Proï¼Œç„¶åæäº†ä¸€ä¸ªCent OS isoé•œåƒï¼Œç¬¬ä¸€æ¬¡å®‰è£…çš„æ—¶å€™é€‰é”™äº†ï¼Œé€‰æˆæç®€ç‰ˆçš„äº†ï¼Œå®‰è£…ä¹Ÿæ²¡æœ‰GNomeæ¡Œé¢ = = ï¼Œé‡æ–°å®‰äº†ä¸€ä¸‹ä»¥åï¼Œè°ƒæ•´äº†IPV4ï¼Œå¯ä»¥æ­£å¸¸ä¸Šç½‘äº†ã€‚\n\næ ¹æ®ä¹¦ä¸­è®²çš„æŠ˜è…¾å‡ºæ¥çš„configureå‚æ•°ã€‚\n\n```\n./configure --with-openssl=/root/openssl-1.0.2f --with-libatomic --with-zlib=/root/zlib-1.2.11 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_stub_status_module --with-google_perftools_module --with-debug --with-pcre=/root/pcre-8.43 --add-module=/root/nginx/test_module/\n```\n\nä¸»è¦æ˜¯éœ€è¦æ‰‹åŠ¨ä¸‹è½½prceï¼Œopenssl,ä»¥åŠzlibçš„æºç ï¼Œä¸‹å¥½ä»¥åç›´æ¥äº¤å‰ç¼–è¯‘ï¼Œç„¶åmake -j4 && make install å¤§æ³• ç›®å‰å·²ç»ç¼–è¯‘å¥½äº†ã€‚\n\n# å¯åŠ¨ & å…³é—­Nginx\n\næœ€ç®€å•çš„å¯åŠ¨æ–¹å¼ï¼Œå¯ä»¥é€šè¿‡/usr/local/nginx/sbin/nginx è¿›è¡Œå¯åŠ¨ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®ï¼Œè¿˜å¯ä»¥æŒ‡å®šconfä»¥åŠæŒ‡å®šæŒ‡å®špidå†™å…¥çš„æ–‡ä»¶è·¯å¾„ç­‰ç­‰ã€‚\n\nå…³é—­çš„è¯å¯ä»¥ä½¿ç”¨/usr/local/nginx/sbin/nginx -s stop/quitä¸¤ç§ã€‚\n\n\n\n# ä½¿ç”¨è‡ªå·±çš„ç¬¬ä¸‰æ–¹æ’ä»¶\n\n","tags":["nginx"]},{"title":"Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays","url":"/2019/10/05/Leetcode-1031-MaxmiumSumOfTwoNon-overlapingSubarrays/","content":"\n# Leetcode 1031 Maxmium Sum of Two Non-overlapping Subarrays\n\n\n\n## é¢˜ç›®\n\nGiven an array `A` of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths `L` and `M`.  (For clarification, the `L`-length subarray could occur before or after the `M`-length subarray.)\n\nFormally, return the largest `V` for which `V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])` and either:\n\n- `0 <= i < i + L - 1 < j < j + M - 1 < A.length`, **or**\n- `0 <= j < j + M - 1 < i < i + L - 1 < A.length`.\n\n**Example 1:**\n\n```\nInput: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n```\n\n**Example 2:**\n\n```\nInput: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n```\n\n**Example 3:**\n\n```\nInput: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.\n```\n\n**Note:**\n\n1. `L >= 1`\n2. `M >= 1`\n3. `L + M <= A.length <= 1000`\n4. `0 <= A[i] <= 1000`\n\n\n\n## é¢˜æ„\n\nå¥½ä¹…æ²¡åˆ·é¢˜äº†ï¼Œçœ‹åˆ°è¿™ä¸ªé¢˜ä¸€ç‚¹å¤´ç»ªä¹Ÿæ²¡æœ‰ï¼Œç‰¹æ­¤è®°å½•ä¸€ä¸‹ï¼Œ<strong>ä»¥åæ¶‰åŠåˆ°è¿™ç§æ±‚å­æ•°ç»„æœ€å¤§å’Œçš„é¢˜ç›®ï¼Œä¼˜å…ˆä½¿ç”¨å‰ç¼€å’Œ</strong>ã€‚\n\nè¿™é“é¢˜ç¿»è¯‘ä¸‹ï¼Œç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œä»¥åŠä¸¤ä¸ªæ•´æ•°L&Mï¼Œè¿”å›ä¸¤ä¸ªå­—æ•°ç»„ä¹‹å’Œï¼Œè¦æ±‚ä¸ºæœ€å¤§å€¼ï¼Œä¸”ä¸¤ä¸ªå­—æ•°ç»„çš„é•¿åº¦åˆ†åˆ«ä¸ºL Mã€‚æ‰€ä»¥è¿™ä¸ªé¢˜æˆ‘ä»¬éœ€è¦éå†ä¸¤æ¬¡ï¼Œé¦–å…ˆæ˜¯ç”¨ä¸€ä¸ªæ•°ç»„è®°å½•è¯¥æ•°ç»„çš„å‰ç¼€å’Œï¼Œç„¶åé€šè¿‡åŠ¨æ€è§„åˆ’æ¥æ±‚çš„éœ€è¦çš„å€¼ã€‚\n\nå¦‚ä½•è¿›è¡ŒåŠ¨æ€è§„åˆ’ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªå˜é‡max_l & max_m, åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªå­—æ•°ç»„å„è‡ªçš„æœ€å¤§å’Œï¼Œç„¶åæ­¤æ—¶ä¼šæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯Låœ¨å·¦ï¼ŒMåœ¨å³ï¼Œå¦ä¸€ç§ç›¸åã€‚å‡è®¾æ­¤æ—¶éå†åˆ°indexä¸ºiçš„æ•°å­—ï¼Œæˆ‘ä»¬çš„è¿”å›å€¼å¯èƒ½ä¼šæœ‰ä¸¤ç§ï¼Œä¸€ç§ä¸ºæƒ…å†µ1ï¼Œå¦ä¸€ç§ä¸ºæƒ…å†µ2ï¼Œå¦‚å›¾æ‰€ç¤ºï¼ˆæš‚æ—¶æ— å›¾ = = ï¼‰ï¼Œæˆ‘ä»¬åªéœ€è¦ç®—å‡ºæœ€å¤§å€¼ï¼Œç„¶åèµ‹å€¼ç»™resultå°±å¯ä»¥äº†ã€‚\n\nä½†æ˜¯ç®—å‡ºæœ€å¤§å€¼ä¹‹å‰æˆ‘ä»¬æ˜¯éœ€è¦æ›´æ–°å½“å‰çš„max_l & max_mï¼Œè‡³äºæ›´æ–°çš„èŒƒå›´ï¼Œæ¯”å¦‚æˆ‘ä»¬éœ€è¦æ›´æ–°max_l, æ­¤æ—¶æˆ‘ä»¬ä»¥å‰i - Mä¸ªæ•°ä¸­æœ€å¤§çš„é•¿åº¦ä¸ºLçš„å­åºåˆ—ä¹‹å’Œä¸ºmax_lï¼Œæ‰€ä»¥max_l = max(max_l, pre_sum[i - M] - pre_sum[i - L - M]),max_mä¹Ÿæ˜¯ç›¸åŒçš„æ–¹æ³•æ¥æ›´æ–°ã€‚\n\n## Code\n\n```cpp\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M)\n{\n    int n = A.size();\n    vector<int>& pre_sum = A;\n\n    for (int i = 1; i < n; ++i) {\n        pre_sum[i] = pre_sum[i-1] + A[i];\n    }\n\n    int res = pre_sum[L + M - 1];\n    int max_l = pre_sum[l-1];\n    int max_m = pre_sum[m-1];\n    for (int i = L + M; i < n; ++i) {\n        max_l = max(max_l, pre_sum[i - M] - pre_sum[i - M - L]);\n        max_m = max(max_m, pre_sum[i - L] - pre_sum[i - M - L]);\n        res = max(res, max(max_l + pre_sum[i] - pre_sum[i-M], max_m + pre_sum[i] - pre_sum[i-L]));\n    }\n\n    return res;\n}\n```\n\n","tags":["C++"]},{"title":"Leetcode-1074-NumbersToSubmatricesThatSumToTarget","url":"/2019/09/17/Leetcode-1074-NumbersToSubmatricesThatSumToTarget/","content":"\nLeetcode 1074 Numbers To Submatrices That Sum To Target\n\nä¸€é“Leetcode Hard çº§åˆ«çš„é¢˜ç›® ï¼Œç”¨äº†ä¸€æ™šæ¥ç†è§£ï¼Œç‰¹æ­¤è®°å½•ã€‚\n\n# é¢˜ç›®\n\n> Given a `matrix`, and a `target`, return the number of non-empty submatrices that sum to target.\n>\n> A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.\n>\n> Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.\n>\n>  \n>\n> **Example 1:**\n>\n> ```\n> Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n> Output: 4\n> Explanation: The four 1x1 submatrices that only contain 0.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: matrix = [[1,-1],[-1,1]], target = 0\n> Output: 5\n> Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n> ```\n\n# é¢˜è§£\n\nè¿™é“é¢˜æ„æ€æ˜¯è¯´ï¼Œç»™å®šä¸€ä¸ªçŸ©é˜µmatrixï¼Œä»¥åŠä¸€ä¸ªtargetï¼Œä¸ºintç±»å‹ï¼Œéœ€è¦ä½ æ±‚å‡ºæ‰€æœ‰çš„submatrixä¸­å’Œä¸ºtargetçš„æ•°é‡ï¼Œè¿™ä¸ªé¢˜ä¹ä¸€çœ‹ä¼šå¾ˆå¤æ‚ï¼Œç”¨æœ€ç®€å•çš„brute forceæ˜¯å¯ä»¥æ±‚å‡ºæ¥çš„ï¼Œå¤æ‚åº¦ä¸ºO(N^4)mï¼Œè¿™ä¸ªå¤æ‚åº¦å…¶å®è¿˜æŒºéš¾æ¥å—çš„ = = ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰äº†å¦‚ä¸‹è§£æ³•ï¼š\n\næˆ‘ä»¬å…ˆæ±‚prefixSumï¼Œå¯ä»¥æŒ‰è¡Œä¹Ÿå¯ä»¥æŒ‰ç…§åˆ—ï¼Œæˆ‘é‡‡ç”¨çš„æ–¹æ³•æ˜¯æŒ‰è¡Œæ±‚ï¼Œç„¶åæˆ‘ä»¬å†å›ºå®šä¸€ä¸ªlå’Œä¸€ä¸ªræŒ‡é’ˆï¼Œç”¨æ¥è¡¨ç¤ºsubmatrixçš„å·¦å³ä¸¤è¾¹ï¼Œå¦é€šè¿‡ä¸€ä¸ªkæ¥ä»ä¸Šè€Œä¸‹çš„éå†æ•´åˆ—ï¼Œæ±‚å¾—ä¸€ä¸ªsumï¼Œå°†è¿™ä¸ªsumè®°å½•åœ¨æˆ‘ä»¬çš„unordered_mapä¸­ï¼Œå¹¶ä¸”ï¼Œæˆ‘ä»¬é€šè¿‡sum - targetå°±å¯ä»¥å¾—åˆ°ä»¥kä¸ºåº•çº¿ï¼Œsubmatrixçš„sumä¸ºtargetçš„æ•°é‡ã€‚å› ä¸ºè¿™ä¸ªsumå…¶å®æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªä»ä¸Šè‡³ä¸‹å åŠ çš„å’Œï¼Œæ‰€ä»¥æˆ‘ä»¬å‡å»targetå¾—åˆ°çš„å€¼ï¼Œå…¶å®æ˜¯ä¸€ä¸ªä¸Šé™çš„æ•°é‡ï¼Œåˆšå¥½ä¸kï¼Œä»¥åŠlå’Œrå›´æˆäº†ä¸€ä¸ªsubmatrixã€‚\n\n\n\n# Code \n\n```cpp\nint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target)\n{\n    int n = matrix.size(), m = matrix[0].size();\n    int ans = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 1; j < m; j++)\n            matrix[i][j] += matrix[i][j - 1];\n\n    for (int l = 0; l < m; l++)\n        for (int r = l; r < m; r++) {\n            unordered_map<int, int> vis;\n            vis[0] = 1;\n            int tot = 0;\n            for (int k = 0; k < n; k++) {\n                if (l == 0) {\n                    tot += matrix[k][r];\n                } else {\n                    tot += matrix[k][r] - matrix[k][l - 1];\n                }\n                if (vis.find(tot - target) != vis.end())\n                    ans += vis[tot - target];\n                vis[tot]++;\n            }\n        }\n    return ans;\n}\n```","tags":["C++","Leetcode"]},{"title":"Leetcode-1122-RelativeSortArray","url":"/2019/09/04/Leetcode-1122-RelativeSortArray/","content":"\nLeetcode 1122 Relative Sort Array\n\nè¿™ä¸ªé¢˜è™½ç„¶æ˜¯easyçº§åˆ«çš„é¢˜ç›®ï¼Œä½†æ˜¯è¿™ä¸ªè§£æ³•æŒºé«˜æ˜çš„ï¼Œè€Œä¸”åœ¨Leetcodeä¸Šæ—¶é—´å’Œç©ºé—´éƒ½è¶…è¿‡äº†100%çš„æäº¤ï¼Œç‰¹æ­¤è®°å½•ä¸‹ã€‚\n\n# é¢˜ç›®\n\n> Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n>\n> Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`.  Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.\n\n# é¢˜è§£\n\nç»™å®šä¸¤ä¸ªæ•°ç»„arr1ä»¥åŠarr2ï¼Œå…¶ä¸­arr2çš„æ•°å­—æ˜¯distinctçš„ï¼Œæ•°å­—1çš„ä¼šæœ‰é‡å¤ï¼Œéœ€è¦æˆ‘ä»¬å°†arr1ä¸­çš„æ•°å­—sortæˆarr2ä¸­çš„é¡ºåºï¼Œè€Œä¸”å¯¹äºarr2ä¸­ä¸å­˜åœ¨çš„æ•°å­—ï¼Œéœ€è¦å°†å…¶æŒ‰å‡åºæ’åˆ—ã€‚\n\nä¸¾ä¸ªğŸŒ°ï¼š\n\n```\nInput: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]\n```\n\næœ¬é¢˜ä¸­çš„è§£æ³•ä½¿ç”¨çš„æ˜¯ï¼šé€šè¿‡ä¸€ä¸ªè‡ªå®šä¹‰sort()å‡½æ•°çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œå³ä¸€ä¸ªfunction/functorï¼Œæ¥å¯¹arr1è¿›è¡Œsortï¼Œå› ä¸ºarr2ä¸­çš„å˜é‡æ˜¯ä¸ä¼šé‡å¤çš„ï¼Œæˆ‘ä»¬å°†arr2ä¸­çš„å˜é‡çš„indexä½œä¸ºæ’åºçš„ä¾æ®ã€‚å³ï¼šå¯¹äºarr1ä»¥åŠarr2ä¸­å­˜åœ¨çš„æ•°å­—ï¼Œæ’åºçš„ä¾æ®æ˜¯arr2ä¸­å˜é‡çš„indexï¼Œå¯¹äºarr1ä¸­å­˜åœ¨ï¼Œarr2ä¸­ä¸å­˜åœ¨çš„æ•°å­—ï¼Œæˆ‘ä»¬æ ¹æ®å…¶æœ¬èº«å¤§å°è¿›è¡Œæ’åºã€‚å¦‚æœarr1ä¸­ä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªåœ¨arr2ä¸­å­˜åœ¨ï¼Œç¬¬äºŒä¸ªä¸å­˜åœ¨ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªåº”è¯¥æ’åœ¨ç¬¬äºŒä¸ªå‰é¢ï¼Œå¦åˆ™å°±æ˜¯åé¢ã€‚ç›´æ¥ä¸Šä»£ç äº†ã€‚\n\n# Code\n\n```cpp\n#include <vector>\n\nusing std::vector;\n\nvector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2)\n{\n    int max = 0;\n    for (auto i : arr2)\n        if (i > max)\n            max = i;\n\n    vector<int> order(max+1, -1);\n\n    int n = arr2.size();\n    for (int i = 0; i < n; i++)\n        order[arr2[i]] = i;\n\n    n = (int)order.size();\n    auto cmp = [&order, &n](const int a, const int b) -> bool\n    {\n        bool contain_a = false, contain_b = false;\n        if (a < n && order[a] != -1)\n            contain_a = true;\n        if (b < n && order[b] != -1)\n            contain_b = true;\n\n        if (contain_a && contain_b)\n            return order[a] < order[b];\n        else if (!contain_a && !contain_b)\n            return a < b;\n        else if (contain_a)\n            return true;\n        else\n            return false;\n    };\n\n    sort(arr1.begin(), arr1.end(), cmp);\n    return arr1;\n}\n```\n\n\n\n-------\n\nåˆæ°´äº†ä¸€é“é¢˜ï¼Œå¿«ä¹;D","tags":["C++","Leetcode"]},{"title":"Leetcode-845-LongestMountainInArray","url":"/2019/08/24/Leetcode-845-LongestMountainInArray/","content":"\nLeetcode 845 LongestMountainInArray\n\n# é¢˜æ„\n\nLet's call any (contiguous) subarray B (of A) a *mountain* if the following properties hold:\n\n- `B.length >= 3`\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\n\n(Note that B could be any subarray of A, including the entire array A.)\n\nGiven an array `A` of integers, return the length of the longest *mountain*. \n\nReturn `0` if there is no mountain.\n\n#First Version\n\n## é¢˜è§£\n\nè¿™ä¸ªé¢˜å®šä¹‰äº†ä¸€ç§Mountain,å³å½“å‰subarrayçš„æ•°å­—å…ˆé€’å¢åé€’å‡ï¼Œæ±‚æœ€é•¿çš„Mountainå­åºåˆ—çš„é•¿åº¦ã€‚è¿™ä¸ªé¢˜æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªupå’Œdownæ•°ç»„æ¥å­˜å‚¨éå†çš„å€¼ï¼Œup[i]è¡¨ç¤ºæ•°ç»„ä¸­ç¬¬iä¸ªä½ç½®çš„å€¼æ˜¯å½“å‰é€’å¢åºåˆ—çš„ç¬¬å‡ ä¸ªï¼Œdownçš„æ„æ€ä¹Ÿæ˜¯,down[i]è¡¨ç¤ºæ•°ç»„çš„ç¬¬iä¸ªå€¼æ˜¯å½“å‰é€’å‡åºåˆ—çš„ç¬¬å‡ ä¸ªï¼ˆä»n-2å¼€å§‹ï¼‰ï¼Œç„¶åéå†ä¸¤ä¸ªæ•°ç»„ï¼Œå½“up[i]å’Œdown[i]åŒæ—¶ä¸ºæ­£çš„æ—¶å€™ï¼Œé€šè¿‡up[i] + down[i] + 1å°±å¯ä»¥å¾—å‡ºå±±å³°çš„length.\n\n## Code\n\n```cpp\nint longestMountain(vector<int>& A)\n{\n    if (A.size() == 0)\n        return 0;\n\n    int n = A.size();\n    int len = INT_MIN;\n    vector<int> up(n, 0);\n    vector<int> down(n, 0);\n\n    for (int i = n-2; i >= 0; --i)\n        if (A[i] > A[i+1])\n            down[i] = down[i+1] + 1;\n\n    for (int i = 1; i < n; i++)\n    {\n        if (A[i] > A[i-1])\n            up[i] = up[i-1] + 1;\n\n        if (up[i] > 0 && down[i] > 0)\n            len = max(len, down[i] + up[i] + 1);\n    }\n    return len;\n}\n```\n\n-------\n\n# Anthor Version\n\n\n\n","tags":["C++"],"categories":["ç®—æ³•"]},{"title":"SlideWindowæ¨¡æ¿","url":"/2019/08/24/SlideWindowæ¨¡æ¿/","content":"\n# Slide Windowæ¨¡æ¿\n\nSlideWindowç±»å‹çš„é¢˜åˆ·äº†å¾ˆå¤šäº†ï¼Œæ€»ç»“ä¸€ä¸ªæ¨¡æ¿å‡ºæ¥\n\né¦–å…ˆï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆl,rè¡¨ç¤ºå·¦å³è¾¹ç•Œï¼Œl = 0, r = 0ã€‚é€šè¿‡è¿™ä¸ªl ræ¥è¡¨ç¤ºä¸€ä¸ª<strong>å·¦å¼€å³é—­åŒºé—´</strong>, å³[l, r)ã€‚\n\nç„¶ååœ¨ä¸€ä¸ªå¾ªç¯ä¸­éå†æ•´ä¸ªæ•°ç»„ï¼Œç»ˆç»“æ¡ä»¶ä¸º r == array.size(), æ¯æ¬¡å¾ªç¯åšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯, sum += array[r++],ç„¶åå¯¹sumçš„å€¼è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ²¡æœ‰è¾¾åˆ°éœ€è¦çš„conditionå°±continueï¼Œå¦åˆ™è¿›è¡Œåˆ¤æ–­ï¼Œä½†æ˜¯è¿™è¾¹ä¸€ä¸ªå®¹æ˜“è¢«å¿½ç•¥è¿‡å»çš„åœ°æ–¹ï¼Œå³låˆ°rçš„èŒƒå›´ä¸­ï¼Œå¦‚æœr-1ä½ç›®æ ‡å€¼ï¼Œå…¶ä¸­ï¼Œ[l,r-1]åŒºé—´ä¸­æœ‰å¯èƒ½è¿˜æœ‰æˆ‘ä»¬éœ€è¦çš„ç»“æœï¼Œæ‰€ä»¥æˆ‘ä»¬å†æ¥å°†[l,r-1]åŒºé—´ä¸­çš„å€¼è¿›è¡Œéå†ã€‚ï¼ˆè¿™æ­¥å¯ä»¥ç†è§£ä¸ºï¼Œä»¥æ•°ç»„ä¸­æ¯ä¸€ä¸ªå€¼ä½œä¸ºsubarrayçš„æœ€åä¸€ä¸ªå€¼ï¼Œåˆ¤æ–­å½“å‰subarrayæ˜¯å¦ç¬¦åˆéœ€æ±‚)\n\næœ€åä¸€ä¸ªå®¹æ˜“å¿½ç•¥çš„åœ°æ–¹ï¼Œå½“å¾ªç¯ç»“æŸåï¼Œæˆ‘ä»¬ä»æœ‰[l,r-1]åŒºé—´çš„å€¼æœªéå†ï¼Œå…¶ä¸­æœ‰å¯èƒ½å‡ºç°æˆ‘ä»¬éœ€è¦çš„ç»“æœ,æ‰€ä»¥æœ€åä¸€ä¸ªæ‰«å°¾ï¼ŒæŠŠè¿™æ®µå€¼å¤„ç†ä¸‹å°±å¯ä»¥äº†ã€‚\n\n\n\n## code\n\n```cpp\ntemplate <typename T>\nint SlideWindow(vector<T>& array, T target)\n{\n  if (array.size() == 0)\n    return;\n  \n  int l = 0;\n  int r = 0;\n \tint sum = array[0];\n  int ans = 0;\n  \n  //å·¦å¼€å³é—­åŒºé—´ï¼Œæ±‚é•¿åº¦å¯ç›´æ¥é€šè¿‡ r - l å¾—åˆ°\n  while (r < array.size())\n  {\n    sum += array[r++];\n    \n    if (sum < target)\n      continue;\n    else if (sum == target)\n    \tans++;\n   \telse\n    {\n      while (sum > target && l < r)\n      {\n        sum -= array[l++];\n        if (sum == target)\n          ans++;\n      }\n    }\n  }\n  \n  // æ‰«å°¾\n  while (sum > target && l < r)\n  {\n    sum -= array[l++];\n    if (sum == target)\n\t\t\tans++;\n  }\n  \n  return ans;\n}\n```\n\n","tags":["C++"],"categories":["ç®—æ³•"]},{"title":"Leetcode-234-PalindromeLinkedList","url":"/2019/08/18/Leetcode-234-PalindromeLinkedList/","content":"\nLeetcode 234 Palindrome Linked List\n\nåˆ·é“æ°´é¢˜  = = \n\næˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºå•¥è¿™é¢˜çš„é€šè¿‡ç‡æ¯”hardçš„çº§åˆ«çš„é€šè¿‡ç‡éƒ½ä½â€¦æˆ‘å¯»æ€å¯èƒ½æ˜¯è¿™ä¸ªè¾¹ç•Œå¤„ç†æ¯”è¾ƒå¤æ‚ï¼Ÿç›´æ¥çœ‹é¢˜8.\n\n\n\n# é¢˜ç›®\n\nGiven a singly linked list, determine if it is a palindrome.\n\n**Example 1:**\n\n```\nInput: 1->2\nOutput: false\n```\n\n**Example 2:**\n\n```\nInput: 1->2->2->1\nOutput: true\n```\n\n**Follow up:**\nCould you do it in O(n) time and O(1) space?\n\n# é¢˜æ„\n\nå…¶å®å°±æ˜¯æœ€åŸºæœ¬çš„å•é“¾è¡¨é—®é¢˜ï¼Œé—®ä½ ç»™å®šçš„é“¾è¡¨æ˜¯å¦æ˜¯ä¸€ä¸ªå›æ–‡é“¾è¡¨ï¼Œæˆ‘å¯»æ€è¿™ä¸ªé¢˜å…¶å®ä¸€å¼€å§‹åœ¨åˆ·ç‰›å®¢çš„é“¾è¡¨é¢˜çš„æ—¶å€™å°±æœ‰è¿‡äº†ã€‚åŸºæœ¬æ€è·¯è¿˜æ˜¯å¾ˆæ¸…æ™°ï¼Œæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œç„¶åå°†é“¾è¡¨ååŠéƒ¨åˆ†å€’è½¬ï¼Œä»ä¸¤è¾¹çš„headeråˆ†åˆ«éå†ï¼Œæœ€åçœ‹ç»è¿‡çš„è·¯ä¸Šçš„å€¼æ˜¯å¦ä¸€è‡´å°±å¯ä»¥äº†ã€‚\n\nè¿˜æœ‰å°±æ˜¯ï¼Œæˆ‘ä»¬æ²¡å¿…è¦å…³å¿ƒè¿™ä¸ªé“¾è¡¨çš„é•¿åº¦æ˜¯å¥‡æ•°æˆ–è€…å¶æ•°ï¼Œå› ä¸ºå³ä½¿åˆ†å¼€ä¸¤ä¸ªé“¾è¡¨é•¿åº¦ç›¸å·®1ï¼Œæˆ‘ä»¬åªéœ€è¦éå†å‰é¢ç›¸åŒçš„å°±å¯ä»¥äº†ã€‚\n\næœ€ä¸»è¦çš„åœ°æ–¹è¿˜æ˜¯ï¼Œä¸€å¼€å§‹æ‰¾ä¸­ç‚¹çš„æ—¶å€™ï¼Œéœ€è¦ä¸€ä¸ªå¿«æ…¢æŒ‡é’ˆï¼Œå½“å¿«æŒ‡é’ˆçš„nextä»¥åŠnext->nextæœ‰ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬ä¾¿è®¤ä¸ºåˆ°è¾¾äº†slowæŒ‡é’ˆåˆ°è¾¾äº†ä¸­ç‚¹ï¼Œå› ä¸ºæ²¡æ³•ç»§ç»­å¾€ä¸‹èµ°äº†ã€‚ç„¶åæ˜¯reverse liståŸºæœ¬æ“ä½œï¼Œä½†ä¸è¦å¿˜è®°å°†slowæŒ‡é’ˆçš„nextç½®ä¸ºnullptr(C++11 ä¸è¦åƒä¸‹é¢çš„ä»£ç ä¸€æ ·å†™NULL).\n\n\n\n# Code\n\n```cpp\nbool isPalindrome(ListNode *head) {\n    if (head == NULL || head->next == NULL)\n        return true;\n\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    /* find middle point */\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    /* reverse half the list */\n    ListNode *cur = slow->next;\n    ListNode *next = cur->next;\n    ListNode *tmp = NULL;\n    cur->next = NULL;\n\n    /* break the list */\n    slow->next = NULL;\n\n    while (next != NULL) {\n        tmp = next->next;\n        next->next = cur;\n        cur = next;\n        next = tmp;\n    }\n\n    /* It doesn't matter the length of the list is odd or even,\n     * because these two pointers will come to an end */\n    while (head && cur) {\n        if (head->val != cur->val)\n            return false;\n        head = head->next;\n        cur = cur->next;\n    }\n\n    return true;\n}\n```\n\n\n\nDone. \n\nä»Šæ—¥ä»½çš„æ°´é¢˜ã€‚","tags":["C++","Leetcode"]},{"title":"å³å€¼å¼•ç”¨","url":"/2019/08/13/å³å€¼å¼•ç”¨/","content":"\n\n> å¾ˆä¹…ä¹‹å‰çœ‹çš„å·¦å€¼ä¸å³å€¼å¼•ç”¨è¿™ç±»çš„ä¸œè¥¿ï¼Œä½†æ˜¯ç°åœ¨å·²ç»è®°ä¸æ¸…æ¥šæ¦‚å¿µï¼Œæ‰€ä»¥é‡æ–°å†™ç¯‡åšå®¢æ¥è®°å½•æ•´ç†ä¸€ä¸‹ã€‚\n\n---------------------------------\n\n# å·¦å€¼ä¸å³å€¼\n\nå·¦å€¼ä¸å³å€¼åœ¨Cè¯­è¨€ä¸­å°±æœ‰å‡ºç°ï¼Œ<strong>\"lvalue\"</strong>ä¸<strong>\"rvalue\"</strong>ï¼Œå­—é¢ä¸Šlå’Œrä¸ºleftå’Œrightï¼Œå…¶å®æˆ‘æ›´æ„¿æ„æŠŠå®ƒä»¬ç†è§£locationä¸readï¼Œä¸€ä¸ªæ˜¯åœ¨å†…å­˜ä¸­æœ‰æ˜ç¡®çš„åœ°å€ï¼Œæœ‰ä¸€ä¸ªå±äºè‡ªå·±çš„\"ååˆ†\"ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯åªèƒ½è¢«read ï¼ˆliterallyï¼‰ï¼Œ æ‰€ä»¥ä¸¤ä¸ªçš„åŒºåˆ«å…¶å®å·²ç»ä¸€ç›®äº†ç„¶ã€‚åœ¨ä»£ç ä¸­è¡¨ç°å‡ºæ¥åˆ™æ˜¯è¿™ä¸ªæ ·å­ã€‚\n\n```cpp\nint i = 0; // i æ˜¯å·¦å€¼ï¼Œåœ¨æ ˆä¸Šæœ‰åœ°å€ï¼Œ0æ˜¯å³å€¼\n\nint dummy(20);\nint mummy(30);\n\nint foo = dummy;  \t//fooæ˜¯å·¦å€¼\nfoo = dummy * mummy; // dummy * mummyæ˜¯å³å€¼\n```\n\nåœ¨åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å·¦å€¼è¿˜æ˜¯å³å€¼æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘ï¼Œè¿™ä¸ªå€¼æ˜¯å¦<strong>çœŸå®å­˜åœ¨</strong>ã€‚å¦‚æœä½œä¸ºä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™ä¸ªå€¼åœ¨å†…å­˜ä¸­å…¶å®å¹¶ä¸å­˜åœ¨ï¼Œæ‰€ä»¥æ˜¯å³å€¼ã€‚\n\n\n# å·¦å€¼å¼•ç”¨ä¸å³å€¼å¼•ç”¨\n\nè¿™ä¸¤ä¸ªä¹Ÿå¾ˆå¥½ç†è§£ï¼Œé¡¾åæ€ä¹‰ï¼Œå·¦å€¼å¼•ç”¨å°±æ˜¯å¯¹å·¦å€¼çš„å¼•ç”¨ï¼Œç”¨&è¡¨ç¤ºï¼Œå³å€¼å¼•ç”¨åˆ™æ˜¯å¯¹å³å€¼çš„å¼•ç”¨ï¼Œé€šè¿‡&&æ¥è¡¨ç¤ºã€‚\n\n```cpp\nint foo = 50;\nint app = 60;\n\nint &dummy = foo; // dummyæ˜¯å·¦å€¼å¼•ç”¨\nint &&rdummy = 30; // 30æ˜¯å³å€¼ rdummyæ˜¯å³å€¼å¼•ç”¨\n\nconst int &ra = a; // const å·¦å€¼å¼•ç”¨\nconst int &&rra = 30; // const å³å€¼å¼•ç”¨\n\n// ä¸€ç§ç‰¹æ®Šæƒ…å†µ \nconst int &ra = 30;  // const å·¦å€¼å¼•ç”¨ç»‘å®šåœ¨ä¸€ä¸ªå³å€¼ä¸Šï¼Œå› ä¸ºè¿™ä¸ªå€¼ä¸èƒ½ä¿®æ”¹ã€‚\n```\n\nå³å€¼å¼•ç”¨åªèƒ½ç»‘å®šåœ¨å³å€¼ä¸Šï¼Œæ‰€ä»¥èµ„æºè¦ä¹ˆæ˜¯ç«‹åˆ»è¢«é”€æ¯ï¼Œæˆ–è€…åªæ˜¯ä¸€ä¸ªå­—é¢å¸¸é‡ï¼Œè¿™å°±æ„å‘³ç€å¯¹å³å€¼è¿›è¡Œå¼•ç”¨åå¯ä»¥æ¥ç®¡è¿™ä¸ªå³å€¼çš„æ‰€æœ‰å¹¶éšæ„ä¿®æ”¹ï¼Œè€Œä¸ç”¨æ‹…å¿ƒä¼šé€ æˆä»€ä¹ˆå¥‡æ€ªçš„å½±å“ã€‚å¯ä»¥è¯´æ˜¯ä¸€ä¸ªå¾ˆæ–¹ä¾¿çš„ç‰¹æ€§äº†ã€‚\n\n# å¼•ç”¨çš„å€¼ç±»å‹ä¸å¼•ç”¨å åŠ \n\n## å€¼ç±»å‹\n\næˆ‘ä»¬å…ˆæ¥çœ‹å·¦å€¼å¼•ç”¨ä¸å³å€¼å¼•ç”¨æœ¬èº«æ˜¯å·¦å€¼è¿˜æ˜¯å³å€¼å‘¢ï¼Ÿ\n\n```cpp\nint foo(40);\n\nint &lfoo = foo;\nint &dummy = lfoo;  \t//å°†ä¸€ä¸ªå·¦å€¼å¼•ç”¨ä½œä¸ºå³å€¼èµ‹å€¼ç»™dummy\n\nint &du = ++foo;  \t//å°†å‰ç½®è‡ªå¢çš„++è¿”å›çš„å·¦å€¼ä½œä¸ºå³å€¼èµ‹å€¼ç»™du\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå·¦å€¼æˆ–è€…å·¦å€¼å¼•ç”¨éƒ½å¯ä»¥ä½œä¸ºå³å€¼èµ‹å€¼ç»™åˆ«çš„å˜é‡ï¼Œæ›´ä»”ç»†çš„è¯´ï¼Œä¸€ä¸ªå·¦å€¼ï¼Œä½œä¸ºä¸€ä¸ªå˜é‡è¢«ä¿å­˜ä¸‹æ¥ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªå·¦å€¼ï¼Œå¦‚æœåªæ˜¯è¢«å½“æˆä¸€ä¸ªå³å€¼ç”¨æ¥èµ‹å€¼ï¼Œé‚£ä¹ˆç”Ÿå‘½å‘¨æœŸä¸ä¸€ä¸ªå³å€¼ä¸€æ ·çŸ­æš‚ã€‚\n\nåŒæ ·çš„ï¼Œä¸€ä¸ªå³å€¼è¢«è¿”å›åè¢«å­˜å‚¨åœ¨ä¸€ä¸ªå˜é‡ä¸­ï¼Œé‚£å°±åº”è¯¥è¢«å½“æˆä¸€ä¸ªå·¦å€¼æ¥å¯¹å¾…ï¼Œå¦åˆ™å°±æ˜¯ä¸€ä¸ªå³å€¼ã€‚\n\n## å¼•ç”¨å åŠ \n\n```cpp\n\ntypedef int& intR;\ntypedef intR& intRR;\n\nint main()\n{\n\tint dummy(10);\n\tintR i = dummy;  \n\tintRR rri = i;\n}\n\n```\n\nåœ¨è¿™é‡Œé¢ï¼ŒintRå…¶å®æ˜¯ä¸€ä¸ªint &, ä½†æ˜¯intRR å…¶å®åº”è¯¥æ˜¯int& &,è¡¨ç¤ºçš„æ˜¯å¯¹ä¸€ä¸ªintç±»å‹å¼•ç”¨çš„å¼•ç”¨ï¼Œè¿™ä¸ªå…¶å®å°±æ˜¯C++çš„å¼•ç”¨å åŠ ï¼Œæœ‰å¦‚ä¸‹è§„åˆ™ã€‚\n\n```cpp\nType& & = Type&;\nType& && = Type&;\nType&& & = Type&;\nType&& && = Type&&;\n```\n\nè¿™å°±æ˜¯C++å¼•ç”¨çš„å åŠ ã€‚æœ‰ç‚¹åƒ0ä¸1æ±‚&ï¼Œåªè¦æœ‰å·¦å€¼å¼•ç”¨é‚£ä¹ˆæœ€åå åŠ ä»¥åä¸€å®šä¼šæ˜¯ä¸€ä¸ªå·¦å€¼ã€‚\n\n#   å³å€¼å¼•ç”¨ä½¿ç”¨åœºæ™¯\n\næ‰€è°“çš„å³å€¼å¼•ç”¨å¯ä»¥åº”ç”¨åœ¨ä»€ä¹ˆåœ°æ–¹å‘¢ï¼Ÿ\n\n## moveè¯­ä¹‰\n\nå…ˆæ¥çœ‹ä¸€æ®µä»£ç ã€‚\t\n\n```cpp\n\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n}\n\n```\n\nä½†æ˜¯å®é™…åº”ç”¨çš„æ—¶å€™ä¼šå‘ç°ï¼Œç®€å•çš„å‡ æ®µä»£ç è°ƒç”¨çš„å‡½æ•°åˆ†åˆ«æœ‰ï¼š\n\n> Trivial Constructor\n> explicit Constructor\n> operator =\n> Destructor\n> Destructor\n\næœ¬æ¬¡çš„è°ƒç”¨è¿‡ç¨‹åˆ†åˆ«æœ‰ï¼šé¦–å…ˆè°ƒç”¨Trivial Constructorï¼Œå¯¹dummy1è¿›è¡Œconstructï¼Œç„¶åè¿›å…¥åˆ°get(),è°ƒç”¨explicit Constructorå¯¹get()ä¸­çš„dummyè¿›è¡Œconsturctã€‚è¿”å›ä¸€ä¸ªdummyåï¼Œé€šè¿‡operator=()é‡è½½çš„=é¢„ç®—ç¬¦èµ‹å€¼ç»™dummy1ï¼Œä»£ç æ‰§è¡Œå®Œä»¥åï¼Œåˆ†åˆ«ä¸ºdummyå’Œdummy1è°ƒç”¨destructorã€‚\n\n\n\nåœ¨operatro=ä¸­ï¼Œæˆ‘ä»¬æ˜¯æŠŠdummyä¸­çš„æŒ‡é’ˆå–å‡ºæ¥ç„¶åé‡æ–°æ„é€ ï¼Œéœ€è¦é‡æ–°è°ƒç”¨newå’ŒInnerçš„deleteï¼Œè€Œä¸”æˆ‘ä»¬è¿˜å¯ä»¥æ³¨æ„åˆ°ï¼Œget()è¿”å›çš„æ˜¯ä¸€ä¸ªå³å€¼ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥ä¸ºoperator=å’Œcopy constructoré‡æ–°å®šåˆ¶ä¸€ä¸ªå³å€¼ç‰ˆæœ¬ï¼Œåˆ†åˆ«ç§°ä¸ºmove assignmentå’Œmove constructor.\n\n```cpp\nclass Dummy\n{\n    typedef std::string Inner;\n\npublic:\n    Dummy() : inner_(new Inner(\"test\"))\n    {\n        cout << \"Trivial Constructor\" << endl;\n    }\n    explicit Dummy(const Inner& inner)\n    {\n        inner_ = new Inner(inner);\n        cout << \"explicit Constructor\" << endl;\n    }\n\n    ~Dummy() {\n        delete(inner_);\n        cout << \"Destructor\" << endl;\n    }\n\n    Dummy(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"copy Constructor\" << endl;\n    }\n\n    Dummy& operator=(const Dummy& dummy)\n    {\n        inner_ = new Inner(*(dummy.inner_));\n        cout << \"operator = \" << endl;\n        return *this;\n    }\n\n    Dummy(Dummy&& dummy) : inner_(dummy.inner_)\n    {\n        dummy.inner_ = nullptr;\n        cout << \"move Construct \" << endl;\n    }\n\n    Dummy& operator=(Dummy&& dummy)\n    {\n        Inner *tmp = dummy.inner_;\n        dummy.inner_ = inner_;\n        inner_ = tmp;\n        tmp = nullptr;\n        cout << \"move assignment\" << endl;\n        return *this;\n    }\n\nprivate:\n    Inner *inner_;\n};\n\nDummy get()\n{\n    Dummy dummy(\"test\");\n    return dummy;\n}\n\nint main()\n{\n    Dummy dummy1;\n    dummy1 = get();\n    return 0;\n}\n```\n\nè¿™æ®µä»£ç çš„è¿è¡Œç»“æœå¦‚ä¸‹ï¼š\n\n> Trivial Constructor\n> explicit Constructor\n> move assignment\n> Destructor\n> Destructor\n\né€šè¿‡move assignmentï¼Œæˆ‘ä»¬å¯ä»¥å°†åŸæ¥çš„copy assignmentä¸­çš„ä¸€æ¬¡new & deleteç»™æ¶ˆé™¤æ‰æ¥æå‡æ€§èƒ½ã€‚\n\næœ¬è´¨ä¸Šæ¥è¯´ï¼Œæˆ‘ä»¬åšäº†ä¸€æ¬¡æµ…æ‹·è´æ¥èŠ‚çœæ€§èƒ½ï¼Œè€Œdummyå˜æˆäº†ä¸€ä¸ªdangling pointer, æ‰€ä»¥ç»™å®ƒèµ‹å€¼ä¸ºnullptr.\n\n## å®Œç¾è½¬å‘(perfect farward)\n\nå‡å¦‚è¯´æˆ‘ä»¬æœ‰å¾ˆå¤šç§ç±»å‹çš„classï¼Œè€Œä¸”æœ‰çš„å¯èƒ½ä¼šæ˜¯å·¦å€¼æœ‰çš„ä¼šæ˜¯å³å€¼ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥è¿›è¡Œè½¬å‘ã€‚\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(t);\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\n\n\nä½†æ˜¯å¾—åˆ°çš„ç»“æœå´å’Œæˆ‘ä»¬æƒ³è±¡çš„å®Œå…¨ä¸ä¸€æ ·ï¼Œå¾—åˆ°çš„ç»“æœå¦‚ä¸‹ï¼š\n\n```cpp\nexplicit Constructor\nin forward\ncopy Constructor\nin func\nDestructor\nDestructor\n```\n\né€šè¿‡ç»“æœæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œåœ¨è°ƒç”¨funcçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä»¥get()è¿”å›çš„å³å€¼ä¼ è¿›å»ï¼ŒæŒ‰ç…§å¼•ç”¨å åŠ çš„åŸç†æ¥è¯´ï¼Œåº”è¯¥ç»™funcçš„ä¹Ÿæ˜¯ä¸€ä¸ªå³å€¼ï¼Œä½†æ˜¯å®é™…ä¸Šæ ¹æ®è°ƒç”¨çš„ç»“æœæ¥çœ‹ï¼Œä¼ è¿›å»çš„tæ˜¯ä»¥å·¦å€¼å¼•ç”¨çš„æ–¹å¼è¿‡å»çš„ï¼Œè€Œä¸æ˜¯ä»¥å³å€¼å¼•ç”¨çš„move Constructorç‰ˆæœ¬ã€‚å…·ä½“çš„åŸå› æ˜¯å› ä¸ºæˆ‘ä»¬ä¼ ç»™funcçš„å€¼å…¶å®å·²ç»è¢«ç¡®ç¡®å®å®çš„å­˜å‚¨åœ¨äº†å†…å­˜ä¸­ï¼Œæ‰€ä»¥æœ€åç»™func()çš„åº”è¯¥æ˜¯ä¸€ä¸ªå·¦å€¼å¼•ç”¨ï¼Œé€šè¿‡å’Œ&&å¼•ç”¨å åŠ ä¸€ä¸ªçœŸæ­£å¾—åˆ°äº†ä¸€ä¸ªå·¦å€¼å¼•ç”¨ï¼Œæ‰€ä»¥è°ƒç”¨äº†copy Constructor.\n\né‚£æˆ‘ä»¬å¦‚æœæƒ³è¦å®Œæˆçš„ä»¥å®ƒæœ¬èº«çš„çŠ¶æ€æ¥ä¼ é€’çš„è¯ï¼Œå°±åº”è¯¥ä»¥forward<T>()æ¥è¿›è¡Œ<strong>å®Œç¾è½¬å‘</strong>,ä»è€Œä¿æŒTæœ¬èº«çš„çŠ¶æ€ï¼Œä»£ç å¦‚ä¸‹ã€‚\n\n\n\n```cpp\ntemplate <typename T>\nvoid func(T t)\n{\n  cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid forward(T&& t)\n{\n  cout << \"in forward \" << endl;\n\tfunc(std::forward<T>(t));\n}\n\nint main()\n{\n  relay(get());\n}\n```\n\nè¿™æ ·å¾—åˆ°çš„ç»“æœæ˜¯ï¼š\n\n> explicit Constructor\n> in forward\n> move Construct\n> in func\n> Destructor\n> Destructor\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ­¤æ—¶ä¼ è¿›funcçš„ç»“æœè¢«å®Œæ•´çš„ä¿ç•™äº†å³å€¼çš„èº«ä»½ã€‚é€šè¿‡å®Œç¾è½¬å‘æ¥è¾¾åˆ°æˆ‘ä»¬éœ€è¦çš„æ•ˆæœã€‚å¦‚æœæˆ‘ä»¬æŠŠè¾“å…¥forwardçš„ç±»å‹æ”¹ä¸ºå·¦å€¼:\n\n```cpp\nint main()\n{\n  Dummy du = get();\n  forward(du);\n}\n```\n\né€šè¿‡è¿™ä¸ªè¾“å…¥å¾—åˆ°çš„ç»“æœæ˜¯ï¼š\n\n> Trivial Constructor\n> in forward\n> copy Constructor\n> in func\n> Destructor\n> Destructor\n\nå®Œç¾çš„å¾—åˆ°äº†æˆ‘ä»¬éœ€è¦çš„ç»“æœã€‚\n\n\n\n\n\n\n\n\n\n","tags":["C++"]},{"title":"å¼±å›è°ƒ","url":"/2019/08/11/å¼±å›è°ƒ/","content":"# å¼±å›è°ƒæŠ€æœ¯\n\n> æœ€è¿‘åœ¨æ‹œè¯»é™ˆç¡•è€å¸ˆçš„ã€ŠLinuxå¤šçº¿ç¨‹æœåŠ¡å™¨ç«¯ç¼–ç¨‹ã€‹ï¼Œä»ç¬¬ä¸€ç« å¼€å§‹å°±è§‰å¾—è‡ªå·±èœ = =ï¼Œå› ä¸ºä¹¦ä¸­æ¶‰åŠçš„çŸ¥è¯†æ˜¯æˆ‘ä¹‹å‰ä»…ä»…äº†è§£äº†çš®æ¯›ï¼Œç”šè‡³æ˜¯ä»…æœ‰è€³é—»çš„å†…å®¹ã€‚æ‰€ä»¥è¿™æœ¬ä¹¦è¯»èµ·æ¥å¾ˆåƒåŠ›ï¼Œè€Œä¸”éœ€è¦åå¤çš„å»å“å‘³å…¶ä¸­è¿ç”¨çš„æŠ€æœ¯ã€‚\n\nä»ç¬¬ä¸€ç« æ¥çœ‹ï¼Œä¸»è¦è®²çš„shared_pträ¸weak_ptrçš„è¿ç”¨ï¼Œå…¶å®å¤§å­¦çš„æ—¶å€™è¿˜æœ‰å»åˆ†æè¿‡shared_pträ¸weak_ptrçš„ç”¨æ³•ï¼Œä½†ç»ˆå½’å¹¶æ²¡æœ‰å®é™…å»ä½¿ç”¨è¿™ä¸¤ä¸ªæ¨åŠ¨äº†C++ç°ä»£åŒ–çš„å·¥å…·ã€‚\n\n## shared_ptr ä¸ weak_ptrç®€ä»‹\n\nè¿™ä¸¤ä¸ªå·¥å…·åŸºæœ¬ä¸Šå¯ä»¥è¯´æ˜¯é…å¥—ä½¿ç”¨çš„ï¼Œä¸¾ä¸ªğŸŒ°ï¼Œshared_ptræœ€å¤§çš„ç‰¹ç‚¹æ˜¯å¼•ç”¨è®¡æ•°ï¼Œå¯¹åŒä¸€ä¸ªå¯¹è±¡çš„å¤šæ¬¡å¼•ç”¨ï¼Œå…¶å®è´¨åªæ˜¯åœ¨ å†…éƒ¨çš„è®¡æ•°å™¨+1è€Œå·²ï¼Œä½†æ˜¯å¦‚æœé‡åˆ°ä¸¤ä¸ªå¯¹è±¡ç›¸äº’å¼•ç”¨ï¼Œå°±ä¼šå½¢æˆæ­»é”ã€‚æ­¤æ—¶å°±éœ€è¦weak_ptræ¥æ‰“ç ´åƒµå±€ï¼Œweak_ptrå¼•ç”¨çš„ å¯¹è±¡ï¼Œä¸ä¼šé€ æˆshared_ptrå†…éƒ¨çš„è®¡æ•°å™¨+1ï¼Œå¯ä»¥ç†è§£ä¸ºå¼±å¼•ç”¨ã€‚ä½†æ˜¯æœ¬ä¹¦ä¸­ä¸»è¦ä½¿ç”¨weak_ptrçš„åœ°æ–¹å¤šåœ¨äºè¯•æ¢ï¼Œçœ‹å½“å‰ çš„å¯¹è±¡æ˜¯å¦èƒ½ä»weak_ptræå‡ä¸ºshared_ptr,ä»¥æ­¤æ¥ä¿è¯å¯¹è±¡å¹¶æœªè¢«é”€æ¯ã€‚ \n## å®ä¾‹\n\næœ¬ä¹¦çš„ä»£ç å…¶å®æ˜¯ä¸€ç‚¹ä¸€ç‚¹æ”¹è¿›çš„ï¼Œæˆ‘å°±ç›´æ¥è´´ä¸ªæœ€ç»ˆç‰ˆï¼Œç„¶åä¸€ç‚¹ä¸€ç‚¹åˆ†æå¥½äº†=3=\n\n```cpp\n//\n// Created by neojxwang(ç‹é–ç…Š) on 2019-08-08.\n//\n\n#include <vector>\n#include <string>\n\nusing std::vector;\nusing std::string;\n\nclass Stock\n{\npublic:\n\n    Stock() {}\n    Stock(string key) : key_(key) {}\n\n    string key()\n    {\n        return key_;\n    }\nprivate:\n    std::string key_;\n\n};\n\nclass StockFactory\n{\npublic:\n    shared_ptr<Stock> get(std::string key)\n    {\n        shared_ptr<Stock> sPtr;\n\n        pthread_mutex_lock(&mutex_);\n        weak_ptr<Stock>& wPtr = mp[key];\n        sPtr = wPtr.lock();\n        if (!sPtr) {\n            sPtr.reset(new Stock(key), std::bind(&StockFactory::delete, weak_ptr<StockFactory>(enable_shared_from_this()), _1));\n            wPtr = sPtr;\n        }\n        pthread_mutex_unlock(&mutex_);\n        return sPtr;\n    }\n\nprivate:\n    pthread_mutex_t mutex_;\n    std::map<std::string, std::weak_ptr<Stock>> mp;\n\n    void delete(weak_ptr<Stock> wPtr, Stock *stock)\n    {\n        shared_ptr<StockFactory> factory(wPtr.lock());\n\n        if (factory)\n        {\n            factory->removeStock(stock);\n        }\n\n        delete stock;\n    }\n\n    void removeStock(Stock * stock)\n    {\n        if (stock)\n        {\n            pthread_mutex_lock(&mutex_);\n            mp.erase(stock->key());\n        }\n    }\n};\n\n\n``` \n\nå‡è®¾æœ‰å„ä¸ªè‚¡ç¥¨ï¼Œæ¯ä¸ªè‚¡ç¥¨æœ‰ä¸€ä¸ªå”¯ä¸€ä»£ç keyï¼Œæˆ‘ä»¬å”¯ä¸€è¦åšçš„å°±æ˜¯é€šè¿‡è¿™ä¸ªkeyæ¥å–åˆ°è‚¡ç¥¨çš„å¯¹è±¡ï¼Œä½†æ˜¯è·å¾—è¿™ä¸ªå¯¹è±¡åœ¨å¤šè¿› ç¨‹ç¯å¢ƒä¸‹å…¶å®æ˜¯å­˜åœ¨ç«äº‰çš„ï¼Œå‡è®¾å¦‚ä¸‹æƒ…å†µï¼Œè¿›ç¨‹Aåˆšåˆšé€šè¿‡get()æ–¹æ³•è·å¾—äº†å¯¹åº”çš„è‚¡ç¥¨å¯¹è±¡ï¼Œè¿›ç¨‹Bè¢«æ¨ä¸ŠCPUï¼Œå¹¶å¯¹é‚£ä¸ª è‚¡ç¥¨å¯¹è±¡è¿›è¡Œäº†é”€æ¯æ“ä½œï¼Œå¹¶åˆ‡å›è¿›ç¨‹Aï¼Œé‚£ä¹ˆæ­¤æ—¶ï¼Œä¼šå‡ºç°coredumpã€‚\n\næ‰€ä»¥æˆ‘ä»¬æœ€ä¸€å¼€å§‹çš„ä½¿ç”¨ä¸€ä¸ªshared_ptræ¥å­˜å‚¨mapä¸­çš„Stockå¯¹è±¡ï¼Œå³<strong>std::map<std::string, std::shared_ptr<Stock>></strong> ä½†æ˜¯è¿™æ ·è™½ç„¶å¯ä»¥æ–¹ä¾¿å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œä½†æ˜¯æ­¤æ—¶çš„shared_ptr<strong>ä¸ä¼šè¢«é”€æ¯</strong>,æ‰€ä»¥æˆ‘ä»¬è¯¥ç”¨weak_ptræ¥å¯¹ mapä¸­çš„Stockè¿›è¡Œç®¡ç†ï¼Œåªæœ‰åœ¨çœŸæ­£è¿›è¡Œæ“ä½œçš„æ—¶å€™ï¼Œæ‰å°†weak_ptræå‡æˆshared_ptrã€‚\n\nä½†æ˜¯è¿™ä¸ªæ ·å­å…¶å®è¿˜æ˜¯ä¼šä½¿å¾—å†…å­˜è¿›è¡Œæ³„æ¼çš„ï¼Œé‚£ä¸ªmapçš„sizeå…¶å®æ˜¯åªå¢ä¸å‡çš„ï¼Œå› ä¸ºå¹¶æ²¡æœ‰å°†mapä¸­çš„å…ƒç´ è¿›è¡Œeraseï¼Œ å³ä½¿è¿™ä¸ªå…ƒç´ æ²¡æœ‰è¢«å¼•ç”¨ï¼Œä½¿ç”¨çš„å†…å­˜ä¹Ÿä¸ä¼šå‡å°‘ï¼Œè¿™å…¶å®å°±æ˜¯å˜ç›¸çš„å†…å­˜æ³„éœ²ã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨shared_ptrçš„å®šåˆ¶å†…å­˜é”€æ¯å‡½æ•°ï¼Œ ä¹Ÿå°±æ˜¯ä½¿ç”¨std::bind()å°†shared_ptrçš„ç¬¬äºŒä¸ªå…ƒç´ ç»‘å®šä¸ºä¸€ä¸ªå‡½æ•°ï¼Œåœ¨è¿™é‡Œbindäº†ä¸€ä¸ªç±»å†…éƒ¨å‡½æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨ std::bind(&StockFactory::delete, this, _1)ä½œä¸ºshared_ptr.reset()çš„ç¬¬äºŒä¸ªå‚æ•°ã€‚ \n> bind ç”¨æ³•å¯ä»¥è§ä¸Šç¯‡æ–‡ç« \n\nä½†æ˜¯è¿™ä¸ªæ—¶å€™æˆ‘ä»¬åˆå‡ºç°äº†æ–°çš„é—®é¢˜ï¼Œæˆ‘ä»¬å°†thisæŒ‡é’ˆä½œä¸ºå‚æ•°ä¼ ç»™äº†å‡½æ•°ï¼Œè¿™å°±å¾ˆæœ‰å¯èƒ½é€ æˆå¤šè¿›ç¨‹ç¯å¢ƒä¸‹çš„ç«æ€ï¼Œä¸€æ—¦ è¿™ä¸ªç±»åœ¨è¿›ç¨‹Aä¸­è¢«destroyï¼Œé‚£ä¹ˆåœ¨å¦ä¸€ä¸ªè¿›ç¨‹ä¸­è°ƒç”¨thisæŒ‡é’ˆå°±ä¼šé€ æˆcoredumpï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯ä½¿ç”¨shared_ptræŒ‡é’ˆæ¥ç®¡ç†thisæŒ‡é’ˆï¼Œ è¿™å°±ç”¨åˆ°äº†enable_shared_from_this()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å¯ä»¥è¿”å›get()æˆå‘˜å‡½æ•°æŒ‡å‘çš„ç±»æœ¬èº«ï¼Œä¸”æ˜¯ä¸€ä¸ªshared_ptrå‡½æ•°ï¼Œ è¿™å°±ä¿è¯æˆ‘ä»¬ä¸ä¼šåœ¨è¿™ä¸ªç±»è¢«é”€æ¯ä»¥åè¿˜èƒ½è°ƒç”¨åˆ°thisæŒ‡é’ˆï¼Œæ›´å‡†ç¡®ç‚¹ï¼Œåº”è¯¥æ˜¯æˆ‘ä»¬ä¼šä¿è¯thisè¢«è°ƒç”¨çš„æ—¶å€™ï¼Œè¿™ä¸ªç±»çš„å®ä¾‹ä¸€å®šä¸ä¼šè¢«é”€æ¯ã€‚ è§£å†³äº†thisæŒ‡é’ˆçš„é—®é¢˜ï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œæ­¤æ—¶bindä¸­ç»‘å®šçš„StockFactoryç±»å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸè¢«å»¶é•¿äº†ï¼Œæˆ‘ä»¬æ­¤æ—¶å¯ä»¥é€šè¿‡ <strong>å¼±å›è°ƒæŠ€æœ¯</strong>æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ \n> æ‰€è°“å¼±å›è°ƒï¼Œé¡¾åæ€ä¹‰ï¼Œæˆ‘ä»¬å¯¹ä¸€ä¸ªç±»å®ä¾‹çš„è°ƒç”¨ä¸ä¼šå½±å“å…¶æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªåœ¨éœ€è¦çš„æ—¶å€™ä¿è¯è¯¥ç±»æ²¡æœ‰è¢«é”€æ¯å°±å¯ä»¥ã€‚ï¼ˆæˆ‘è‡ªå·±çè¯´çš„\n\næœ€ç»ˆç‰ˆæœ¬çš„codeå°±åœ¨ä¸Šé¢ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªenable_shared_from_this()æ–¹æ³•äº§ç”Ÿçš„shared_ptræŒ‡é’ˆå…¶å®è¢«æ”¾åœ¨äº†ä¸€ä¸ª weak_ptræŒ‡é’ˆä¸­ï¼Œè¿™å°±ä¿è¯thisæŒ‡é’ˆçš„ç±»å®ä¾‹<strong>ä¸€å®š</strong>ä¸ä¼šè¢«æ„å¤–çš„å»¶é•¿ç”Ÿå‘½å‘¨æœŸï¼Œè€Œä¸”åœ¨éœ€è¦å¯¹thisæŒ‡é’ˆè¿›è¡Œ æ“ä½œæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹weak_ptræŒ‡é’ˆçš„lock()æ“ä½œæ¥ç¡®ä¿ç±»å®ä¾‹æ˜¯å­˜åœ¨çš„ï¼Œè¿™å°±æ˜¯å¼±å›è°ƒæŠ€æœ¯ã€‚ \n* æ€»ç»“ä¸€ä¸‹ï¼Œè¿ç”¨çš„æŠ€æœ¯ä¸»è¦æ˜¯é€šè¿‡weak_ptræ¥å¯¹å¯¹è±¡è¿›è¡Œå¼±å¼•ç”¨ï¼Œä»¥ä¿è¯ä¸æ„å¤–å»¶é•¿å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶åœ¨éœ€è¦å¯¹è±¡çš„æ—¶å€™é€šè¿‡lock()æ¥æå‡çº§åˆ«ï¼Œä»¥ä¿è¯åœ¨å¤šè¿›ç¨‹ç¯å¢ƒä¸­å¯¹è±¡å®ä¾‹è¿˜æ´»ç€ï¼ˆXD\n\n\n\n\n\n\n","tags":["C++"]},{"title":"Leetcode-567-PermutationStrings","url":"/2019/08/09/Leetcode-567-PermutationStrings/","content":"\n# Leetcode 567 PermutationString \n\n## é¢˜å¹² \n\n> Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\n\n## é¢˜æ„ \n\nå…¶å®è¿™ä¸ªé¢˜è¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œç»™å®šä¸¤ä¸ªstring s1å’Œs2,å¦‚æœs2çš„æŸä¸ªå­é›†ä¸­åŒ…å«çš„å­—æ¯ä¸s1<strong>å®Œå…¨</strong>ä¸€æ ·ï¼Œé‚£ä¹ˆè¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚å¯ä»¥ç”¨æœ€æ™®é€šçš„æ–¹æ³•ï¼Œç”¨ä¸€ä¸ªs1.length()é•¿åº¦çš„çª—å£æ¥éå†s2,æ¯æ¬¡æ£€æŸ¥çª—å£å†…çš„å­—æ¯æ˜¯å¦ä¸\ns1ç›¸åŒã€‚ä½†æ˜¯è¿™ä¸ªé¢˜è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰æ„æ€çš„è§£æ³•ï¼Œåå‘æ€ç»´ï¼Œç”¨ä¸€ä¸ªmapè®°å½•s1ä¸­æ‰€æœ‰çš„å­—æ¯ï¼Œæ¯æ¬¡--1ï¼Œç„¶åè¿˜æ˜¯ç”¨ä¸€ä¸ªs1.length()çš„çª—å£æ¥éå†ï¼ŒçŸ¥é“å¯ä»¥è®©è¯¥mapæ‰€æœ‰æˆå‘˜éƒ½ä¸º0ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾s1 = \"ba\", s2 = \"acdeab\", é‚£ä¹ˆåˆå§‹\nmap={-1, -1, 0, 0, ... , 0}, ç„¶åä»¥ä¸€ä¸ªsizeä¸º2çš„çª—å£éå†æ•´ä¸ªs2ï¼Œä¸€ç›´åˆ°mapä¸­<strong>æ‰€æœ‰çš„å…ƒç´ </strong>éƒ½ä¸º0ï¼Œå°±è¯æ˜æ˜¯å­˜åœ¨çš„ã€‚\n\n## Code\n\n```cpp\nbool checkInclusion(const string &s1, const string &s2)\n{\n    const int n1 = s1.length(), n2 = s2.length();\n    if (n1 > n2)\n        return false;\n    vector<int> mp(27, 0);\n    int i = 0, j = n1;\n\n    for (const auto &c : s1)\n        --mp[c-'a'];\n\n    for (int i = 0; i < j; i++)\n        ++mp[s2[i]-'a'];\n\n    while (j < n2)\n    {\n        if (equal(mp.begin(), mp.end(), mp.rbegin()))\n            return true;\n\n        ++mp[s2[j++] - 'a'];\n        --mp[s2[i++] - 'a'];\n    }\n\n    return equal(mp.begin(), mp.end(), mp.rbegin());\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Leetcode-828-UniqueLetterString","url":"/2019/08/07/Leetcode-828-UniqueLetterString/","content":"\nLeetcode 828 UniqueLetterString\n\n# é¢˜æ„ \n\n> A character is unique in string S if it occurs exactly once in it.\n> For example, in string S = \"LETTER\", the only unique characters are \"L\" and \"R\".\n> Let's define UNIQ(S) as the number of unique characters in string S.\n>For example, UNIQ(\"LETTER\") =  2.\n>Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.\n>If there are two or more equal substrings at different positions in S, we consider them different.\n>Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.\n\né¢˜æ„å…¶å®å¾ˆå¥½ç†è§£ï¼Œç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²Sï¼Œå…¶ä¸­ä»…å‡ºç°ä¸€æ¬¡çš„å­—ç¬¦æ•°é‡ç”¨UNIQ(S)è¡¨ç¤ºï¼Œè‹¥S=\"LETTER\", é‚£ä¹ˆå…¶ä¸­UNIQ(S)=2, ä¸º\"L\"ä¸\"R\"ï¼Œè¿™ä¸ªé¢˜éœ€è¦ æ±‚å¾—çš„ç»“æœæ˜¯ï¼Œç»™å®šçš„Sçš„æ‰€æœ‰å­—ä¸²çš„UNIQ()çš„å€¼ã€‚\n\n# é¢˜è§£\n\næˆ‘ä»¬å¯ä»¥æ¢ä¸€ä¸ªè§’åº¦æ¥æ€è€ƒè¿™é“é¢˜ï¼Œä»¥å­—ç¬¦ä¸²\"XAXXAXXA\"ä¸ºä¾‹ï¼Œå‡è®¾æˆ‘ä»¬éœ€è¦å¾—å‡ºä»¥ç¬¬äºŒä¸ª\"A\"ä½œä¸ºunique charçš„æ‰€æœ‰å­ä¸²æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å·¦å³åŠ å…¥() æ¥è¡¨ç¤ºï¼Œé‚£å¯èƒ½çš„å·¦è¾¹å­—ä¸²æœ‰\"XA(XXA\"/\"XAX(XA\"/\"XAXX(A\",å¯èƒ½çš„å³è¾¹å­—ä¸²æœ‰\"AXX)\"/\"AX)X\"/\"A)XX\",å„æœ‰3ç§ï¼Œ3*3=9ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥éå†æ¯ä¸ªcharï¼Œ åˆ†åˆ«æ±‚å‡ºä»¥å½“å‰charä¸ºunique charçš„æ‰€æœ‰å­—ä¸²æ•°é‡å³ä¸ºé¢˜è§£ã€‚\n\n# Code\n\n```cpp\n#define LL long long\n\nint uniqueLetterString(string S) {\n    const int mod = 1000000007;\n    int n = S.length();\n    LL ans = 0;\n    vector<int> last(26, -1);\n\n    vector<int> left(n, -1), right(n, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        left[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    last = vector<int> (26, n);\n    for (int i = n-1; i >= 0; i--)\n    {\n        right[i] = last[S[i] - 'A'];\n        last[S[i] - 'A'] = i;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n       ans += (ans + (LL)(i - left[i]) * (right[i] - i)) % mod;\n    }\n\n    return ans;\n}\n\n```\n","tags":["C++","Leetcode"]},{"title":"bind","url":"/2019/07/24/bind/","content":"\n\n# C++ std::bind\n\nå¾ˆä¹…ä¹‹å‰å­¦ä¹ è¿‡bindï¼Œä½†æ˜¯ç°åœ¨å·²ç»è®°ä¸æ¸…æ¥šäº†â€¦é‡æ–°å­¦ä¸€å“ˆã€‚\n\nC++ä¸­åº”è¯¥æœ‰Lvalueï¼ŒRvalueï¼Œä½†æ˜¯å…¶å®ä¸€å…±æœ‰äº”ç§æ¥ç€â€¦\n\nbindçš„ä¸»è¦ä½œç”¨åº”è¯¥æ˜¯å°†æ–¹æ³•ä¸å‚æ•°ç›¸ç»‘å®šã€‚\n\nå…¶å¯ä»¥ç»‘å®šä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯æ™®é€šçš„æ–¹æ³•ï¼Œä¸€ç§æ˜¯ç±»çš„æˆå‘˜æ–¹æ³•ã€‚\n\n```cpp\n\nclass Test\n{\npublic:\n    void changeAB(int a, int b)\n    {\n        a_ = a;\n        b_ = b;\n    }\nprivate:\n    int a_;\n    int b_;\n}\n\nvoid test(int &a, int &b, const int &c)\n{\n    //æ­¤å¤„æ‰“å°ç»“æœæ˜¯ a = 1\n    //åœ¨bindæ—¶å°±å·²ç»ç¡®å®šäº†å„ä¸ªå‚æ•°çš„ç±»å‹ï¼Œä¸ä¼šå› ä¸ºæ–¹æ³•æœ¬èº«æ”¹å˜\n    cout << \"in\" << a << \" \" << b << \" \" << c << endl;\n    ++a;\n    ++b; //æ­¤å¤„ä¿®æ”¹mainä¸­bçš„å€¼\n    // ++c; compile error\n}\n\nint main()\n{\n    using namespace std::placeholders; // ä½¿ç”¨å ä½ç¬¦\n    int a = 1, b = 2, c = 3;\n\n    //ç»‘å®štestæ–¹æ³•\n    std::function<void()> bound_test = std::bind(test, a, std::ref(b), std::cref(c));\n    a = 10;\n    b = 12;\n    c = 13;\n    cout << a  << \"  \" << b << \" \" << c << endl;\n    bound_test();\n    cout << a  << \"  \" << b << \" \" << c << endl;\n\n    //bind ç±»æˆå‘˜æ–¹æ³•ï¼š\n    std::function<void()> bound_changeAB(&Test::changeAB, _1, _2);\n    bound_changeAB(a, b);\n}\n\n```\n\n","tags":["C++"]},{"title":"Weak_Ptrç›¸å…³","url":"/2019/07/23/Weak-Ptrç›¸å…³/","content":"\n# weak_ptr\n\nweak_ptræ˜¯ä¸€ä¸ªC++11çš„è¯­æ³•ï¼Œä½œä¸ºä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œæœ€å¤§çš„ä½œç”¨å°±æ˜¯åœ¨å¤šçº¿ç¨‹çš„ç¯å¢ƒä¸‹ï¼Œé…åˆshare_ptrè¿›è¡Œå¼•ç”¨è®¡\næ•°ï¼Œä½†æ˜¯weak_ptræ˜¯å¼±å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡weak_ptrè¿›è¡Œå¼•ç”¨å¹¶ä¸ä¼šå°†share_ptr+1, åªæœ‰é€šè¿‡lock()æå‡ä¸º\nshared_ptræ‰èƒ½æ­£å¸¸çš„è¿›è¡Œè®¿é—®å…¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œä½†åŒæ—¶ä¹Ÿä¼šè¿›è¡Œå¼•ç”¨æ•°å­—çš„+1ã€‚\n\n```cpp\ntemplate <class T>\nstd::shared_ptr<T> lock() const nonexcept;\n```\n\n> å› weak_ptræ˜¯æ— æ³•è®¿é—®å­˜å‚¨çš„æ•°æ®çš„ï¼Œå¿…é¡»åŒlockæå‡ä¸ºshared_ptrå†è¿›è¡Œè®¿é—®ã€‚ç”¨ä¸€ä¸ªç»å…¸çš„Observeræ¨¡å¼æ¥\n> æ¼”ç¤ºweak_ptr.\n\n```cpp\nclass Observer\n{\npublic:\n    virtual ~Observer() {\n       subject_->unregister(); \n    }\n    virtual void update() {}\n    \n    void observer(Observable *s) {\n        s->register_(this);\n        subject_ = s;\n    }\nprivate:\n    Observable *subject_;\n}\n\nclass Observable\n{\npublic:\n    void register(Observer* ob);\n    void unregister(Observer* ob);\n\n    void notifyRegeisters()\n    {\n        /*******\n        for (auto x : observers_) {\n            x->update();\n        }\n        ******/\n\n        Iterator iter = observers_.begin();\n        while (iter != observers_.end()) \n        {\n            //é€šè¿‡lock() æå‡\n            std::shared_ptr<Observer *> obj(iter->lock());     \n            if (obj) {\n                iter->update();\n                iter++;\n            } else {\n                observers_.erase(iter); //æå‡å¤±è´¥ ç›´æ¥ä»vectorä¸­åˆ é™¤weakptr\n            }\n        }\n    }\n\nprivate:\n    //std::vector<Observers *> observers_;\n    std::vector<std::weak_ptr<Observer *>> observers_;\n    typedef std::vector<std::weak_ptr<Observer *>>::iterator Iterator; \n}\n```\n\n# shared_ptr\n\n## reset \n\nå¯é€šè¿‡ä¸€ä¸ªT* çš„æŒ‡é’ˆé‡æ–°èµ‹å€¼ç»™shared_ptrï¼Œæ¥å¡«å……shared_ptrã€‚\n\ntemplate <class T>\nvoid reset(T *) noexcept;\n","tags":["C++"]},{"title":"Leetcode-42-TrappingRainWaters","url":"/2019/07/22/LeetCode-42-TrappingRainWaters/","content":"\n# Leetcode 42 Trapping Rain Waters\n\n## é¢˜ç›®\n\n\n> Given n non-negative integers representing an elevation map where the width of each bar is 1,\n> compute how much water it is able to trap after raining.\n\n![test](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n## é¢˜è§£\n\nè¿™ä¸ªé¢˜å…¶å®å¾ˆæœ‰æ„æ€ï¼Œä¸€å¼€å§‹åˆ·çš„æ—¶å€™ï¼Œæ„Ÿè§‰æ— ä»ä¸‹æ‰‹ï¼Œä½†æ˜¯ç¬¬äºŒæ¬¡åˆ·å°±å¥½å¾ˆå¤šï¼Œèµ·ç æœ‰ä¸ªå¤§æ¦‚æ€è·¯ï¼Œç”¨äº†\nä¸¤ç§æ€è·¯æ¥è§£è¿™é“é¢˜ã€‚\n\n- Two Pointers\n- MonoStack\n\n### Two Pointers\n\næˆ‘ä»¬å¯ä»¥å…ˆç†æ¸…æ¥šæœ€åŸºæœ¬çš„é—®é¢˜ï¼Œèƒ½Trapä½é›¨æ°´çš„ï¼Œä¸€å®šæ˜¯æœ‰å‡¹æ§½å­˜åœ¨ï¼Œè€Œè¿™ä¸ªå‡¹æ§½èƒ½å®¹çº³å¤šå°‘æ°´ï¼Œä¸€å®šæ˜¯\nä»¥å®ƒä¸¤ç«¯ä¸­æœ€ä½çš„è¿™ç«¯ä½œä¸ºBaseï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œåº”è¯¥æ˜¯ä¸¤ç«¯å„å–æœ€å¤§å€¼ï¼Œä»¥è¾¾åˆ°å®¹çº³æœ€å¤šæ°´çš„æ•ˆæœã€‚ä¸¾ä¸ªğŸŒ°ã€‚\n\n*Lmax L R Rmax*\n\næ­¤æ—¶ï¼Œå¦‚æœLMax < Rmax,  æˆ‘ä»¬å¯ä»¥è®¡ç®—Lç‚¹çš„æ°´é‡ï¼Œå› ä¸ºæ­¤æ—¶ï¼Œæˆ‘ä»¬ä»¥LMaxä¸ºçŸ­æ¿ï¼Œé‚£ä¹ˆä¸€å®šæœ‰Rmax > LMax\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†Lå¤„çš„æ°´é‡ï¼Œå³Lmax - L åŠ å…¥åˆ°æ°´é‡ä¸­ï¼Œåä¹‹ï¼Œåˆ™åŠ å…¥RMax - Rã€‚\n\n```cpp\nint trap(vector<int>& height)\n{\n    int left = 0;\n    int right = height.size()-1;\n    int leftMax = 0;\n    int rightMax = 0;\n    int res = 0;\n\n    while (left < right)\n    {\n        leftMax = max(height[left], leftMax);\n        rightMax = max(height[right], rightMax);\n\n        if (leftMax > rightMax) {\n            res += rightMax - height[right];\n            right--;\n        } else {\n            res += leftMax - height[left];\n            left++;\n        }\n    }\n\n    return res;\n}\n```\n### MonoStack\n\nè¿™ä¸ªè§£æ³•å…¶å®ä¹Ÿå¾ˆæœ‰æ„æ€ï¼Œå•è°ƒæ ˆï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯æ ˆå†…çš„å…ƒç´ éƒ½ä¿æŒå•è°ƒé€’å¢æˆ–é€’å‡ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç›®çš„æ˜¯\nè®¡ç®—å®¹çº³çš„æ°´ï¼Œé‚£ä¹ˆå°±è¦åˆ¶é€ é«˜ä½å·®ã€‚æˆ‘ä»¬ä½¿æ ˆå†…çš„å…ƒç´ å•è°ƒé€’å‡ï¼Œè€ƒè™‘ä¸€ç§æé™æƒ…å†µï¼Œ1-4éƒ½ä¸ºå•è°ƒé€’å‡ï¼Œ\nç¬¬5ä¸ªå€¼ > ç¬¬ä¸€ä¸ªå€¼ï¼Œæ­¤æ—¶ï¼Œå› ä¸ºç¬¬äº”ä¸ªå€¼å¤§äºæ ˆé¡¶å…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æ ˆé¡¶å¼¹å‡ºï¼Œå¹¶å°†æ ˆä½œä¸ºä¸€ä¸ªå‘ï¼Œæ­¤æ—¶ï¼Œ\nå‘çš„é«˜åº¦åº”è¯¥ä¸ºå½“å‰æ ˆï¼ˆå³å¼¹å‡ºæ ˆé¡¶åçš„æ ˆï¼‰çš„æ ˆé¡¶ä¸ç¬¬äº”ä¸ªå€¼çš„minï¼ˆæ˜¾ç„¶ä¸ºæ ˆé¡¶ï¼‰ä¸å‘çš„é«˜åº¦åšå·®ï¼Œå¾—åˆ°\næ­¤æ—¶å‘çš„é«˜åº¦ï¼Œå‘çš„å®½åº¦åº”è¯¥ä¸º5 - 3 - 1ï¼Œä¹Ÿå°±æ˜¯ç¬¬äº”ä¸ªå…ƒç´ çš„indexä¸æ ˆé¡¶çš„indexç›¸å‡ï¼Œå› å®½åº¦ä¸º1ï¼Œæ•…\nå†æ¬¡å‡ä¸€ï¼Œç›¸ä¹˜å³ä¸ºç»“æœã€‚\n\n```cpp\nint trap1(vector<int>& height)\n{\n    stack<int> stk;\n    int res = 0;\n    int i = 0;\n    int sz = height.size();\n\n    while (i < sz)\n    {\n        if (stk.empty() || height[stk.top()] >= height[i])\n            stk.push(i++);\n        else {\n            int cur  = height[stk.top()];\n            stk.pop();\n            int len = i - stk.top() - 1;\n            int h = min(stk.top(), height[i]);\n            res += (h - cur) * len;\n        }\n    }\n\n    return res;\n}\n```\n\n## æ€»ç»“ \nå…¶å®Two Pointerä¸MonoStackæœ‰ç›¸ä¼¼æŒ‡å‡ºï¼Œåªä¸è¿‡Two Pointersè®¡ç®—çš„æ˜¯çºµå‘çš„æ°´é‡ï¼ŒMonoStackè®¡ç®—çš„æ˜¯\næ¨ªå‘çš„æ°´é‡ã€‚åæ­£è¿™ä¸ªé¢˜ï¼Œåº”è¯¥ç®—æ˜¯åƒé€äº†8. å¿«ä¹ã€‚\n","tags":["C++","Leetcode"]},{"title":"881_BoatsToSavePeople","url":"/2019/07/22/LeetCode-881-BoatsToSavePeople/","content":"\n# LeetCode 881 Boats To Save People\n\n## é¢˜ç›®\n\n> The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\n\n> Each boat carries at most 2 people at the same time, provided the sum of the weight of those \n> people is at most limit.\n\n> Return the minimum number of boats to carry every given person.  (It is guaranteed each person\n> can be carried by a boat.)\n\nè¿™ä¸ªè¿˜è›®ç®€å•çš„ï¼Œå®Œå…¨å¯ä»¥ç±»æ¯”æˆï¼Œ2 Sumï¼Œå–æœ€æ¥è¿‘çš„å€¼ï¼Œæ²¡å•¥å¥½è¯´çš„ï¼Œç›´æ¥ä¸Šä»£ç äº†ã€‚\n\n## Code\n\n```cpp\nint numRescueBoats(vector<int>& people, int limit)\n{\n    sort(begin(people), end(people));\n\n    int beg = 0;\n    int end = people.size()-1;\n    int count = 0;\n\n\n    while (beg <= end)\n    {\n        if (people[beg] + people[end] > limit)\n        {\n            end--;\n            count++;\n        }\n        else\n        {\n            beg++;\n            end--;\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n","tags":["C++","Leetcode"]},{"title":"Mutableå…³é”®å­—","url":"/2019/07/21/Mutableå…³é”®å­—/","content":"\n# å…³äºC++çš„mutableå…³é”®å­—\n\nC++çš„mutableå…³é”®å­—ä»Šå¤©æ•´ç†ä¸€ä¸‹ã€‚\n\nC++çš„constæ¦‚å¿µä¸º ä¸å¯ä»¥ä¿®æ”¹ï¼Œconstå¯ç”¨æ¥ä¿®é¥°å˜é‡ï¼ŒæŒ‡é’ˆï¼Œå¼•ç”¨ï¼Œç±»æˆå‘˜å‡½æ•°ç­‰ï¼Œå½“constè¢«ç”¨æ¥ä¿®é¥°\næˆå‘˜å‡½æ•°çš„æ—¶å€™ï¼Œä»£è¡¨è¯¥æˆå‘˜å‡½æ•°ä¸å¯ä»¥ä¿®æ”¹ç±»å†…éƒ¨çš„æˆå‘˜å˜é‡ã€‚\n\n```cpp\n\nclass dummy\n{\npublic:\n    int getX() const\n    {\n        // x = 10  compplie error\n        return x;\n    } \n\nprivate:\n    int x;\n}\n\n```\n\n> getXä½œä¸ºconstæˆå‘˜å‡½æ•°ï¼Œå¼ºè¡Œä¿®æ”¹ä¼šé€ æˆç¼–è¯‘é”™è¯¯.\n> ä½†æ˜¯é€šè¿‡mutableå…³é”®å­—ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹mutableä¿®é¥°çš„æˆå‘˜å˜é‡è¿›è¡Œä¿®æ”¹ã€‚\n\n```cpp\nclass dummy_mutable\n{\npublic:\n    std::string get(std::string key) \n    {\n        if (key == last_key) \n        {\n            return last_value;\n        }\n\n        std::string value = {this->lookup(last_key)};\n\n        last_key_ = key;\n        last_value_ = value;\n    }\nprivate:\n    mutable std::string last_key_;\n    mutable std::string last_value_;\n}\n```\n\nåœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åœ¨constæˆå‘˜å‡½æ•°get()ä¸­ä¿®æ”¹äº†last_key_ä»¥åŠlast_value_\nçš„å€¼ï¼Œè¿™å°±æ˜¯mutableçš„ä½œç”¨ã€‚\n\n\n\n","tags":["C++"]},{"title":"LeetCode 424_LongestRepeatingCharacterReplacement","url":"/2019/07/13/LeetCode-424-LongestRepeatingCharacterReplacement/","content":"\n# LeetCode 424 Longest RepeatingCharacterReplacement\n\n## é¢˜ç›®\n\n> Given a string s that consists of only uppercase English letters, you can perform at \n> most k operations on that string.In one operation, you can choose any character of the \n> string and change it to any other uppercase English character.Find the length of the longest\n> sub-string containing all repeating letters you can get after performing the above operations.\n\n## é¢˜æ„\n\næœ¬é¢˜çš„æ„æ€æ˜¯ï¼Œç»™å®šä¸€ä¸ªåªå«æœ‰å°å†™å­—æ¯çš„å•è¯ï¼Œæœ€å¤šå¯ä»¥è¿›è¡ŒKæ¬¡æ›¿æ¢ï¼Œæ‰¾åˆ°é•¿åº¦æœ€é•¿çš„ç›¸åŒå­—æ¯å­—ä¸²ã€‚\n\næœ¬é¢˜ä¸€å¼€å§‹çœ‹çš„æ—¶å€™è¿˜ä»¥ä¸ºæ˜¯dp = =ï¼Œåæ¥æƒ³èµ·æ¥æˆ‘æœ€è¿‘åˆ·çš„å…¨æ˜¯Two Pointersç±»å‹â€¦ æ‰€ä»¥å°±å¾€Slide Windowæ–¹å‘\næƒ³ï¼Œè¿˜æ˜¯åŸºæœ¬æ“ä½œï¼Œä¸€ä¸ªæŒ‡å‘begï¼Œä¸€ä¸ªæŒ‡å‘endâ€¦ä½†æ˜¯åæ¥çœ‹äº†Discussï¼Œè¿™ä¸ªè§£æ³•çœŸçš„æƒŠåˆ°æˆ‘äº†ï¼Œå±å®ä¼˜é›…ã€‚\n\nç”¨ä¸€ä¸ªmpæ¥è®°å½•slide windowä¸­ç»è¿‡çš„æ‰€æœ‰å­—æ¯ï¼Œä½†æ˜¯è¿™ä¸ªé‡Œé¢åªæœ‰ä¸¤ç§å­—æ¯ï¼Œä¸€ä¸ªæ˜¯æ•°é‡æœ€å¤šçš„ç›¸åŒå­—æ¯ï¼Œæˆ‘ä»¬ç”¨same\nè¡¨ç¤ºï¼Œè¿˜æœ‰0-kä¸ªå­—æ¯æ˜¯æ›¿æ¢æˆsameå­—æ¯çš„ï¼Œå¦‚æœæ­¤æ—¶åˆšå¥½æœ‰kä¸ªå­—æ¯è¢«æ›¿æ¢ï¼Œé‚£ä¹ˆæ›¿æ¢å­—æ¯é‡è¾¾åˆ°æœ€å¤§ï¼Œæ­¤æ—¶åº”è¯¥æœ‰\nk + same == end - beg.ä¸€æ—¦end - beg å¤§äº k + same,è¯´æ˜æˆ‘ä»¬çš„slide windowéœ€è¦ç¼©å°ï¼Œå³beg++ï¼Œè¿™å°±æ˜¯å…¨éƒ¨è¿‡ç¨‹ã€‚\n\n## Code\n\n```cpp\nint characterReplacement(string s, int k)\n{\n    int beg = 0, end = 0;\n    int len = s.length();\n    int same = 0;\n    int mp[130];\n\n    memset(mp, 0, sizeof(mp));\n\n    while (end < len) {\n        same = max(same, ++mp[s[end++]]);\n        if (end - beg - same > k)\n            --mp[s[beg++]];\n    }\n    return end - beg;\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["ç®—æ³•"]},{"title":"LeetCode 992 SubarraysOfKDistincts","url":"/2019/07/12/LeetCode-992-SubarraysOfKDistincts/","content":"\n\n# LeetCode 992 SubarraysOfKDistincts \n\n## é¢˜ç›®\n\n> Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of \n> A good if the number of different integers in that subarray is exactly K.\n> (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\n> Return the number of good subarrays of A.\n\næœ¬é¢˜çš„æ„æ€æ˜¯è¯´ï¼Œåœ¨ç»™å®šçš„æ•°ç»„ä¸­ï¼Œæœ‰å¤šå°‘ä¸ªå­æ•°ç»„åˆšå¥½å«æœ‰Kä¸ªæ•°å­—ã€‚\n\n## é¢˜è§£\n\nä¸€å¼€å§‹æƒ³åˆ°çš„æ˜¯ç”¨ä¸€ä¸ªSlide Windowï¼Œä½†æ˜¯åªæ˜¯ç®€å•çš„ç”¨ä¸€ä¸ªdeqæ¥åšæ»‘åŠ¨çª—å£ï¼Œæœ‰å¯èƒ½ä¼šé”™è¿‡ä¸€äº›æƒ…å†µã€‚\nåæ¥å’Œå®¤å‹è®¨è®ºçš„æ–¹æ³•æ˜¯ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ï¼Œä»¥æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä¸ºèµ·å§‹å…ƒç´ æ¥å‘åéå†ï¼Œä¸€ç›´åˆ°æœ€å³ç«¯ï¼Œ\nå³å½“å‰å­—æ•°ç»„ä¸­åŒ…å«çš„æ•°å­—æ•°é‡ä¸ºKä½ç½®ï¼Œåé¢è®¾ç½®ä¸€ä¸ªç‰¹æ®Šæ ‡å¿—ä¸ºå¦‚INFç­‰ã€‚ä½†æ˜¯è¿™ä¸ªæ ·å­å…¶å®å¤æ‚åº¦\nè¾ƒé«˜ï¼Œä¸å…·æœ‰å¯è¡Œæ€§ã€‚\n\nååœ¨Youtubeä¸Šåˆ·åˆ°äº†é¢˜è§£ï¼Œè¿™ä¸ªé¢˜å®Œå…¨å¯ä»¥ä»¥é«˜ä¸­æ—¶å€™çš„æ€è·¯æ¥åšï¼ŒåŸé¢˜ä¸ºæ±‚åˆšå¥½å«æœ‰Kä¸ªæ•°å­—ï¼Œæˆ‘ä»¬æ”¹ä¸ºï¼Œ\nå®Œæ•´éå†ä¸€éAæ•°ç»„ï¼Œæ¯æ¬¡ += f(K) = ä»¥å½“å‰å­—ç¬¦ç»“å°¾çš„å­ä¸²è‡³å¤šå«æœ‰Kä¸ªæ•°å­—ã€‚åŒæ—¶ï¼Œä½¿ç”¨f(k) - f(k-1)\nå°±å¯ä»¥å¾—å‡ºé¢˜ç›®çš„è§£ã€‚ \n\nè¿˜æœ‰ä¸€ä¸ªè¦ç‚¹æ˜¯ï¼šæˆ‘ä»¬è®¡ç®—è‡³å¤šå«æœ‰Kä¸ªæ•°å­—å…¶å®æœ‰å¾ˆå¤šç§è§£æ³•ï¼Œä½†æ˜¯å¯ä»¥åœ¨éå†çš„æ—¶å€™ï¼Œé€šè¿‡æ»‘åŠ¨çª—å£çš„ä¸¤ä¾§\nçš„å·®å€¼+1ï¼Œå°±æ˜¯ä»¥å½“å‰å­—ç¬¦ç»“å°¾çš„å­—ä¸²æ•°é‡.\n\n## Code\n\n```cpp\n\nint subarraysWithKDistinct(vector<int>& A, int k)\n{\n\tint n = A.size();\n\tint res;\n\n\tauto sub = [&A](int k) {\n\t\tint ans = 0;\n\t\tint i = 0;\n\t\tint mp[20005];\n\t\tmemset(mp, 0, sizeof(mp));\n\t\t//å¾ªç¯å¼€å§‹\n\t\tfor (int j = 0; j < A.size(); j++)\n\t\t{\n\t\t\tif (mp[A[j]]++ == 0)\n\t\t\t\t--k;\n\t\t\twhile (k < 0)\n\t\t\t\tif (--mp[A[i++]] == 0) ++k; //kä¸º0æ—¶å°±å°†æ»‘åŠ¨çª—å£çš„å·¦ä¾§å·¦ç§»\n\t\t\tans += j - i + 1; \t//ä»¥å½“å‰æ»‘åŠ¨çª—å£ä¸ºæœ€å³ä¾§çš„å­—ç¬¦ä¸²ä¸ºendçš„å­—ä¸²çš„æ•°é‡\n\t\t}\n\t\treturn ans;\n\t};\n\treturn sub(k) - sub(k-1);\n}\n\n```\n","tags":["C++","Leetcode"],"categories":["ç®—æ³•"]}]